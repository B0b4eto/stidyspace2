<!DOCTYPE html>
<html lang="bg">
<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Space</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700&display=swap" rel="stylesheet">
    <style>
        :root{
            --bg:#e6f2ff;
            --glass-1: rgba(255,255,255,0.65);
            --glass-2: rgba(230,245,255,0.40);
            --accent:#0b63c7; /* stronger blue */
            --accent-2:#009fe6;
            --accent-dark:#05294a;
            --muted:#6b87b7;
            --soft:#f6fbff;
            --frame-pad:clamp(14px,2.2vw,28px);
            --gap:clamp(10px,1.4vw,18px);
        }

        *{box-sizing:border-box}
        html,body{height:100%}
        /* Dark page background (edge-to-edge) */
        body{margin:0;font-family:'Montserrat',Arial,sans-serif;background:
            linear-gradient(180deg, rgba(32, 102, 255, 0.72), rgba(255, 255, 255, 0.5)),
            url('assets/bg-silk.jpg') center/cover no-repeat;
            color:var(--accent-dark);display:block;padding:0;min-height:100vh}

        /* Frame remains transparent */
        .frame{
            width:100vw;
            max-width:100%;
            background:transparent; /* no glass panel */
            border-radius:0;
            padding:clamp(18px,3.2vw,36px) clamp(20px,4vw,56px);
            -webkit-backdrop-filter: none;
            backdrop-filter: none;
            border:0;
            box-shadow:none;
            margin:0;
            position:relative;overflow:visible;
        }

        /* Top bar fully transparent so background shows through */
        .topbar{display:flex;align-items:center;justify-content:space-between;padding:12px 8px;gap:var(--gap);background:transparent}

        /* transparent, light glassy icon buttons */
        .icon-btn{width:56px;height:56px;border-radius:999px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(255,255,255,0.14), rgba(255,255,255,0.06));border:1px solid rgba(255,255,255,0.12);box-shadow:0 8px 20px rgba(4,30,60,0.12);position:relative;overflow:hidden;backdrop-filter:blur(6px)}

        /* faint mouse-position reflection (uses CSS vars set by JS) */
        .icon-btn::before{content:'';position:absolute;left:0;top:0;right:0;bottom:0;border-radius:999px;pointer-events:none;z-index:1;mix-blend-mode:screen;background:radial-gradient(circle at var(--mx,50%) var(--my,50%), rgba(255,255,255,0.92) 0%, rgba(255,255,255,0.40) 18%, rgba(255,255,255,0.18) 36%, rgba(255,255,255,0.04) 60%, transparent 75%);opacity:var(--ref-opacity,0);transition:opacity 360ms ease, transform 260ms ease;filter:blur(6px);}

        /* elongated center bar (wide pill) */
        .center-pill{flex:1;display:flex;justify-content:center;padding:0 8px}
        /* pill restored to semi-transparent glass */
        .pill{width:min(1100px,92%);background:linear-gradient(90deg, rgba(255,255,255,0.10), rgba(240,250,255,0.06));border-radius:40px;padding:12px 28px;border:1px solid rgba(255,255,255,0.12);display:flex;justify-content:center;gap:24px;font-weight:800;align-items:center;position:relative;overflow:visible;backdrop-filter:blur(6px)}
        .pill span{font-size:clamp(15px,1.4vw,18px);color:#e6f5ff;position:relative;z-index:2}

        /* subtle inside accent for pill (disabled) */
        .pill::after{content:'';position:absolute;left:6%;right:6%;top:50%;height:0;border-radius:999px;transform:translateY(-50%);background:transparent;opacity:0;pointer-events:none}

        /* white sheen animation for icon buttons (contained inside button) */
        .icon-btn::after{content:'';position:absolute;top:-20%;left:-60%;width:36%;height:140%;background:linear-gradient(120deg, rgba(255,255,255,0.95), rgba(255,255,255,0.65), rgba(255,255,255,0.28));transform:skewX(-22deg) translateX(0);opacity:0;transition:opacity 160ms;z-index:2;pointer-events:none}
        @keyframes button-sheen { from { transform:skewX(-22deg) translateX(-120%); opacity:0 } 10% { opacity:0.9 } to { transform:skewX(-22deg) translateX(220%); opacity:0 } }
        .icon-btn:hover::after{animation: button-sheen 640ms cubic-bezier(.2,.9,.3,1);}

        /* single-run sheen helpers: play only when the element has .sheen-run or .sheen-back */
        .icon-btn.sheen-run::after{animation: button-sheen 900ms cubic-bezier(.18,.8,.25,1) 1 forwards;}
        .icon-btn.sheen-back::after{animation: button-sheen 480ms cubic-bezier(.3,.9,.4,1) 1 reverse;}

        /* helper to force-finish an outgoing sheen so it doesn't linger when another button is hovered */
        .icon-btn.sheen-end::after{transform:skewX(-22deg) translateX(220%) !important;opacity:0 !important;transition:none !important}
        .card.sheen-end::before{transform:skewX(-18deg) translateX(220%) !important;opacity:0 !important;transition:none !important}

        /* Cards area */
        .cards-wrap{margin-top:calc(var(--gap) * 1.2);padding:18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.4), rgba(240,250,255,0.18));border:1px solid rgba(255,255,255,0.6);display:flex;align-items:flex-start;box-shadow:0 8px 24px rgba(45,80,150,0.04)}

        /* Responsive flow: cards will wrap and scale to available width */
        .cards{display:flex;gap:var(--gap);width:100%;flex-wrap:wrap;align-items:flex-start}

        /* Cards: make them light, glassy and button-like */
        .card{
            flex:1 1 clamp(200px,28%,320px);
            min-width:180px;
            min-height:140px;
            padding:18px 20px;
            border-radius:12px;
            background:linear-gradient(180deg, rgba(255,255,255,0.14), rgba(245,250,255,0.06));
            border:1px solid rgba(255,255,255,0.18);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            box-shadow:0 10px 30px rgba(2,18,40,0.12);
            display:flex;flex-direction:column;align-items:center;justify-content:center;font-weight:800;color:var(--accent-dark);text-align:center;
            gap:8px;position:relative;overflow:visible;z-index:2
        }
        .card.selected{outline:3px solid rgba(29,78,216,0.12);box-shadow:0 36px 92px rgba(11,99,199,0.28);transform:translateY(-6px)}
        .card::after{ /* subtle inner sheen */
            content:'';position:absolute;left:0;right:0;top:0;height:40%;border-radius:12px;pointer-events:none;background:linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0));mix-blend-mode:overlay;opacity:0.9;
        }

        /* animated contained sheen for cards (same behaviour as icon buttons) */
        .card::before{content:'';position:absolute;top:-40%;left:-80%;width:60%;height:200%;background:linear-gradient(120deg, rgba(255,255,255,0.9), rgba(255,255,255,0.12), rgba(255,255,255,0));transform:skewX(-20deg) translateX(0);opacity:0;transition:transform 620ms cubic-bezier(.2,.9,.3,1),opacity 220ms;z-index:1;pointer-events:none;border-radius:12px}
        .card:hover::before{transform:translateX(220%);opacity:1}
        .card > .card-content{position:relative;z-index:2}
        .card{cursor:pointer}

        /* single-run sheen helpers: play only when the element has .sheen-run or .sheen-back */
        .card.sheen-run::before{animation: button-sheen 900ms cubic-bezier(.18,.8,.25,1) 1;}
        .card.sheen-back::before{animation: button-sheen 480ms cubic-bezier(.3,.9,.4,1) 1 reverse;}

        /* ensure pseudo-elements are always clipped to the button area */
        .icon-btn,.card{overflow:hidden}

        @media (prefers-reduced-motion: reduce){
            .card::before{transition:none;opacity:0}
            .icon-btn::after{animation:none;opacity:0}
        }

        /* When there is little space, stack cards vertically */
        @media (max-width:640px){
            .topbar{gap:10px}
            .pill{min-width:160px;padding:clamp(8px,4vw,14px)}
            .cards{flex-direction:column}
            .card{width:100%;flex-basis:auto}
            .card.add{order:-1}
        }

        /* dark reduced motion preference */
        @media (prefers-reduced-motion: reduce){
            .card:hover{transform:none;transition:none}
            .card.land{animation:none}
            .icon-btn::after,.icon-btn::before{transition:none;opacity:0}
        }

        /* Glass only on icon buttons: controlled sheen animation that stays inside button */
        .icon-btn{overflow:hidden}
        .icon-btn::after{content:'';position:absolute;top:-40%;left:-80%;width:60%;height:200%;background:linear-gradient(120deg, rgba(255,255,255,0.9), rgba(255,255,255,0.12), rgba(255,255,255,0));transform:skewX(-20deg) translateX(0);opacity:0;transition:transform 620ms cubic-bezier(.2,.9,.3,1),opacity 220ms;z-index:1}
        .icon-btn:hover::after{transform:translateX(220%);opacity:1}
        .icon-btn > div{position:relative;z-index:3}

        /* Disable CSS-only hover sheen except when JS has applied the single-run classes */
        .icon-btn:not(.sheen-run):not(.sheen-back):hover::after,
        .card:not(.sheen-run):not(.sheen-back):hover::before{animation:none !important;transform:none !important;opacity:0 !important}

        /* gentle lift on hover (now JS-controlled via .lift) */
        .card.lift{transform:translateY(-6px);box-shadow:0 26px 64px rgba(6,40,90,0.12);transition:transform 240ms cubic-bezier(.2,.9,.3,1),box-shadow 240ms}
        .icon-btn.lift{transform:translateY(-4px);box-shadow:0 18px 44px rgba(6,40,90,0.10);transition:transform 220ms cubic-bezier(.2,.9,.3,1),box-shadow 220ms}

        /* 'Land' animation: smooth return to original position without overshoot */
        @keyframes land { from { transform: translateY(-8px); } to { transform: translateY(0); } }
        .card.land { animation: land 220ms cubic-bezier(0.22, 0.9, 0.36, 1); }
        .icon-btn.land { animation: land 200ms cubic-bezier(0.22, 0.9, 0.36, 1); }

        /* faint mouse-position reflection for pill */
        .pill{overflow:hidden}
        .pill::before{
            content:'';position:absolute;left:0;top:0;right:0;bottom:0;border-radius:40px;pointer-events:none;z-index:1;mix-blend-mode:screen;
            background:radial-gradient(circle at var(--mx,50%) var(--my,50%), rgba(255,255,255,0.92) 0%, rgba(255,255,255,0.42) 16%, rgba(255,255,255,0.18) 34%, rgba(255,255,255,0.06) 60%, transparent 76%);
            opacity:var(--pill-ref-opacity,0);transition:opacity 420ms ease, transform 260ms ease;filter:blur(8px);
        }
        .pill::after{z-index:2}
        .pill > span{position:relative;z-index:3}

        .home-clipboard{position:relative;display:flex;flex-direction:column;align-items:center;width:min(1100px,92%);gap:10px;z-index:1;padding-bottom:24px}
        .home-clipboard.open{z-index:460}
        .home-clipboard .pill{width:100%;position:relative;padding-right:110px;padding-left:28px;padding-top:10px;padding-bottom:10px;border-radius:34px}
        .home-capsule{justify-content:center;gap:20px;cursor:default;transition:transform 0.5s cubic-bezier(.25,.85,.35,1),box-shadow 0.4s ease,border-color 0.25s ease;min-height:48px;outline:none;position:relative;z-index:2;box-shadow:0 12px 34px rgba(6,40,90,0.14);will-change:transform,box-shadow}
        .home-capsule:focus-visible{box-shadow:0 0 0 3px rgba(11,99,199,0.28)}
        .home-capsule span{color:#e6f5ff;font-size:clamp(15px,1.4vw,18px);font-weight:inherit}
        .home-clipboard-count{position:absolute;top:50%;right:12px;min-width:32px;height:22px;padding:0 12px;border-radius:999px;background:linear-gradient(135deg,var(--accent),var(--accent-2));color:#fff;font-size:11px;font-weight:700;display:flex;align-items:center;justify-content:center;box-shadow:0 16px 36px rgba(11,99,199,0.32);transform:translateY(-50%) scale(0);opacity:0;transition:transform 0.3s ease,opacity 0.3s ease;pointer-events:none;z-index:4}
        .home-clipboard.has-items .home-clipboard-count{transform:translateY(-50%) scale(1);opacity:1}
        .home-clipboard.drag-ready{z-index:480}
        .home-clipboard.drag-ready .home-capsule{transform:scale(1.12);box-shadow:0 58px 120px rgba(6,40,90,0.26);border-color:rgba(255,255,255,0.32)}
        .home-clipboard.captured .home-capsule{animation:homeCapsuleSnap 0.6s cubic-bezier(.3,1.2,.3,1)}
        @keyframes homeCapsuleSnap{0%{transform:scale(1.08);}50%{transform:scale(0.96);}100%{transform:scale(1);}}
        .home-clipboard-panel{position:absolute;left:0;top:calc(100% - 10px);width:100%;background:linear-gradient(200deg, rgba(255,255,255,0.28), rgba(235,245,255,0.12));border:1px solid rgba(255,255,255,0.32);border-radius:30px;padding:0 24px;max-height:0;opacity:0;overflow:hidden;transition:max-height 0.45s cubic-bezier(.25,.9,.3,1),opacity 0.28s ease,padding 0.3s ease,transform 0.35s cubic-bezier(.3,.95,.4,1);pointer-events:none;backdrop-filter:blur(24px);box-shadow:0 44px 88px rgba(5,20,45,0.32);transform:translateY(-26px) scaleY(0.88);transform-origin:top center}
        .home-clipboard-panel::before{content:'';position:absolute;left:40px;right:40px;top:-28px;height:36px;border-radius:20px;background:linear-gradient(200deg, rgba(255,255,255,0.3), rgba(235,245,255,0.14));opacity:0;transform:translateY(12px);transition:opacity 0.32s ease,transform 0.32s cubic-bezier(.3,.95,.4,1);pointer-events:none}
        .home-clipboard.open .home-clipboard-panel{max-height:420px;opacity:1;padding:22px 24px 26px;pointer-events:auto;transform:translateY(0) scaleY(1);overflow:auto}
        .home-clipboard.open .home-clipboard-panel::before{opacity:1;transform:translateY(0)}
        .home-clipboard.open .home-clipboard-panel::-webkit-scrollbar{width:8px}
        .home-clipboard.open .home-clipboard-panel::-webkit-scrollbar-thumb{background:rgba(11,99,199,0.3);border-radius:999px}
        .home-clipboard-empty{margin:0 0 12px;font-size:13px;color:rgba(230,245,255,0.82);text-align:center}
        .home-clipboard.has-items .home-clipboard-empty{display:none}
        .home-clipboard-list{list-style:none;margin:0;padding:0;display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:14px}
        .home-clipboard-item{position:relative;display:flex;align-items:flex-start;gap:14px;padding:14px 16px;border-radius:18px;background:rgba(255,255,255,0.18);border:1px solid rgba(255,255,255,0.28);box-shadow:0 18px 42px rgba(5,20,45,0.18);cursor:grab;transition:transform 0.25s ease,box-shadow 0.25s ease,opacity 0.2s ease}
        .home-clipboard-item:hover{transform:translateY(-4px);box-shadow:0 24px 52px rgba(5,20,45,0.24)}
        .home-clipboard-item:active{cursor:grabbing}
        .home-clipboard-item.dragging{opacity:0.65;transform:scale(0.98)}
        .home-clipboard-preview{flex:0 0 64px;width:64px;height:64px;border-radius:14px;background:rgba(255,255,255,0.16);border:1px solid rgba(255,255,255,0.26);overflow:hidden;display:flex;align-items:center;justify-content:center;color:var(--accent-dark);text-align:center}
        .home-clipboard-preview img{width:100%;height:100%;object-fit:cover;display:block}
        .home-clipboard-preview-icon{font-size:24px}
        .home-clipboard-info{flex:1;display:flex;flex-direction:column;gap:6px;min-width:0}
        .home-clipboard-item-title{font-size:13px;font-weight:600;color:var(--accent-dark);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .home-clipboard-snippet{font-size:11px;line-height:1.35;color:var(--accent-dark);margin:0;overflow:hidden;display:-webkit-box;line-clamp:2;-webkit-line-clamp:2;-webkit-box-orient:vertical}
        .home-clipboard-item-details{font-size:10px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px}

        @media (max-width:640px){
            .home-capsule{flex-direction:column;align-items:center;gap:8px}
            .home-capsule span{text-align:center}
            .home-clipboard-count{top:50%;right:12px;transform:translateY(-50%) scale(0)}
            .home-clipboard.has-items .home-clipboard-count{transform:translateY(-50%) scale(1)}
        }

        @media (prefers-reduced-motion: reduce){
            .home-capsule{transition:none}
            .home-clipboard-panel{transition:none;transform:none}
            .home-clipboard.drag-ready .home-capsule{transform:none;box-shadow:0 12px 34px rgba(6,40,90,0.14)}
            .home-clipboard.captured .home-capsule{animation:none}
        }

        /* Custom Blocks Styles */
        .custom-blocks-wrap {
            margin-top: calc(var(--gap) * 2);
            padding: 0;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--gap);
            padding: 0 8px;
        }

        .section-title {
            font-size: clamp(18px, 2.2vw, 24px);
            font-weight: 700;
            color: var(--accent-dark);
            margin: 0;
        }

        .edit-btn {
            padding: 8px 16px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            background: linear-gradient(180deg, rgba(255,255,255,0.2), rgba(245,250,255,0.08));
            backdrop-filter: blur(8px);
            font-family: 'Montserrat', sans-serif;
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-dark);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .edit-btn::before {
            content: '';
            position: absolute;
            top: -40%;
            left: -80%;
            width: 60%;
            height: 200%;
            background: linear-gradient(120deg, rgba(255, 255, 255, 0.9), rgba(255,255,255,0.12), rgba(255,255,255,0));
            transform: skewX(-20deg) translateX(0);
            opacity: 0;
            transition: transform 620ms cubic-bezier(.2,.9,.3,1), opacity 220ms;
            z-index: 1;
            pointer-events: none;
            border-radius: 12px;
        }

        .edit-btn:hover::before {
            transform: skewX(-20deg) translateX(220%);
            opacity: 1;
        }

        .edit-btn > span {
            position: relative;
            z-index: 2;
        }

        .edit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(6,40,90,0.12);
            border-color: rgba(255,255,255,0.4);
        }

        .edit-btn.active {
            background: linear-gradient(180deg, var(--accent-2), var(--accent));
            color: white;
            border-color: var(--accent);
        }

        .edit-btn.active:hover {
            background: linear-gradient(180deg, var(--accent), var(--accent-2));
        }

        .custom-blocks {
            display: block; /* Always use block layout for absolute positioning */
            position: relative;
            gap: var(--gap);
            width: 100%;
            transition: all 0.3s ease;
            min-height: 400px; /* Ensure minimum container height */
        }

        /* Grid mode for free positioning */
        .custom-blocks.edit-mode {
            position: relative;
            min-height: 600px;
            background-size: clamp(15px, 2vw, 25px) clamp(15px, 2vw, 25px);
            background-size: clamp(15px, 2vw, 25px) clamp(15px, 2vw, 25px);
            background-position: 0 0;
            display: block; /* Change from grid to block for free positioning */
            animation: gridFadeIn 0.3s ease;
            overflow: visible; /* Allow content to extend beyond initial bounds */
            transition: min-height 0.3s ease, background-size 0.3s ease; /* Smooth height and grid transitions */
        }

        @keyframes gridFadeIn {
            from { 
                background-image: none;
                background-size: 0;
            }
            to { 
                background-image: radial-gradient(circle, rgba(107, 135, 183, 0.3) 2px, transparent 2px);
                background-size: clamp(15px, 2vw, 25px) clamp(15px, 2vw, 25px);
            }
        }

        @keyframes gridFadeOut {
            from { 
                background-image: radial-gradient(circle, rgba(107, 135, 183, 0.3) 2px, transparent 2px);
                background-size: clamp(15px, 2vw, 25px) clamp(15px, 2vw, 25px);
            }
            to { 
                background-image: none;
                background-size: 0;
            }
        }

        .custom-blocks.edit-mode-exit {
            animation: gridFadeOut 0.3s ease;
        }

        .custom-block {
            --block-bg: linear-gradient(180deg, rgba(255,255,255,0.25), rgba(245,250,255,0.08));
            --block-border: rgba(255,255,255,0.25);
            --block-shadow: 0 12px 32px rgba(2,18,40,0.08);
            padding: clamp(16px, 3vw, 20px);
            border-radius: clamp(12px, 2vw, 16px);
            background: var(--block-bg);
            border: 1px solid var(--block-border);
            backdrop-filter: blur(10px);
            box-shadow: var(--block-shadow);
            position: absolute; /* Always use absolute positioning */
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            resize: none; /* Disabled by default */
            min-width: clamp(250px, 35vw, 280px);
            min-height: clamp(160px, 20vh, 180px);
            max-width: calc(100vw - clamp(40px, 8vw, 80px));
            width: clamp(280px, 40vw, 320px);
            height: clamp(180px, 25vh, 220px);
            z-index: 1;
        }

        /* Edit mode styles */
        .custom-blocks.edit-mode {
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }

        .custom-block.edit-mode {
            cursor: move;
            border: 2px dashed var(--accent-2);
            background: var(--block-bg);
            resize: both;
            overflow: hidden; /* Remove scrollbars and adapt content */
            transition: border-color 0.3s ease, background 0.3s ease, transform 0.2s ease;
            z-index: 10; /* Higher z-index in edit mode */
        }
        
        /* Adaptive content styling for edit mode */
        .custom-block.edit-mode .block-content {
            height: calc(100% - 60px); /* Account for header and padding */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding: 12px;
            box-sizing: border-box;
        }
        
        .custom-block.edit-mode .block-header {
            height: 48px;
            min-height: 48px;
            flex-shrink: 0;
            overflow: hidden;
        }
        
        .custom-block.edit-mode .block-header h4 {
            font-size: clamp(14px, 2vw, 18px);
            margin: 0;
            line-height: 1.2;
        }
        
        /* Responsive content elements */
        .custom-block.edit-mode .reminder-list,
        .custom-block.edit-mode .music-controls,
        .custom-block.edit-mode .storage-options,
        .custom-block.edit-mode .weather-info,
        .custom-block.edit-mode .quote-text {
            font-size: clamp(12px, 1.5vw, 16px);
            line-height: 1.3;
            overflow: hidden;
        }
        
        .custom-block.edit-mode .music-controls {
            justify-content: center;
            gap: clamp(8px, 1vw, 16px);
        }
        
        .custom-block.edit-mode .music-btn {
            min-width: clamp(32px, 3vw, 48px);
            height: clamp(32px, 3vw, 48px);
            font-size: clamp(12px, 1.5vw, 18px);
        }

        /* Enhanced responsive behavior for all block content */
        .custom-block .block-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .custom-block .block-content * {
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        /* Responsive text scaling */
        .custom-block .reminder-item input[type="text"],
        .custom-block .song-info,
        .custom-block .weather-details,
        .custom-block .quote-text,
        .custom-block .link-input {
            font-size: clamp(11px, 1.2vw, 15px);
            line-height: 1.4;
        }
        
        /* Responsive button scaling */
        .custom-block .music-btn,
        .custom-block .link-btn,
        .custom-block .storage-option {
            font-size: clamp(11px, 1.1vw, 14px);
            padding: clamp(6px, 0.8vw, 12px) clamp(10px, 1.2vw, 16px);
            min-height: clamp(28px, 2.5vw, 40px);
        }
        
        /* Responsive icon scaling */
        .custom-block .block-icon {
            width: clamp(32px, 3vw, 44px);
            height: clamp(32px, 3vw, 44px);
            font-size: clamp(18px, 2vw, 26px);
        }
        
        /* Enhanced content adaptation for very small blocks */
        @media (max-width: 480px) {
            .custom-block.edit-mode .block-header {
                margin-bottom: clamp(8px, 2vw, 16px);
                gap: clamp(6px, 1.5vw, 12px);
            }
            
            .custom-block.edit-mode .block-content {
                padding: clamp(8px, 2vw, 12px);
            }
        }

        /* Delete button for blocks */
        .delete-btn {
            position: absolute;
            top: 8px;
            left: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff4757, #ff3742);
            border: none;
            color: white;
            font-size: 14px;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 15;
            display: none; /* Hidden by default */
        }

        .custom-block.edit-mode .delete-btn {
            display: flex; /* Show only in edit mode */
        }

        .custom-block.edit-mode .delete-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(255, 71, 87, 0.4);
        }

        /* Add block trigger */
        .add-block-btn {
            position: fixed;
            bottom: clamp(24px, 5vw, 48px);
            right: clamp(24px, 6vw, 64px);
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color: #fff;
            font-size: 32px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 20px 50px rgba(11, 99, 199, 0.35);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.25s cubic-bezier(.2,.9,.3,1), box-shadow 0.25s ease, opacity 0.2s ease;
            z-index: 1800;
            opacity: 0;
            pointer-events: none;
            transform: scale(0.9);
            visibility: hidden;
        }

        .add-block-btn.visible {
            opacity: 1;
            pointer-events: auto;
            transform: scale(1);
            visibility: visible;
        }

        .add-block-btn:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 28px 62px rgba(11, 99, 199, 0.4);
        }

        .add-block-btn:focus-visible {
            outline: 3px solid rgba(255,255,255,0.7);
            outline-offset: 4px;
        }

        @media (max-width: 680px) {
            .add-block-btn {
                width: 56px;
                height: 56px;
                font-size: 28px;
                bottom: clamp(18px, 6vw, 32px);
                right: clamp(18px, 8vw, 36px);
            }
        }

        /* Block builder modal */
        .block-selector-modal {
            position: fixed;
            inset: 0;
            background: rgba(9, 23, 43, 0.55);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            padding: clamp(20px, 4vw, 48px);
            z-index: 2200;
        }

        .block-selector-modal.show {
            display: flex;
        }

        .builder-panel {
            position: relative;
            width: min(620px, 92vw);
            background: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(235,245,255,0.9));
            border-radius: 28px;
            padding: clamp(26px, 3vw, 36px);
            box-shadow: 0 40px 90px rgba(5,20,45,0.35);
            border: 1px solid rgba(255,255,255,0.7);
            display: flex;
            flex-direction: column;
            gap: clamp(16px, 2vw, 22px);
        }

        .builder-close {
            position: absolute;
            top: 14px;
            right: 16px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: rgba(11,99,199,0.12);
            color: var(--accent-dark);
            font-size: 22px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        .builder-close:hover {
            background: rgba(11,99,199,0.22);
            transform: rotate(90deg);
        }

        .builder-title {
            margin: 0;
            font-size: clamp(22px, 2.4vw, 28px);
            color: var(--accent-dark);
        }

        .builder-subtitle {
            margin: 0;
            font-size: clamp(13px, 1.4vw, 15px);
            color: var(--muted);
        }

        .builder-type-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .builder-type-btn {
            flex: 1;
            min-width: 140px;
            padding: 12px 16px;
            border-radius: 16px;
            border: 1px solid rgba(11,99,199,0.2);
            background: rgba(255,255,255,0.6);
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 14px;
            color: var(--accent-dark);
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .builder-type-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 26px rgba(11,99,199,0.2);
        }

        .builder-type-btn.active {
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color: #fff;
            border-color: var(--accent);
            box-shadow: 0 16px 40px rgba(11,99,199,0.35);
        }

        #blockBuilderForm {
            display: flex;
            flex-direction: column;
            gap: clamp(18px, 2vw, 24px);
        }

        .builder-section {
            display: none;
            flex-direction: column;
            gap: clamp(12px, 1.6vw, 18px);
        }

        .builder-section.active {
            display: flex;
        }

        .builder-field {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .builder-field label {
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-dark);
        }

        .builder-field input,
        .builder-field select,
        .builder-field input[type="color"] {
            width: 64px;
            height: 40px;
            padding: 0;
            border-radius: 12px;
            border: 2px solid rgba(11,99,199,0.25);
            background: transparent;
            cursor: pointer;
        }

        .builder-field input[type="color"]:hover {
            border-color: rgba(11,99,199,0.45);
        }

        .builder-color-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .builder-color-value {
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-dark);
            letter-spacing: 0.4px;
            text-transform: uppercase;
        }

        .builder-field textarea {
            font-family: 'Montserrat', sans-serif;
            font-size: 14px;
            border-radius: 12px;
            border: 1px solid rgba(11,99,199,0.16);
            padding: 12px;
            background: rgba(255,255,255,0.7);
            color: var(--accent-dark);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .builder-field textarea {
            resize: vertical;
            min-height: 80px;
        }

        .builder-field input:focus,
        .builder-field select:focus,
        .builder-field textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(11,99,199,0.18);
        }

        .builder-checklist-items {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .builder-checklist-item {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            align-items: center;
        }

        .builder-checklist-item input {
            width: 100%;
        }

        .builder-remove-item {
            border: none;
            background: rgba(11,99,199,0.1);
            color: var(--accent-dark);
            width: 36px;
            height: 36px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 18px;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        .builder-remove-item:hover {
            background: rgba(11,99,199,0.22);
            transform: scale(1.05);
        }

        .builder-add-item {
            align-self: flex-start;
            padding: 10px 16px;
            border-radius: 12px;
            border: 1px dashed rgba(11,99,199,0.4);
            background: rgba(255,255,255,0.5);
            color: var(--accent);
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .builder-add-item:hover {
            border-style: solid;
            transform: translateY(-1px);
            box-shadow: 0 12px 26px rgba(11,99,199,0.25);
        }

        .builder-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 8px;
        }

        .builder-primary,
        .builder-secondary {
            border-radius: 14px;
            padding: 12px 22px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(.2,.9,.3,1), box-shadow 0.2s ease;
            border: 1px solid transparent;
        }

        .builder-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color: #fff;
            box-shadow: 0 16px 40px rgba(11,99,199,0.3);
        }

        .builder-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 22px 54px rgba(11,99,199,0.38);
        }

        .builder-secondary {
            background: rgba(255,255,255,0.7);
            color: var(--accent-dark);
            border-color: rgba(11,99,199,0.18);
        }

        .builder-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 30px rgba(11,99,199,0.18);
        }

        @media (max-width: 540px) {
            .builder-actions {
                flex-direction: column;
                align-items: stretch;
            }

            .builder-primary,
            .builder-secondary {
                width: 100%;
                text-align: center;
            }

            .builder-type-grid {
                flex-direction: column;
            }

            .builder-remove-item {
                width: 32px;
                height: 32px;
                border-radius: 10px;
            }
        }

        /* New Block Types Styles */
        .reminder-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            padding: 6px 0;
        }

        .reminder-item input[type="text"] {
            flex: 1;
            background: rgba(255,255,255,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--accent-dark);
        }

        .reminder-item input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-2);
            background: rgba(255,255,255,0.4);
        }

        .music-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 12px;
        }

        .music-platform-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(11,99,199,0.12);
            color: var(--accent-dark);
            font-size: 12px;
            font-weight: 600;
        }

        .music-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255,255,255,0.4), rgba(255,255,255,0.2));
            border: 1px solid rgba(255,255,255,0.3);
            color: var(--accent);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .music-btn:hover {
            transform: scale(1.1);
            background: linear-gradient(135deg, rgba(255,255,255,0.6), rgba(255,255,255,0.4));
        }

        .music-btn.play {
            width: 50px;
            height: 50px;
            font-size: 20px;
        }

        .song-info {
            text-align: center;
            font-size: 12px;
            color: var(--accent-dark);
        }

        .weather-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .weather-icon {
            font-size: 32px;
            line-height: 1;
        }

        .weather-details {
            flex: 1;
        }

        .weather-temp {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 4px;
        }

        .weather-desc {
            font-size: 12px;
            color: var(--muted);
        }

        .quote-text {
            font-size: 14px;
            font-style: italic;
            color: var(--accent-dark);
            line-height: 1.4;
            margin-bottom: 10px;
            text-align: center;
        }

        .quote-author {
            font-size: 12px;
            color: var(--muted);
            text-align: right;
        }

        .link-input {
            width: 100%;
            background: rgba(255,255,255,0.3);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 14px;
            color: var(--accent-dark);
            margin-bottom: 10px;
        }

        .link-input:focus {
            outline: none;
            border-color: var(--accent-2);
            background: rgba(255,255,255,0.4);
        }

        .link-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .link-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(11, 99, 199, 0.3);
        }

        .link-btn.disabled {
            background: rgba(255,255,255,0.6);
            color: var(--muted);
            cursor: not-allowed;
            box-shadow: none;
        }

        .link-btn.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .storage-options {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .storage-option {
            flex: 1;
            padding: 12px;
            background: rgba(255,255,255,0.3);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .storage-option.active {
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color: white;
            border-color: var(--accent);
        }

        .storage-link {
            display: block;
            padding: 12px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            text-decoration: none;
            color: var(--accent-dark);
            font-size: 14px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .storage-link:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .checklist-progress {
            margin-top: 10px;
            font-size: 12px;
            font-weight: 600;
            color: var(--muted);
            text-align: right;
        }

        /* Responsive adjustments for custom blocks */
        @media (max-width: 768px) {
            .custom-blocks {
                grid-template-columns: 1fr;
            }
            
            .custom-block {
                min-width: 100%;
                resize: vertical;
            }
            
            .custom-block.edit-mode {
                max-width: calc(100vw - 40px); /* Adjust for mobile */
            }
            
            .calendar-preview {
                flex-direction: column;
                gap: 12px;
            }
            
            .calendar-date {
                align-self: flex-start;
            }

            .section-header {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }

            .edit-btn {
                align-self: flex-end;
            }
        }

        @media (max-width: 480px) {
            .custom-block {
                padding: 16px;
                min-width: 100%;
                resize: none;
            }
            
            .custom-block.edit-mode {
                max-width: calc(100vw - 20px);
                min-width: 250px;
            }
            
            .section-title {
                font-size: 18px;
            }

            .section-header {
                padding: 0 4px;
            }

            .custom-block.edit-mode::after {
                font-size: 14px;
                top: 6px;
                right: 6px;
            }
        }

            
        /* --- Profile Dropdown --- */
        .profile-container {
            position: relative;
        }

        .profile-icon {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            transition: 0.2s;
        }

        .profile-icon:hover {
            transform: scale(1.07);
        }

        .profile-dropdown {
            position: absolute;
            right: 0;
            top: 58px;
            width: 220px;
            background: #fff;
            border-radius: 12px;
            padding: 10px 0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.22s ease;
            z-index: 999;
        }

        .profile-dropdown.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .dropdown-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
        }

        .dropdown-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .profile-dropdown ul {
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .profile-dropdown li a {
            display: block;
            padding: 12px 18px;
            font-size: 15px;
            color: #333;
            text-decoration: none;
            transition: 0.2s;
        }

        .profile-dropdown li a:hover {
            background: #f5f5f5;
            transform: translateX(3px);
        }
        /* Icon inside dropdown list */
        .profile-dropdown .icon {
            width: 18px;
            height: 18px;
            margin-right: 10px;
            opacity: 0.85;
        }
        
        /* Arrow that appears on hover */
        .profile-dropdown .arrow {
            margin-left: auto;
            opacity: 0;
            transform: translateX(-6px);
            transition: 0.25s ease;
            font-size: 13px;
            color: #666;
        }
        
        /* Hover effect: slide arrow in */
        .profile-dropdown ul li a:hover .arrow {
            opacity: 1;
            transform: translateX(0);
        }
        
        /* Slight move to the right when hovering */
        .profile-dropdown ul li a:hover {
            background: #f5f5f5;
            transform: translateX(4px);
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .custom-block.edit-mode {
                touch-action: none;
            }
            
            .custom-block.edit-mode::before {
                width: 30px;
                height: 30px;
            }
        }
    </style>
    <script src="assets/auth.js" defer></script>
 </head>
 <body>
     <div class="frame">
         <div class="topbar">
             <div class="icon-btn" title="Settings">⚙️</div>

             <div class="center-pill">
                 <div class="home-clipboard" id="homeClipboard">
                     <div class="pill home-capsule" id="homeClipboardCapsule" role="button" tabindex="0" aria-expanded="false" aria-controls="homeClipboardPanel">
                         <span id="date">10 Oct 2025</span>
                         <span id="time">10:48</span>
                         <span class="home-clipboard-count" id="homeClipboardCount" aria-hidden="true">0</span>
                     </div>
                     <div class="home-clipboard-panel" id="homeClipboardPanel" aria-hidden="true">
                         <p class="home-clipboard-empty" id="homeClipboardEmpty">Плъзни файлове върху капсулата, за да ги запазиш временно.</p>
                         <ul class="home-clipboard-list" id="homeClipboardList"></ul>
                     </div>
                 </div>
             </div>

             <div class="profile-container">
                <img src="images/user.png" id="profileBtn" class="profile-icon">

                <div class="profile-dropdown" id="profileDropdown">

                    <div class="dropdown-header">
                        <img src="images/user.png" class="dropdown-avatar">
                        <h4>Your Name</h4>
                    </div>

                    <ul>
                        <li>
                            <a href="edit-profile.html">
                                <img src="images/profile.png" class="icon">
                                Edit Profile
                                <span class="arrow">▶</span>
                            </a>
                        </li>

                        <li>
                            <a href="connect-apps.html">
                                <img src="images/setting.png" class="icon">
                                Connect Apps
                                <span class="arrow">▶</span>
                            </a>
                        </li>

                        <li>
                            <a href="account.html">
                                <img src="images/user.png" class="icon">
                                Your Account
                                <span class="arrow">▶</span>
                            </a>
                        </li>

                        <li>
                            <a href="help.html">
                                <img src="images/help.png" class="icon">
                                Help
                                <span class="arrow">▶</span>
                            </a>
                        </li>

                        <li>
                            <a href="log-in.html">
                                <img src="images/logout.png" class="icon">
                                Logout
                                <span class="arrow">▶</span>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
         </div>

           <div class="cards-wrap">
               <div class="cards" id="recentCards">
                 <div class="card add" role="button" aria-label="Добави нова колекция">
                     <div class="card-content" style="text-align:center">
                         <div class="plus">＋</div>
                         <div class="label">Нова</div>
                     </div>
                 </div>

                 <div class="card">
                     <div class="card-content" style="text-align:center">
                         <div style="font-size:14px;font-weight:800">Последно използвани</div>
                         <div class="label">карта</div>
                     </div>
                 </div>

                 <div class="card">
                     <div class="card-content" style="text-align:center">
                         <div style="font-size:14px;font-weight:800">Последно използвани</div>
                         <div class="label">карта</div>
                     </div>
                 </div>

                 <!-- extra placeholders to show adaptive flow -->
                 <div class="card">
                     <div class="card-content" style="text-align:center;color:var(--muted)">Още</div>
                 </div>
              </div>
          </div>

          <!-- Custom Blocks Section -->
          <div class="custom-blocks-wrap">
              <div class="section-header">
                  <h3 class="section-title">Персонализирани блокове</h3>
                  <button class="edit-btn" id="editBlocksBtn">
                      <span>Редактиране</span>
                  </button>
              </div>
              <div class="custom-blocks" id="customBlocks">
                  <div class="custom-block calendar-block" role="button" aria-label="Календар" data-block-id="calendar" data-default-block="true">
                      <button class="delete-btn" title="Изтрий блок">×</button>
                      <div class="block-header">
                          <div class="block-icon">📅</div>
                          <h4>Календар</h4>
                      </div>
                      <div class="block-content">
                          <div class="calendar-preview">
                              <div class="calendar-date">
                                  <span class="day" id="calendar-day">09</span>
                                  <span class="month">Окт</span>
                              </div>
                              <div class="calendar-events">
                                  <div class="event">📚 Математика - 14:00</div>
                                  <div class="event">📖 История - 16:30</div>
                              </div>
                          </div>
                      </div>
                  </div>

                  <div class="custom-block homework-block" role="button" aria-label="Домашни" data-block-id="homework" data-default-block="true">
                      <button class="delete-btn" title="Изтрий блок">×</button>
                      <div class="block-header">
                          <div class="block-icon">📝</div>
                          <h4>Домашни</h4>
                      </div>
                      <div class="block-content">
                          <div class="homework-list">
                              <div class="homework-item">
                                  <input type="checkbox" id="hw1" checked>
                                  <label for="hw1">Физика - упражнения</label>
                              </div>
                              <div class="homework-item">
                                  <input type="checkbox" id="hw2">
                                  <label for="hw2">Химия - лабораторен отчет</label>
                              </div>
                              <div class="homework-item">
                                  <input type="checkbox" id="hw3">
                                  <label for="hw3">Английски - есе</label>
                              </div>
                          </div>
                          <div class="homework-progress">
                              <span>1 от 3 завършени</span>
                          </div>
                      </div>
                  </div>

                  <div class="custom-block curriculum-block" role="button" aria-label="Учебна програма" data-block-id="curriculum" data-default-block="true">
                      <button class="delete-btn" title="Изтрий блок">×</button>
                      <div class="block-header">
                          <div class="block-icon">🎓</div>
                          <h4>Учебна програма</h4>
                      </div>
                      <div class="block-content">
                          <div class="curriculum-overview">
                              <div class="subject-progress">
                                  <div class="subject">
                                      <span class="subject-name">Математика</span>
                                      <div class="progress-bar">
                                          <div class="progress-fill" style="width: 75%"></div>
                                      </div>
                                  </div>
                                  <div class="subject">
                                      <span class="subject-name">Физика</span>
                                      <div class="progress-bar">
                                          <div class="progress-fill" style="width: 60%"></div>
                                      </div>
                                  </div>
                                  <div class="subject">
                                      <span class="subject-name">Химия</span>
                                      <div class="progress-bar">
                                          <div class="progress-fill" style="width: 45%"></div>
                                      </div>
                                  </div>
                              </div>
                          </div>
                      </div>
                  </div>
              </div>
          </div>
      </div>

      <!-- Add Block Button -->
      <button class="add-block-btn" id="addBlockBtn">+</button>

      <!-- Block Selector Modal -->
      <div class="block-selector-modal" id="blockBuilder">
          <div class="builder-panel" role="dialog" aria-modal="true" aria-labelledby="builderTitle">
              <button class="builder-close" type="button" id="builderCloseBtn" aria-label="Затвори">×</button>
              <h3 class="builder-title" id="builderTitle">Добави персонализиран блок</h3>
              <p class="builder-subtitle">Изберете тип и настройте съдържанието преди да го закачите на таблото.</p>
              <div class="builder-type-grid">
                  <button type="button" class="builder-type-btn active" data-builder-type="music">🎵 Музика</button>
                  <button type="button" class="builder-type-btn" data-builder-type="weather">🌤️ Време</button>
                  <button type="button" class="builder-type-btn" data-builder-type="checklist">✅ Чеклист</button>
              </div>
              <form id="blockBuilderForm">
                  <div class="builder-field" data-builder-shared>
                      <label for="blockColor">Цвят на блока</label>
                      <div class="builder-color-row">
                          <input type="color" id="blockColor" name="blockColor" value="#4d7cff">
                          <span class="builder-color-value" id="builderColorValue">#4D7CFF</span>
                      </div>
                  </div>
                  <div class="builder-section active" data-builder-section="music">
                      <div class="builder-field">
                          <label for="musicTitle">Заглавие</label>
                          <input type="text" id="musicTitle" name="musicTitle" value="Музика" required>
                      </div>
                      <div class="builder-field">
                          <label for="musicPlatform">Платформа</label>
                          <select id="musicPlatform" name="musicPlatform">
                              <option value="spotify">Spotify</option>
                              <option value="apple">Apple Music</option>
                              <option value="youtube">YouTube Music</option>
                              <option value="custom">Друго</option>
                          </select>
                      </div>
                      <div class="builder-field">
                          <label for="musicUrl">Линк към плейлист или албум</label>
                          <input type="url" id="musicUrl" name="musicUrl" placeholder="https://...">
                      </div>
                      <div class="builder-field">
                          <label for="musicNote">Описание (по избор)</label>
                          <textarea id="musicNote" name="musicNote" rows="2" placeholder="Добави кратко описание или настроение"></textarea>
                      </div>
                  </div>

                  <div class="builder-section" data-builder-section="weather" hidden>
                      <div class="builder-field">
                          <label for="weatherTitle">Заглавие</label>
                          <input type="text" id="weatherTitle" name="weatherTitle" value="Време" required>
                      </div>
                      <div class="builder-field">
                          <label for="weatherLocation">Локация</label>
                          <input type="text" id="weatherLocation" name="weatherLocation" placeholder="София, България" required>
                      </div>
                      <div class="builder-field">
                          <label for="weatherUnits">Единици</label>
                          <select id="weatherUnits" name="weatherUnits">
                              <option value="metric">Целзий (°C)</option>
                              <option value="imperial">Фаренхайт (°F)</option>
                          </select>
                      </div>
                  </div>

                  <div class="builder-section" data-builder-section="checklist" hidden>
                      <div class="builder-field">
                          <label for="checklistTitle">Заглавие</label>
                          <input type="text" id="checklistTitle" name="checklistTitle" value="Чеклист" required>
                      </div>
                      <div class="builder-field">
                          <label>Елементи</label>
                          <div class="builder-checklist-items" id="builderChecklistItems"></div>
                          <button type="button" class="builder-add-item" id="builderAddChecklistItem">+ Добави елемент</button>
                      </div>
                  </div>

                  <div class="builder-actions">
                      <button type="button" class="builder-secondary" id="builderCancelBtn">Отказ</button>
                      <button type="submit" class="builder-primary">Добави блок</button>
                  </div>
              </form>
          </div>
      </div>

      <script>
        // Account Dropdown Toggle
        const profileBtn = document.getElementById("profileBtn");
        const profileDropdown = document.getElementById("profileDropdown");
    
        profileBtn.addEventListener("click", () => {
            profileDropdown.classList.toggle("show");
        });
    
        // Close dropdown on outside click
        document.addEventListener("click", (e) => {
            if (!profileBtn.contains(e.target) && !profileDropdown.contains(e.target)) {
                profileDropdown.classList.remove("show");
            }
        });

   function updateDateTime(){
    const d = new Date();
    const dateEl = document.getElementById('date');
    const timeEl = document.getElementById('time');
    if(dateEl) dateEl.textContent = d.toLocaleDateString('bg-BG');
    if(timeEl) timeEl.textContent = d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
}
updateDateTime();
setInterval(updateDateTime, 60000);
      
       

    <script>
        (function(){
            const clipboard = document.getElementById('homeClipboard');
            const capsule = document.getElementById('homeClipboardCapsule');
            const panel = document.getElementById('homeClipboardPanel');
            const list = document.getElementById('homeClipboardList');
            const countEl = document.getElementById('homeClipboardCount');
            const emptyEl = document.getElementById('homeClipboardEmpty');
            if(!clipboard || !capsule || !panel || !list){
                return;
            }

            const reducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            const clipboardElementMap = new Map();
            const TEXT_SNIPPET_TYPES = new Set([
                'application/json',
                'application/xml',
                'application/javascript',
                'application/x-javascript',
                'application/svg+xml'
            ]);
            const MAX_TEXT_PREVIEW_CHARS = 160;
            let clipboardItems = [];
            let clipboardOpen = false;
            let dragDepth = 0;
            let dragGhostEl = null;

            function formatBytes(bytes){
                if(typeof bytes !== 'number' || Number.isNaN(bytes)) return '0 B';
                const units = ['B','KB','MB','GB','TB'];
                let value = bytes;
                let index = 0;
                while(value >= 1024 && index < units.length - 1){
                    value /= 1024;
                    index++;
                }
                const formatted = value % 1 === 0 ? value : value.toFixed(1);
                return `${formatted} ${units[index]}`;
            }

            function pickPreviewIcon(type){
                if(!type) return '📄';
                if(type.includes('sheet') || type.includes('excel') || type.includes('spreadsheet')) return '📊';
                if(type.includes('presentation') || type.includes('powerpoint') || type.includes('slideshow')) return '📽️';
                if(type.includes('word') || type.includes('document') || type.includes('msword')) return '📃';
                if(type.includes('audio')) return '🎵';
                if(type.includes('video')) return '🎬';
                if(type.includes('pdf')) return '📕';
                if(type.includes('zip') || type.includes('compressed') || type.includes('archive')) return '🗜️';
                return '📄';
            }

            function fillPreview(previewEl, item){
                previewEl.innerHTML = '';
                if(item.previewKind === 'image' && item.previewUrl){
                    const img = document.createElement('img');
                    img.src = item.previewUrl;
                    img.alt = item.name;
                    previewEl.appendChild(img);
                } else {
                    const iconEl = document.createElement('div');
                    iconEl.className = 'home-clipboard-preview-icon';
                    iconEl.textContent = item.previewIcon || pickPreviewIcon((item.type || '').toLowerCase());
                    previewEl.appendChild(iconEl);
                }
            }

            function refreshItemPreview(item){
                const record = clipboardElementMap.get(item.id);
                if(record){
                    fillPreview(record.preview, item);
                }
            }

            function updateSnippetDisplay(item){
                const record = clipboardElementMap.get(item.id);
                if(!record) return;
                if(item.snippet){
                    if(record.snippet){
                        record.snippet.textContent = item.snippet;
                    } else {
                        const snippetEl = document.createElement('p');
                        snippetEl.className = 'home-clipboard-snippet';
                        snippetEl.textContent = item.snippet;
                        record.info.insertBefore(snippetEl, record.details);
                        record.snippet = snippetEl;
                    }
                } else if(record.snippet){
                    record.snippet.remove();
                    record.snippet = null;
                }
            }

            function prepareItemPreview(item){
                if(!item || !item.file || item.previewPrepared) return;
                const mime = (item.type || item.file.type || '').toLowerCase();
                if(mime.startsWith('image/')){
                    item.previewKind = 'image';
                    if(!item.previewUrl){
                        item.previewUrl = URL.createObjectURL(item.file);
                    }
                    refreshItemPreview(item);
                } else if(mime.startsWith('text/') || TEXT_SNIPPET_TYPES.has(mime)){
                    item.previewKind = 'icon';
                    item.previewIcon = '📝';
                    refreshItemPreview(item);
                    const snippetSource = item.file.slice(0, 4096);
                    snippetSource.text().then(text => {
                        if(typeof text !== 'string'){
                            item.previewKind = 'icon';
                            item.previewIcon = pickPreviewIcon(mime);
                            refreshItemPreview(item);
                            item.snippet = '';
                            updateSnippetDisplay(item);
                            return;
                        }
                        const cleaned = text.replace(/\s+/g,' ').trim();
                        if(!cleaned){
                            item.previewKind = 'icon';
                            item.previewIcon = pickPreviewIcon(mime);
                            refreshItemPreview(item);
                            item.snippet = '';
                            updateSnippetDisplay(item);
                            return;
                        }
                        item.snippet = cleaned.slice(0, MAX_TEXT_PREVIEW_CHARS);
                        if(cleaned.length > MAX_TEXT_PREVIEW_CHARS){
                            item.snippet = `${item.snippet}…`;
                        }
                        updateSnippetDisplay(item);
                        refreshItemPreview(item);
                    }).catch(()=>{
                        item.previewKind = 'icon';
                        item.previewIcon = pickPreviewIcon(mime);
                        refreshItemPreview(item);
                        item.snippet = '';
                        updateSnippetDisplay(item);
                    });
                } else if(mime.startsWith('video/')){
                    item.previewKind = 'icon';
                    item.previewIcon = '🎬';
                    refreshItemPreview(item);
                } else if(mime.startsWith('audio/')){
                    item.previewKind = 'icon';
                    item.previewIcon = '🎵';
                    refreshItemPreview(item);
                } else if(mime.includes('pdf')){
                    item.previewKind = 'icon';
                    item.previewIcon = '📕';
                    refreshItemPreview(item);
                } else if(mime.includes('sheet') || mime.includes('excel')){
                    item.previewKind = 'icon';
                    item.previewIcon = '📊';
                    refreshItemPreview(item);
                } else if(mime.includes('presentation') || mime.includes('powerpoint')){
                    item.previewKind = 'icon';
                    item.previewIcon = '📽️';
                    refreshItemPreview(item);
                } else if(mime.includes('zip') || mime.includes('compressed')){
                    item.previewKind = 'icon';
                    item.previewIcon = '🗜️';
                    refreshItemPreview(item);
                } else {
                    item.previewKind = 'icon';
                    item.previewIcon = pickPreviewIcon(mime);
                    refreshItemPreview(item);
                }
                item.previewPrepared = true;
            }

            function createDragGhost(entry){
                const ghost = entry.cloneNode(true);
                ghost.style.position = 'absolute';
                ghost.style.top = '-9999px';
                ghost.style.left = '-9999px';
                ghost.style.pointerEvents = 'none';
                ghost.style.width = `${entry.offsetWidth}px`;
                document.body.appendChild(ghost);
                return ghost;
            }

            function handleItemDragStart(event, item, entry){
                entry.classList.add('dragging');
                if(event.dataTransfer){
                    event.dataTransfer.effectAllowed = 'copy';
                    event.dataTransfer.setData('text/plain', item.name);
                    try{
                        event.dataTransfer.setData('application/x-study-clipboard', JSON.stringify({ name: item.name, size: item.size, type: item.displayType || 'Файл', mime: item.type || '' }));
                    } catch(err){
                        // Ignore unsupported structured data
                    }
                    if(event.dataTransfer.items && typeof event.dataTransfer.items.add === 'function' && item.file){
                        try{
                            event.dataTransfer.items.add(item.file);
                        } catch(err){
                            // Some browsers disallow adding files programmatically
                        }
                    }
                    const ghost = createDragGhost(entry);
                    if(ghost){
                        dragGhostEl = ghost;
                        event.dataTransfer.setDragImage(ghost, ghost.offsetWidth / 2, ghost.offsetHeight / 2);
                    }
                }
            }

            function handleItemDragEnd(event){
                event.currentTarget.classList.remove('dragging');
                if(dragGhostEl && dragGhostEl.parentNode){
                    dragGhostEl.parentNode.removeChild(dragGhostEl);
                }
                dragGhostEl = null;
            }

            function createClipboardEntry(item){
                const entry = document.createElement('li');
                entry.className = 'home-clipboard-item';
                entry.setAttribute('draggable', 'true');
                entry.dataset.itemId = item.id;

                const preview = document.createElement('div');
                preview.className = 'home-clipboard-preview';
                fillPreview(preview, item);

                const title = document.createElement('div');
                title.className = 'home-clipboard-item-title';
                title.textContent = item.name;

                const info = document.createElement('div');
                info.className = 'home-clipboard-info';
                info.appendChild(title);

                let snippetEl = null;
                if(item.snippet){
                    snippetEl = document.createElement('p');
                    snippetEl.className = 'home-clipboard-snippet';
                    snippetEl.textContent = item.snippet;
                    info.appendChild(snippetEl);
                }

                const details = document.createElement('div');
                details.className = 'home-clipboard-item-details';
                details.textContent = `${item.displayType || 'Файл'} · ${formatBytes(item.size)}`;
                info.appendChild(details);

                entry.append(preview, info);
                entry.addEventListener('dragstart', (event) => handleItemDragStart(event, item, entry));
                entry.addEventListener('dragend', handleItemDragEnd);

                clipboardElementMap.set(item.id, { entry, preview, info, details, snippet: snippetEl });
                return entry;
            }

            function clearClipboardPreviews(){
                clipboardItems.forEach(item => {
                    if(item.previewUrl){
                        URL.revokeObjectURL(item.previewUrl);
                        item.previewUrl = null;
                    }
                });
            }

            function updateClipboardUI(){
                if(countEl){
                    countEl.textContent = clipboardItems.length.toString();
                    countEl.setAttribute('aria-hidden', clipboardItems.length > 0 ? 'false' : 'true');
                }
                clipboard.classList.toggle('has-items', clipboardItems.length > 0);
                if(emptyEl){
                    emptyEl.setAttribute('aria-hidden', clipboardItems.length > 0 ? 'true' : 'false');
                }
                clipboardElementMap.clear();
                list.innerHTML = '';
                clipboardItems.forEach(item => {
                    prepareItemPreview(item);
                    const entry = createClipboardEntry(item);
                    list.appendChild(entry);
                });
            }

            function setClipboardOpen(nextState){
                if(nextState === clipboardOpen) return;
                clipboardOpen = nextState;
                clipboard.classList.toggle('open', nextState);
                capsule.setAttribute('aria-expanded', nextState ? 'true' : 'false');
                panel.setAttribute('aria-hidden', nextState ? 'false' : 'true');
                if(!nextState){
                    panel.scrollTop = 0;
                }
            }

            function captureClipboardFiles(files){
                let captured = false;
                Array.from(files || []).forEach(file => {
                    const mime = file.type || '';
                    clipboardItems.push({
                        id: `${file.name}-${Date.now()}-${Math.random().toString(16).slice(2)}`,
                        name: file.name,
                        size: file.size,
                        type: mime,
                        displayType: mime || 'Файл',
                        file,
                        previewUrl: null,
                        previewKind: null,
                        previewIcon: null,
                        snippet: '',
                        previewPrepared: false
                    });
                    captured = true;
                });
                if(captured){
                    updateClipboardUI();
                }
                return captured;
            }

            const isFileDrag = (event) => {
                const dt = event.dataTransfer;
                if(!dt) return false;
                const types = dt.types ? Array.from(dt.types) : [];
                if(types.includes('Files')) return true;
                if(types.length === 0) return true;
                return dt.files && dt.files.length > 0;
            };

            clipboard.addEventListener('dragenter', (event) => {
                if(!isFileDrag(event)) return;
                event.preventDefault();
                dragDepth += 1;
                clipboard.classList.add('drag-ready');
                if(event.dataTransfer){
                    event.dataTransfer.dropEffect = 'copy';
                }
            });

            clipboard.addEventListener('dragover', (event) => {
                if(!isFileDrag(event)) return;
                event.preventDefault();
                if(event.dataTransfer){
                    event.dataTransfer.dropEffect = 'copy';
                }
            });

            clipboard.addEventListener('dragleave', (event) => {
                if(!isFileDrag(event)) return;
                event.preventDefault();
                dragDepth = Math.max(dragDepth - 1, 0);
                if(dragDepth === 0){
                    clipboard.classList.remove('drag-ready');
                }
            });

            clipboard.addEventListener('drop', (event) => {
                if(!isFileDrag(event)) return;
                event.preventDefault();
                dragDepth = 0;
                clipboard.classList.remove('drag-ready');
                const files = event.dataTransfer ? event.dataTransfer.files : null;
                if(captureClipboardFiles(files)){
                    if(!reducedMotion){
                        clipboard.classList.remove('captured');
                        void clipboard.offsetWidth;
                        clipboard.classList.add('captured');
                        setTimeout(() => clipboard.classList.remove('captured'), 600);
                    }
                    setTimeout(() => setClipboardOpen(false), 180);
                }
            });

            capsule.addEventListener('dblclick', () => {
                setClipboardOpen(!clipboardOpen);
            });

            let hoverIntentTimer = null;

            function scheduleAutoClose(){
                if(hoverIntentTimer){
                    clearTimeout(hoverIntentTimer);
                }
                hoverIntentTimer = setTimeout(() => {
                    if(!clipboard.matches(':hover') && clipboardOpen){
                        setClipboardOpen(false);
                    }
                }, 260);
            }

            clipboard.addEventListener('mouseleave', () => {
                if(!clipboardOpen) return;
                scheduleAutoClose();
            });

            clipboard.addEventListener('mouseenter', () => {
                if(hoverIntentTimer){
                    clearTimeout(hoverIntentTimer);
                    hoverIntentTimer = null;
                }
            });

            capsule.addEventListener('keydown', (event) => {
                if(event.key === 'Enter' || event.key === ' '){
                    event.preventDefault();
                    setClipboardOpen(!clipboardOpen);
                } else if(event.key === 'Escape' && clipboardOpen){
                    setClipboardOpen(false);
                }
            });

            document.addEventListener('click', (event) => {
                if(clipboardOpen && !clipboard.contains(event.target)){
                    setClipboardOpen(false);
                }
            });

            document.addEventListener('keydown', (event) => {
                if(event.key === 'Escape' && clipboardOpen){
                    setClipboardOpen(false);
                }
            });

            window.addEventListener('beforeunload', clearClipboardPreviews);
            window.addEventListener('blur', () => {
                if(clipboardOpen){
                    setClipboardOpen(false);
                }
            });

            updateClipboardUI();
            setClipboardOpen(false);
        })();
    </script>

    <script>
        // Custom blocks functionality
        (function(){
            let editMode = false;
            let draggedElement = null;
            let dragOffset = { x: 0, y: 0 };
            let isResizing = false;
            let resizeObserver = null;
            let originalDimensions = new Map(); // Store original dimensions
            let originalPositions = new Map(); // Store original positions
            
            // Dynamic grid size calculation
            function getGridSize() {
                const viewportWidth = window.innerWidth;
                // Grid size scales between 15px (mobile) and 25px (desktop)
                return Math.max(15, Math.min(25, Math.round(viewportWidth * 0.02)));
            }
            
            let gridSize = getGridSize(); // Initialize grid size

            const editBtn = document.getElementById('editBlocksBtn');
            const customBlocks = document.getElementById('customBlocks');
            const addBlockBtn = document.getElementById('addBlockBtn');
            const blockBuilderModal = document.getElementById('blockBuilder');
            const builderForm = document.getElementById('blockBuilderForm');
            const builderTypeButtons = blockBuilderModal ? blockBuilderModal.querySelectorAll('.builder-type-btn') : [];
            const builderSections = blockBuilderModal ? blockBuilderModal.querySelectorAll('.builder-section') : [];
            const builderCancelBtn = document.getElementById('builderCancelBtn');
            const builderCloseBtn = document.getElementById('builderCloseBtn');
            const builderChecklistItems = document.getElementById('builderChecklistItems');
            const builderAddChecklistItemBtn = document.getElementById('builderAddChecklistItem');
            const builderColorInput = document.getElementById('blockColor');
            const builderColorValue = document.getElementById('builderColorValue');
            let activeBuilderType = 'music';
            let blocks = document.querySelectorAll('.custom-block');
            const CUSTOM_BLOCKS_STORAGE_KEY = 'customBlocksData';
            const REMOVED_DEFAULT_BLOCKS_KEY = 'removedDefaultBlocks';
            const DEFAULT_BLOCK_COLOR = '#4d7cff';

            function isDefaultBlock(block) {
                return block && block.getAttribute('data-default-block') === 'true';
            }

            function getRemovedDefaultBlocks() {
                try {
                    const raw = localStorage.getItem(REMOVED_DEFAULT_BLOCKS_KEY);
                    return raw ? JSON.parse(raw) : [];
                } catch (err) {
                    return [];
                }
            }

            function markDefaultBlockRemoved(blockId) {
                const removed = new Set(getRemovedDefaultBlocks());
                removed.add(blockId);
                localStorage.setItem(REMOVED_DEFAULT_BLOCKS_KEY, JSON.stringify(Array.from(removed)));
            }

            function applyRemovedDefaultBlocks() {
                const removed = new Set(getRemovedDefaultBlocks());
                if (!removed.size) return;
                removed.forEach(blockId => {
                    const block = customBlocks.querySelector(`.custom-block[data-block-id="${blockId}"][data-default-block="true"]`);
                    if (block) {
                        block.remove();
                    }
                });
            }

            function updateBuilderColorValue(color) {
                if (builderColorValue) {
                    builderColorValue.textContent = (color || DEFAULT_BLOCK_COLOR).toUpperCase();
                }
            }

            function normalizeColorValue(color) {
                if (!color || typeof color !== 'string') return DEFAULT_BLOCK_COLOR;
                if (color.startsWith('#')) {
                    return color.length === 4 || color.length === 7 ? color : DEFAULT_BLOCK_COLOR;
                }
                const hexMatch = color.match(/#?[0-9a-fA-F]{6}/);
                return hexMatch ? (hexMatch[0].startsWith('#') ? hexMatch[0] : `#${hexMatch[0]}`) : DEFAULT_BLOCK_COLOR;
            }

            function hexToRgb(hex) {
                if (!hex) return null;
                let normalized = hex.replace('#', '');
                if (normalized.length === 3) {
                    normalized = normalized.split('').map(ch => ch + ch).join('');
                }
                if (normalized.length !== 6) return null;
                const r = parseInt(normalized.slice(0, 2), 16);
                const g = parseInt(normalized.slice(2, 4), 16);
                const b = parseInt(normalized.slice(4, 6), 16);
                if ([r, g, b].some(v => Number.isNaN(v))) return null;
                return { r, g, b };
            }

            function rgbaString(rgb, alpha) {
                if (!rgb) return `rgba(11, 99, 199, ${alpha})`;
                return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
            }

            function applyBlockColor(block, color) {
                if (!block) return;
                const normalized = normalizeColorValue(color);
                const rgb = hexToRgb(normalized) || { r: 77, g: 124, b: 255 };
                const primary = rgbaString(rgb, 0.42);
                const secondary = rgbaString(rgb, 0.18);
                const border = rgbaString(rgb, 0.46);
                const shadow = `0 18px 40px ${rgbaString(rgb, 0.24)}`;
                block.style.setProperty('--block-bg', `linear-gradient(180deg, ${primary}, ${secondary})`);
                block.style.setProperty('--block-border', border);
                block.style.setProperty('--block-shadow', shadow);
                block.dataset.blockColor = normalized;
            }

            function getCustomBlocksData() {
                try {
                    const raw = localStorage.getItem(CUSTOM_BLOCKS_STORAGE_KEY);
                    return raw ? JSON.parse(raw) : {};
                } catch (err) {
                    return {};
                }
            }

            function persistCustomBlockData(blockId, type, config) {
                const data = getCustomBlocksData();
                data[blockId] = { type, config: { ...(config || {}) } };
                localStorage.setItem(CUSTOM_BLOCKS_STORAGE_KEY, JSON.stringify(data));
            }

            function removeCustomBlockData(blockId) {
                const data = getCustomBlocksData();
                if (data[blockId]) {
                    delete data[blockId];
                    localStorage.setItem(CUSTOM_BLOCKS_STORAGE_KEY, JSON.stringify(data));
                }
            }

            function addBuilderChecklistItem(value = '') {
                if (!builderChecklistItems) return;
                const row = document.createElement('div');
                row.className = 'builder-checklist-item';

                const input = document.createElement('input');
                input.type = 'text';
                input.name = 'checklistItem';
                input.placeholder = 'Например: Подготви презентация';
                input.value = value;

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'builder-remove-item';
                removeBtn.setAttribute('aria-label', 'Премахни елемент');
                removeBtn.textContent = '×';

                row.append(input, removeBtn);
                builderChecklistItems.appendChild(row);
            }

            function restoreSavedCustomBlocks() {
                const savedData = getCustomBlocksData();
                const entries = Object.entries(savedData);
                if (!entries.length) {
                    return;
                }
                let savedPositions = {};
                let savedDimensions = {};
                try {
                    savedPositions = JSON.parse(localStorage.getItem('blockPositions') || '{}');
                } catch (err) {
                    savedPositions = {};
                }
                try {
                    savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}');
                } catch (err) {
                    savedDimensions = {};
                }

                entries.forEach(([blockId, payload]) => {
                    if (!payload || !payload.type) return;
                    if (customBlocks.querySelector(`.custom-block[data-block-id="${blockId}"]`)) return;

                    const position = savedPositions[blockId] || null;
                    const dimensions = savedDimensions[blockId] || null;
                    createNewBlock(payload.type, payload.config || {}, {
                        blockId,
                        position,
                        dimensions,
                        restoring: true
                    });
                });
                blocks = document.querySelectorAll('.custom-block');
            }

            function setActiveBuilderType(type) {
                if (!type) return;
                activeBuilderType = type;
                builderTypeButtons.forEach(btn => {
                    const btnType = btn.getAttribute('data-builder-type');
                    btn.classList.toggle('active', btnType === type);
                });
                builderSections.forEach(section => {
                    const sectionType = section.getAttribute('data-builder-section');
                    const isActive = sectionType === type;
                    section.hidden = !isActive;
                    section.classList.toggle('active', isActive);
                    section.querySelectorAll('input, select, textarea').forEach(field => {
                        field.disabled = !isActive;
                    });
                });
            }

            function resetBuilderFormFields(defaultType = 'music') {
                if (!builderForm) return;
                builderForm.reset();
                if (builderColorInput) {
                    updateBuilderColorValue(builderColorInput.value || DEFAULT_BLOCK_COLOR);
                }
                if (builderChecklistItems) {
                    builderChecklistItems.innerHTML = '';
                    addBuilderChecklistItem('Примерна задача');
                    addBuilderChecklistItem('');
                }
                setActiveBuilderType(defaultType);
            }

            function openBlockBuilder(defaultType = 'music') {
                if (!blockBuilderModal) return;
                resetBuilderFormFields(defaultType);
                blockBuilderModal.classList.add('show');
                requestAnimationFrame(() => {
                    const focusTarget = blockBuilderModal.querySelector(`[data-builder-section="${activeBuilderType}"] input, [data-builder-section="${activeBuilderType}"] select`);
                    if (focusTarget) {
                        focusTarget.focus({ preventScroll: true });
                    }
                });
            }

            function closeBlockBuilder() {
                if (!blockBuilderModal) return;
                blockBuilderModal.classList.remove('show');
            }

            function collectBuilderConfig(type) {
                if (!builderForm) return {};
                const color = builderColorInput ? normalizeColorValue(builderColorInput.value || DEFAULT_BLOCK_COLOR) : DEFAULT_BLOCK_COLOR;
                switch (type) {
                    case 'music': {
                        const title = builderForm.musicTitle.value.trim() || 'Музика';
                        const platform = builderForm.musicPlatform.value;
                        const url = builderForm.musicUrl.value.trim();
                        const note = builderForm.musicNote.value.trim();
                        return { title, platform, url, note, color };
                    }
                    case 'weather': {
                        const title = builderForm.weatherTitle.value.trim() || 'Време';
                        const location = builderForm.weatherLocation.value.trim();
                        const units = builderForm.weatherUnits.value;
                        return { title, location, units, color };
                    }
                    case 'checklist': {
                        const title = builderForm.checklistTitle.value.trim() || 'Чеклист';
                        const items = builderChecklistItems ? Array.from(builderChecklistItems.querySelectorAll('input[name="checklistItem"]')).map(input => input.value.trim()).filter(Boolean) : [];
                        if (!items.length) {
                            items.push('Нова задача');
                        }
                        return { title, items, color };
                    }
                    default:
                        return { color };
                }
            }

            if (addBlockBtn) {
                addBlockBtn.addEventListener('click', () => {
                    if (!editMode) return;
                    openBlockBuilder(activeBuilderType);
                });
            }

            builderTypeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const type = btn.getAttribute('data-builder-type');
                    setActiveBuilderType(type);
                });
            });

            if (builderColorInput) {
                builderColorInput.addEventListener('input', () => {
                    updateBuilderColorValue(builderColorInput.value || DEFAULT_BLOCK_COLOR);
                });
                updateBuilderColorValue(builderColorInput.value || DEFAULT_BLOCK_COLOR);
            }

            if (builderAddChecklistItemBtn) {
                builderAddChecklistItemBtn.addEventListener('click', () => {
                    addBuilderChecklistItem('');
                    if (builderChecklistItems) {
                        const lastInput = builderChecklistItems.querySelector('.builder-checklist-item:last-child input');
                        if (lastInput) {
                            lastInput.focus();
                        }
                    }
                });
            }

            if (builderChecklistItems) {
                builderChecklistItems.addEventListener('click', (e) => {
                    const removeBtn = e.target.closest('.builder-remove-item');
                    if (!removeBtn) return;
                    e.preventDefault();
                    const row = removeBtn.closest('.builder-checklist-item');
                    if (!row) return;
                    if (builderChecklistItems.children.length > 1) {
                        row.remove();
                    } else {
                        const input = row.querySelector('input');
                        if (input) input.value = '';
                    }
                });
            }

            if (builderCancelBtn) {
                builderCancelBtn.addEventListener('click', closeBlockBuilder);
            }

            if (builderCloseBtn) {
                builderCloseBtn.addEventListener('click', closeBlockBuilder);
            }

            if (blockBuilderModal) {
                blockBuilderModal.addEventListener('click', (e) => {
                    if (e.target === blockBuilderModal) {
                        closeBlockBuilder();
                    }
                });
            }

            if (builderForm) {
                builderForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    if (!builderForm.reportValidity()) return;
                    const config = collectBuilderConfig(activeBuilderType);
                    createNewBlock(activeBuilderType, config);
                    closeBlockBuilder();
                });
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && blockBuilderModal && blockBuilderModal.classList.contains('show')) {
                    closeBlockBuilder();
                }
            });

            if (blockBuilderModal) {
                setActiveBuilderType(activeBuilderType);
            }

            restoreSavedCustomBlocks();

            // Create ResizeObserver for monitoring resize operations
            if (window.ResizeObserver) {
                resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        const block = entry.target;
                        if (block.classList.contains('edit-mode')) {
                            handleBlockResize(block, entry);
                        }
                    }
                });
            }

            function handleBlockResize(block, entry) {
                if (!isResizing) {
                    isResizing = true;
                    customBlocks.classList.add('resizing-active');
                    block.classList.add('resizing');
                    
                    // Clear any existing timeout
                    if (block.resizeTimeout) {
                        clearTimeout(block.resizeTimeout);
                    }
                    
                    // Ultra-smooth resize completion with longer debounce
                    block.resizeTimeout = setTimeout(() => {
                        isResizing = false;
                        customBlocks.classList.remove('resizing-active');
                        block.classList.remove('resizing');
                        
                        // Check for collisions and adjust if needed
                        const blockLeft = parseFloat(block.style.left) || block.offsetLeft || 0;
                        const blockTop = parseFloat(block.style.top) || block.offsetTop || 0;
                        const currentWidth = block.offsetWidth;
                        const currentHeight = block.offsetHeight;
                        
                        if (checkCollisionWithSize(block, blockLeft, blockTop, currentWidth, currentHeight)) {
                            adjustBlockSizeAfterResize(block);
                        } else {
                            // Smooth collision indicator removal
                            block.style.transition = 'all 0.3s ease';
                            block.classList.remove('collision');
                            setTimeout(() => {
                                block.style.transition = '';
                            }, 300);
                        }
                        
                        // Save resize dimensions
                        saveBlockDimensions(block);
                    }, 600); // Longer timeout for ultra-smooth experience
                }

                // Enhanced adaptive minimum dimensions with better responsive scaling
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const minWidth = Math.max(220, Math.min(300, viewportWidth * 0.28));
                const minHeight = Math.max(140, Math.min(200, viewportHeight * 0.18));
                
                const currentWidth = block.offsetWidth;
                const currentHeight = block.offsetHeight;
                
                // Smooth enforcement of minimum dimensions
                if (currentWidth < minWidth - 15 || currentHeight < minHeight - 15) {
                    requestAnimationFrame(() => {
                        block.style.transition = 'width 0.2s ease, height 0.2s ease';
                        if (currentWidth < minWidth - 15) {
                            block.style.width = minWidth + 'px';
                        }
                        if (currentHeight < minHeight - 15) {
                            block.style.height = minHeight + 'px';
                        }
                        setTimeout(() => {
                            block.style.transition = '';
                        }, 200);
                    });
                }
            }

            function saveBlockDimensions(block) {
                const blockId = block.getAttribute('data-block-id');
                const rect = block.getBoundingClientRect();
                const dimensions = {
                    width: block.offsetWidth + 'px',
                    height: block.offsetHeight + 'px'
                };
                
                // Save to localStorage
                const savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}');
                savedDimensions[blockId] = dimensions;
                localStorage.setItem('blockDimensions', JSON.stringify(savedDimensions));
                
                // Update container height if block is near the bottom
                const blockTop = parseInt(block.style.top) || 0;
                const blockBottom = blockTop + block.offsetHeight;
                const currentMinHeight = parseFloat(getComputedStyle(customBlocks).minHeight) || 600;
                if (blockBottom > currentMinHeight - 50) {
                    customBlocks.style.minHeight = (blockBottom + 100) + 'px';
                }
            }

            function storeOriginalDimensions() {
                // Store current dimensions before entering edit mode
                blocks.forEach(block => {
                    const blockId = block.getAttribute('data-block-id');
                    const rect = block.getBoundingClientRect();
                    const containerRect = customBlocks.getBoundingClientRect();
                    
                    originalDimensions.set(blockId, {
                        width: block.offsetWidth,
                        height: block.offsetHeight,
                        computedWidth: getComputedStyle(block).width,
                        computedHeight: getComputedStyle(block).height
                    });
                    
                    // Store relative position within the container
                    originalPositions.set(blockId, {
                        left: rect.left - containerRect.left,
                        top: rect.top - containerRect.top
                    });
                });
            }

            function restoreOriginalLayout() {
                // Don't restore to grid layout - maintain absolute positioning with saved positions
                blocks.forEach(block => {
                    const blockId = block.getAttribute('data-block-id');
                    
                    // Keep absolute positioning but remove edit-specific styling
                    block.style.position = 'absolute';
                    // Don't clear left and top - keep the positions!
                    block.style.zIndex = '1';
                    
                    // Restore saved dimensions if they exist
                    const savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}');
                    if (savedDimensions[blockId]) {
                        block.style.width = savedDimensions[blockId].width;
                        block.style.height = savedDimensions[blockId].height;
                    }
                });
            }

            function snapToGrid(value) {
                return Math.round(value * 100) / 100;
            }

            // Collision detection and prevention functions
            function getBlockBounds(block) {
                const left = parseFloat(block.style.left) || block.offsetLeft || 0;
                const top = parseFloat(block.style.top) || block.offsetTop || 0;
                const width = block.offsetWidth || parseFloat(block.style.width) || 280;
                const height = block.offsetHeight || parseFloat(block.style.height) || 180;
                
                return {
                    left: left,
                    top: top,
                    right: left + width,
                    bottom: top + height,
                    width: width,
                    height: height
                };
            }

            function blocksOverlap(bounds1, bounds2) {
                // Add small margin to prevent blocks from touching
                const margin = 10;
                return !(bounds1.right + margin <= bounds2.left || 
                        bounds2.right + margin <= bounds1.left || 
                        bounds1.bottom + margin <= bounds2.top || 
                        bounds2.bottom + margin <= bounds1.top);
            }

            function checkCollision(targetBlock, newLeft, newTop) {
                const targetBounds = {
                    left: newLeft,
                    top: newTop,
                    right: newLeft + (targetBlock.offsetWidth || 280),
                    bottom: newTop + (targetBlock.offsetHeight || 180),
                    width: targetBlock.offsetWidth || 280,
                    height: targetBlock.offsetHeight || 180
                };

                // Check against all other blocks
                for (let block of blocks) {
                    if (block === targetBlock) continue;
                    
                    const blockBounds = getBlockBounds(block);
                    if (blocksOverlap(targetBounds, blockBounds)) {
                        return true; // Collision detected
                    }
                }
                return false; // No collision
            }

            function checkCollisionWithSize(targetBlock, left, top, width, height) {
                const targetBounds = {
                    left: left,
                    top: top,
                    right: left + width,
                    bottom: top + height,
                    width: width,
                    height: height
                };

                // Check against all other blocks
                for (let block of blocks) {
                    if (block === targetBlock) continue;
                    
                    const blockBounds = getBlockBounds(block);
                    if (blocksOverlap(targetBounds, blockBounds)) {
                        return true; // Collision detected
                    }
                }
                return false; // No collision
            }

            function adjustBlockAfterResize(block) {
                const currentLeft = parseFloat(block.style.left) || block.offsetLeft || 0;
                const currentTop = parseFloat(block.style.top) || block.offsetTop || 0;
                const currentWidth = block.offsetWidth;
                const currentHeight = block.offsetHeight;
                
                // Try to find a position where the new size doesn't cause overlap
                const containerWidth = customBlocks.offsetWidth;
                const containerHeight = parseInt(getComputedStyle(customBlocks).minHeight, 10) || 600;
                
                // First try moving the block slightly in different directions
                const adjustments = [
                    { dx: 0, dy: 0 }, // Current position
                    { dx: gridSize, dy: 0 }, // Right
                    { dx: -gridSize, dy: 0 }, // Left
                    { dx: 0, dy: gridSize }, // Down
                    { dx: 0, dy: -gridSize }, // Up
                    { dx: gridSize, dy: gridSize }, // Down-right
                    { dx: -gridSize, dy: -gridSize }, // Up-left
                    { dx: gridSize, dy: -gridSize }, // Up-right
                    { dx: -gridSize, dy: gridSize }, // Down-left
                ];
                
                for (let adj of adjustments) {
                    const newLeft = currentLeft + adj.dx;
                    const newTop = currentTop + adj.dy;
                    
                    // Check bounds
                    if (newLeft >= 0 && newTop >= 0 && 
                        newLeft + currentWidth <= containerWidth &&
                        newTop + currentHeight <= containerHeight + 200) {
                        
                        if (!checkCollisionWithSize(block, newLeft, newTop, currentWidth, currentHeight)) {
                            // Found a good position
                            block.style.transition = 'all 0.3s cubic-bezier(0.2, 0.9, 0.3, 1)';
                            block.style.left = snapToGrid(newLeft) + 'px';
                            block.style.top = snapToGrid(newTop) + 'px';
                            
                            setTimeout(() => {
                                block.style.transition = '';
                                block.classList.remove('collision');
                                saveBlockPosition(block);
                            }, 300);
                            return;
                        }
                    }
                }
                
                // If no nearby position works, try to reduce the size slightly
                const maxAttempts = 5;
                for (let i = 1; i <= maxAttempts; i++) {
                    const reducedWidth = currentWidth - (i * 20);
                    const reducedHeight = currentHeight - (i * 15);
                    
                    // Don't make it too small
                    const minWidth = Math.max(250, Math.min(280, window.innerWidth * 0.35));
                    const minHeight = Math.max(160, Math.min(180, window.innerHeight * 0.2));
                    
                    if (reducedWidth >= minWidth && reducedHeight >= minHeight) {
                        if (!checkCollisionWithSize(block, currentLeft, currentTop, reducedWidth, reducedHeight)) {
                            // Reduce size to prevent overlap
                            block.style.transition = 'all 0.3s cubic-bezier(0.2, 0.9, 0.3, 1)';
                            block.style.width = reducedWidth + 'px';
                            block.style.height = reducedHeight + 'px';
                            
                            setTimeout(() => {
                                block.style.transition = '';
                                block.classList.remove('collision');
                                saveBlockDimensions(block);
                            }, 300);
                            return;
                        }
                    }
                }
                
                // If nothing works, just remove the collision visual feedback
                setTimeout(() => {
                    block.classList.remove('collision');
                }, 1000);
            }

            function calculateResizeConstraints(targetBlock, blockLeft, blockTop) {
                const containerWidth = customBlocks.offsetWidth;
                const containerHeight = parseFloat(getComputedStyle(customBlocks).minHeight) || 600;
                
                // Calculate maximum possible dimensions based on container bounds
                let maxWidth = containerWidth - blockLeft;
                let maxHeight = containerHeight - blockTop + 200; // Allow some extension
                
                // Check collision constraints with other blocks
                for (let block of blocks) {
                    if (block === targetBlock) continue;
                    
                    const otherBounds = getBlockBounds(block);
                    
                    // If other block is to the right, limit width
                    if (otherBounds.left > blockLeft && otherBounds.top < blockTop + 200 && otherBounds.bottom > blockTop) {
                        const availableWidth = Math.max(0, otherBounds.left - blockLeft - 10); // 10px margin
                        maxWidth = Math.min(maxWidth, availableWidth);
                    }
                    
                    // If other block is below, limit height
                    if (otherBounds.top > blockTop && otherBounds.left < blockLeft + 200 && otherBounds.right > blockLeft) {
                        const availableHeight = Math.max(0, otherBounds.top - blockTop - 10); // 10px margin
                        maxHeight = Math.min(maxHeight, availableHeight);
                    }
                }
                
                // Ensure minimum dimensions
                const minWidth = Math.max(250, Math.min(280, window.innerWidth * 0.35));
                const minHeight = Math.max(160, Math.min(180, window.innerHeight * 0.2));
                
                return {
                    maxWidth: Math.max(minWidth, maxWidth),
                    maxHeight: Math.max(minHeight, maxHeight),
                    minWidth: minWidth,
                    minHeight: minHeight
                };
            }

            function findMaxValidSize(targetBlock, blockLeft, blockTop, constraints) {
                const currentWidth = targetBlock.offsetWidth;
                const currentHeight = targetBlock.offsetHeight;
                
                // Start from current size and work backwards to find valid size
                let testWidth = currentWidth;
                let testHeight = currentHeight;
                
                // First, ensure we're within container bounds
                testWidth = Math.min(testWidth, constraints.maxWidth);
                testHeight = Math.min(testHeight, constraints.maxHeight);
                
                // Binary search approach for width
                let validWidth = constraints.minWidth;
                let minW = constraints.minWidth;
                let maxW = testWidth;
                
                while (maxW - minW > 5) {
                    const midW = Math.floor((minW + maxW) / 2);
                    if (!checkCollisionWithSize(targetBlock, blockLeft, blockTop, midW, testHeight)) {
                        validWidth = midW;
                        minW = midW;
                    } else {
                        maxW = midW - 1;
                    }
                }
                
                // Binary search approach for height
                let validHeight = constraints.minHeight;
                let minH = constraints.minHeight;
                let maxH = testHeight;
                
                while (maxH - minH > 5) {
                    const midH = Math.floor((minH + maxH) / 2);
                    if (!checkCollisionWithSize(targetBlock, blockLeft, blockTop, validWidth, midH)) {
                        validHeight = midH;
                        minH = midH;
                    } else {
                        maxH = midH - 1;
                    }
                }
                
                return {
                    width: Math.max(validWidth, constraints.minWidth),
                    height: Math.max(validHeight, constraints.minHeight)
                };
            }

            function adjustBlockSizeAfterResize(block) {
                const currentLeft = parseFloat(block.style.left) || block.offsetLeft || 0;
                const currentTop = parseFloat(block.style.top) || block.offsetTop || 0;
                const currentWidth = block.offsetWidth;
                const currentHeight = block.offsetHeight;
                
                // Calculate constraints based on current position
                const constraints = calculateResizeConstraints(block, currentLeft, currentTop);
                
                // Find the maximum valid size that doesn't cause overlap
                const validSize = findMaxValidSize(block, currentLeft, currentTop, constraints);
                
                // Only adjust if the current size exceeds valid limits
                let needsAdjustment = false;
                let targetWidth = currentWidth;
                let targetHeight = currentHeight;
                
                if (currentWidth > validSize.width) {
                    targetWidth = validSize.width;
                    needsAdjustment = true;
                }
                
                if (currentHeight > validSize.height) {
                    targetHeight = validSize.height;
                    needsAdjustment = true;
                }
                
                if (needsAdjustment) {
                    // Ultra-smooth animation with enhanced easing
                    block.style.transition = 'all 0.6s cubic-bezier(0.15, 0.85, 0.3, 1)';
                    block.style.width = targetWidth + 'px';
                    block.style.height = targetHeight + 'px';
                    
                    // Enhanced cleanup with smooth collision removal
                    setTimeout(() => {
                        if (block) {
                            block.style.transition = '';
                            // Gentle collision indicator fade-out
                            if (block.classList.contains('collision')) {
                                block.style.opacity = '0.95';
                                setTimeout(() => {
                                    block.classList.remove('collision');
                                    block.style.opacity = '';
                                }, 100);
                            }
                            saveBlockDimensions(block);
                        }
                    }, 600);
                } else {
                    // Smooth collision indicator removal without size change
                    if (block.classList.contains('collision')) {
                        block.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                        block.style.opacity = '0.98';
                        setTimeout(() => {
                            block.classList.remove('collision');
                            block.style.transition = '';
                            block.style.opacity = '';
                        }, 300);
                    }
                }
            }

            function findFreePosition(targetBlock, preferredLeft, preferredTop) {
                const containerWidth = customBlocks.offsetWidth;
                const containerHeight = parseInt(getComputedStyle(customBlocks).minHeight) || 600;
                const blockWidth = targetBlock.offsetWidth || 280;
                const blockHeight = targetBlock.offsetHeight || 180;
                
                // Start from preferred position and spiral outward to find free space
                const maxSteps = 50; // Limit search to prevent infinite loops
                let stepSize = gridSize;
                
                // Try the preferred position first
                if (!checkCollision(targetBlock, preferredLeft, preferredTop)) {
                    return { left: preferredLeft, top: preferredTop };
                }
                
                // Spiral search pattern
                for (let step = 1; step <= maxSteps; step++) {
                    const positions = [
                        // Try positions around the preferred location
                        { left: preferredLeft + step * stepSize, top: preferredTop },
                        { left: preferredLeft - step * stepSize, top: preferredTop },
                        { left: preferredLeft, top: preferredTop + step * stepSize },
                        { left: preferredLeft, top: preferredTop - step * stepSize },
                        { left: preferredLeft + step * stepSize, top: preferredTop + step * stepSize },
                        { left: preferredLeft - step * stepSize, top: preferredTop - step * stepSize },
                        { left: preferredLeft + step * stepSize, top: preferredTop - step * stepSize },
                        { left: preferredLeft - step * stepSize, top: preferredTop + step * stepSize }
                    ];
                    
                    for (let pos of positions) {
                        // Check if position is within bounds
                        if (pos.left >= 0 && pos.top >= 0 && 
                            pos.left + blockWidth <= containerWidth &&
                            pos.top + blockHeight <= containerHeight + 200) { // Allow some extension
                            
                            if (!checkCollision(targetBlock, pos.left, pos.top)) {
                                return { left: snapToGrid(pos.left), top: snapToGrid(pos.top) };
                            }
                        }
                    }
                }
                
                // If no free position found, try to place at the bottom
                let bottomY = 0;
                blocks.forEach(block => {
                    if (block !== targetBlock) {
                        const bounds = getBlockBounds(block);
                        bottomY = Math.max(bottomY, bounds.bottom + 20);
                    }
                });
                
                return { 
                    left: snapToGrid(Math.min(preferredLeft, containerWidth - blockWidth)), 
                    top: snapToGrid(bottomY) 
                };
            }

            // Update grid size on window resize
            function updateGridSize() {
                const newGridSize = getGridSize();
                if (newGridSize !== gridSize) {
                    gridSize = newGridSize;
                    
                    // Update CSS custom property for grid size if in edit mode
                    if (editMode) {
                        document.documentElement.style.setProperty('--dynamic-grid-size', gridSize + 'px');
                    }
                }
            }

            // Adaptive block resizing function
            function adaptBlockSizes() {
                blocks.forEach(block => {
                    const blockId = block.getAttribute('data-block-id');
                    const savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}');
                    
                    // Only adapt if no custom dimensions are saved
                    if (!savedDimensions[blockId]) {
                        const containerWidth = customBlocks.offsetWidth;
                        const adaptiveWidth = Math.max(250, Math.min(320, containerWidth * 0.4));
                        const adaptiveHeight = Math.max(160, Math.min(220, window.innerHeight * 0.25));
                        
                        block.style.width = adaptiveWidth + 'px';
                        block.style.height = adaptiveHeight + 'px';
                    }
                });
                
                updateContainerHeight();
            }

            // Enhanced window resize handler
            function handleWindowResize() {
                updateGridSize();
                adaptBlockSizes();
                
                // Reposition blocks if they're out of bounds
                blocks.forEach(block => {
                    const left = parseFloat(block.style.left) || block.offsetLeft || 0;
                    const top = parseFloat(block.style.top) || block.offsetTop || 0;
                    const limited = enforceScreenLimits(block, left, top);
                    
                    if (limited.left !== left || limited.top !== top) {
                        block.style.left = limited.left + 'px';
                        block.style.top = limited.top + 'px';
                        saveBlockPosition(block);
                    }
                });
            }

            // Listen for window resize with debouncing
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(handleWindowResize, 150);
            });

            function enforceScreenLimits(block, left, top) {
                const containerRect = customBlocks.getBoundingClientRect();
                const blockWidth = block.offsetWidth;
                
                // Only enforce horizontal limits - allow free vertical movement
                const maxLeft = containerRect.width - blockWidth;
                
                left = Math.max(0, Math.min(left, maxLeft));
                top = Math.max(0, top); // Only prevent going above container, no bottom limit
                
                // Dynamically expand container height if needed
                const blockBottom = top + block.offsetHeight;
                const currentMinHeight = parseInt(getComputedStyle(customBlocks).minHeight) || 600;
                if (blockBottom > currentMinHeight - 50) {
                    customBlocks.style.minHeight = (blockBottom + 100) + 'px';
                }
                
                return { left, top };
            }

            function loadBlockDimensions() {
                const savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}');
                
                blocks.forEach(block => {
                    const blockId = block.getAttribute('data-block-id');
                    if (savedDimensions[blockId]) {
                        const dims = savedDimensions[blockId];
                        if (dims.width) block.style.width = dims.width;
                        if (dims.height) block.style.height = dims.height;
                    }
                });
            }

            function loadBlockPositions() {
                const savedPositions = JSON.parse(localStorage.getItem('blockPositions') || '{}');
                
                blocks.forEach((block, index) => {
                    const blockId = block.getAttribute('data-block-id');
                    if (savedPositions[blockId]) {
                        // Use saved positions
                        const pos = savedPositions[blockId];
                        const savedLeft = parseFloat(pos.left);
                        const savedTop = parseFloat(pos.top);
                        block.style.left = (Number.isNaN(savedLeft) ? 0 : savedLeft) + 'px';
                        block.style.top = (Number.isNaN(savedTop) ? 0 : savedTop) + 'px';
                    } else {
                        // Initialize with adaptive grid-like positions
                        const containerWidth = customBlocks.offsetWidth;
                        const blockWidth = Math.max(280, Math.min(320, containerWidth * 0.4)); // Adaptive block width
                        const blockHeight = Math.max(180, Math.min(220, window.innerHeight * 0.25)); // Adaptive block height
                        
                        const cols = Math.floor(containerWidth / (blockWidth + gridSize));
                        const row = Math.floor(index / Math.max(1, cols));
                        const col = index % Math.max(1, cols);
                        
                        block.style.left = snapToGrid(col * (blockWidth + gridSize)) + 'px';
                        block.style.top = snapToGrid(row * (blockHeight + gridSize)) + 'px';
                        
                        // Save the initial position
                        saveBlockPosition(block);
                    }
                });
                
                // Update container height to fit all blocks
                updateContainerHeight();
            }

            function updateContainerHeight() {
                let maxBottom = 600; // minimum height
                blocks.forEach(block => {
                    const top = parseInt(block.style.top) || 0;
                    const height = block.offsetHeight || 180;
                    const bottom = top + height;
                    if (bottom > maxBottom) {
                        maxBottom = bottom;
                    }
                });
                customBlocks.style.minHeight = (maxBottom + 50) + 'px';
            }

            // Toggle edit mode
            editBtn.addEventListener('click', () => {
                editMode = !editMode;
                toggleEditMode();
            });

            function toggleEditMode() {
                if (editMode) {
                    // Store original dimensions and positions before entering edit mode
                    storeOriginalDimensions();
                    
                    // Update grid size for current viewport
                    updateGridSize();
                    
                    editBtn.classList.add('active');
                    editBtn.innerHTML = '<span>Готово</span>';
                    customBlocks.classList.add('edit-mode');
                    if (addBlockBtn) {
                        addBlockBtn.classList.add('visible');
                    }
                    
                    // Convert to absolute positioning
                    blocks.forEach((block, index) => {
                        const blockId = block.getAttribute('data-block-id');
                        block.classList.add('edit-mode');
                        enableDragAndDrop(block);
                        enableResizeMonitoring(block);
                        
                        // Positions are already loaded, just ensure they have explicit values
                        if (!block.style.left || !block.style.top) {
                            // Only set if not already positioned
                            const savedPositions = JSON.parse(localStorage.getItem('blockPositions') || '{}');
                            if (savedPositions[blockId]) {
                                block.style.left = savedPositions[blockId].left + 'px';
                                block.style.top = savedPositions[blockId].top + 'px';
                            }
                        }
                        
                        // Apply saved dimensions if not already set
                        const savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}');
                        if (savedDimensions[blockId] && (!block.style.width || !block.style.height)) {
                            block.style.width = savedDimensions[blockId].width;
                            block.style.height = savedDimensions[blockId].height;
                        }
                    });
                } else {
                    editBtn.classList.remove('active');
                    editBtn.innerHTML = '<span>Редактиране</span>';
                    
                    // Add exit animation class
                    customBlocks.classList.add('edit-mode-exit');
                    if (addBlockBtn) {
                        addBlockBtn.classList.remove('visible');
                    }
                    closeBlockBuilder();
                    
                    // Wait for animation and then clean up
                    setTimeout(() => {
                        customBlocks.classList.remove('edit-mode', 'edit-mode-exit', 'resizing-active');
                        
                        // Don't reset container height - keep it based on block positions
                        updateContainerHeight();
                        
                        blocks.forEach(block => {
                            block.classList.remove('edit-mode', 'resizing', 'snapping');
                            disableDragAndDrop(block);
                            disableResizeMonitoring(block);
                        });
                        
                        // Restore layout but keep positions
                        restoreOriginalLayout();
                        
                        // Clean up any resize timeouts
                        blocks.forEach(block => {
                            if (block.resizeTimeout) {
                                clearTimeout(block.resizeTimeout);
                                delete block.resizeTimeout;
                            }
                        });
                    }, 300);
                }
            }

            function enableResizeMonitoring(block) {
                if (resizeObserver) {
                    resizeObserver.observe(block);
                }
                
                // Add mouse events for resize detection
                block.addEventListener('mousedown', handleResizeStart);
            }

            function disableResizeMonitoring(block) {
                if (resizeObserver) {
                    resizeObserver.unobserve(block);
                }
                
                block.removeEventListener('mousedown', handleResizeStart);
            }

            function handleResizeStart(e) {
                const block = e.target.closest('.custom-block');
                if (!block || !block.classList.contains('edit-mode')) return;
                
                const rect = block.getBoundingClientRect();
                const isResizeArea = e.clientX > rect.right - 20 && e.clientY > rect.bottom - 20;
                
                if (isResizeArea) {
                    // Ultra smooth transition into resize mode
                    block.style.transition = 'border-color 0.3s ease, background 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease';
                    customBlocks.classList.add('resizing-active');
                    block.classList.add('resizing');
                    
                    // Store current collision state to prevent flickering
                    let currentCollisionState = block.classList.contains('collision');
                    
                    // Stable collision checking - only update when state actually changes
                    const resizeMonitor = setInterval(() => {
                        const blockLeft = parseFloat(block.style.left) || block.offsetLeft || 0;
                        const blockTop = parseFloat(block.style.top) || block.offsetTop || 0;
                        const hasCollision = checkCollisionWithSize(block, blockLeft, blockTop, block.offsetWidth, block.offsetHeight);
                        
                        // Only update if collision state actually changed
                        if (hasCollision !== currentCollisionState) {
                            currentCollisionState = hasCollision;
                            if (hasCollision) {
                                block.classList.add('collision');
                            } else {
                                block.classList.remove('collision');
                            }
                        }
                    }, 100); // Stable, less frequent checking
                    
                    // Add mouse up listener to clean up resize state
                    const cleanup = () => {
                        clearInterval(resizeMonitor);
                        block.style.transition = '';
                        block.classList.remove('collision'); // Always clear on resize end
                        document.removeEventListener('mouseup', cleanup);
                    };
                    document.addEventListener('mouseup', cleanup);
                }
            }

            function enableDragAndDrop(block) {
                // Use mouse events for better control in absolute positioning
                block.addEventListener('mousedown', handleMouseDown);
            }

            function disableDragAndDrop(block) {
                block.removeEventListener('mousedown', handleMouseDown);
            }

            function handleMouseDown(e) {
                const block = e.target.closest('.custom-block');
                if (!block || !block.classList.contains('edit-mode')) return;
                
                const rect = block.getBoundingClientRect();
                const containerRect = customBlocks.getBoundingClientRect();
                
                // Check if clicking on resize handle
                const isResizeArea = e.clientX > rect.right - 20 && e.clientY > rect.bottom - 20;
                if (isResizeArea) return;
                
                e.preventDefault();
                
                draggedElement = block;
                block.classList.add('dragging');
                
                // Calculate offset from mouse to block position
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            }

            function handleMouseMove(e) {
                if (!draggedElement) return;
                
                e.preventDefault();
                
                const containerRect = customBlocks.getBoundingClientRect();
                
                // Calculate new position relative to container
                let newLeft = e.clientX - containerRect.left - dragOffset.x;
                let newTop = e.clientY - containerRect.top - dragOffset.y;
                
                // Snap to grid
                newLeft = snapToGrid(newLeft);
                newTop = snapToGrid(newTop);
                
                // Enforce screen limits
                const limited = enforceScreenLimits(draggedElement, newLeft, newTop);
                newLeft = limited.left;
                newTop = limited.top;
                
                // Always apply position during drag (allow passing over other blocks)
                draggedElement.style.left = newLeft + 'px';
                draggedElement.style.top = newTop + 'px';
                
                // Ultra-smooth collision checking - only check once and maintain state
                if (!draggedElement.lastCollisionCheck || Date.now() - draggedElement.lastCollisionCheck > 50) {
                    const hasCollision = checkCollision(draggedElement, newLeft, newTop);
                    
                    // Only update class if state actually changed
                    if (hasCollision && !draggedElement.classList.contains('collision')) {
                        draggedElement.classList.add('collision');
                    } else if (!hasCollision && draggedElement.classList.contains('collision')) {
                        draggedElement.classList.remove('collision');
                    }
                    
                    draggedElement.lastCollisionCheck = Date.now();
                }
                
                // Add snapping visual feedback
                if (!draggedElement.classList.contains('snapping')) {
                    draggedElement.classList.add('snapping');
                }
            }

            function handleMouseUp(e) {
                if (!draggedElement) return;
                
                // Clear any pending collision checks and states
                if (draggedElement.collisionCheckTimeout) {
                    clearTimeout(draggedElement.collisionCheckTimeout);
                    draggedElement.collisionCheckTimeout = null;
                }
                draggedElement.lastCollisionCheck = null;
                
                const currentLeft = parseInt(draggedElement.style.left) || 0;
                const currentTop = parseInt(draggedElement.style.top) || 0;
                
                // Check if the current position would cause a collision
                if (checkCollision(draggedElement, currentLeft, currentTop)) {
                    // Find the nearest free position
                    const freePosition = findFreePosition(draggedElement, currentLeft, currentTop);
                    
                    // Animate to the free position
                    draggedElement.style.transition = 'all 0.5s cubic-bezier(0.15, 0.85, 0.3, 1)';
                    draggedElement.style.left = freePosition.left + 'px';
                    draggedElement.style.top = freePosition.top + 'px';
                    
                    // Remove transition after animation
                    setTimeout(() => {
                        if (draggedElement) {
                            draggedElement.style.transition = '';
                        }
                    }, 500);
                }
                
                // Remove all drag-related classes smoothly
                draggedElement.classList.remove('dragging', 'snapping', 'collision');
                
                // Save the final position
                setTimeout(() => {
                    if (draggedElement) {
                        saveBlockPosition(draggedElement);
                    }
                }, 500); // Wait for potential animation to complete
                
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                
                draggedElement = null;
            }

            function saveBlockPosition(block) {
                const blockId = block.getAttribute('data-block-id');
                const left = Number.isFinite(block.offsetLeft) ? block.offsetLeft : parseFloat(block.style.left) || 0;
                const top = Number.isFinite(block.offsetTop) ? block.offsetTop : parseFloat(block.style.top) || 0;
                const position = {
                    left: Math.round(left * 100) / 100,
                    top: Math.round(top * 100) / 100
                };
                
                let savedPositions = {};
                try {
                    savedPositions = JSON.parse(localStorage.getItem('blockPositions') || '{}') || {};
                } catch (err) {
                    savedPositions = {};
                }
                savedPositions[blockId] = position;
                localStorage.setItem('blockPositions', JSON.stringify(savedPositions));
            }

            function saveBlockOrder() {
                // In free positioning mode, we don't need traditional order
                // Instead, we save positions which is handled by saveBlockPosition
            }

            function loadBlockOrder() {
                // Legacy function - positions are now handled differently
                // Keep for backward compatibility but functionality moved to loadBlockPositions
            }

            applyRemovedDefaultBlocks();
            blocks = document.querySelectorAll('.custom-block');

            // Load saved dimensions and positions on page load
            loadBlockDimensions();
            loadBlockPositions();
            
            // Apply initial adaptive sizing
            adaptBlockSizes();

            function createNewBlock(type, config = {}, options = {}) {
                const blockConfig = config && typeof config === 'object' ? config : {};
                const blockId = options.blockId || ('block_' + Date.now());
                const newBlock = document.createElement('div');
                newBlock.className = 'custom-block';
                newBlock.setAttribute('data-block-id', blockId);
                const containerWidth = customBlocks.offsetWidth;
                const adaptiveWidth = Math.max(250, Math.min(320, containerWidth * 0.4));
                const adaptiveHeight = Math.max(160, Math.min(220, window.innerHeight * 0.25));
                const storedWidth = options.dimensions && options.dimensions.width;
                const storedHeight = options.dimensions && options.dimensions.height;
                const resolvedWidth = typeof storedWidth === 'number' ? storedWidth + 'px' : (storedWidth || (adaptiveWidth + 'px'));
                const resolvedHeight = typeof storedHeight === 'number' ? storedHeight + 'px' : (storedHeight || (adaptiveHeight + 'px'));

                // Set dimensions first so collision detection works properly
                newBlock.style.width = resolvedWidth;
                newBlock.style.height = resolvedHeight;

                // Add to container temporarily for collision detection
                newBlock.style.position = 'absolute';
                newBlock.style.left = '-9999px'; // Hide while calculating position
                newBlock.style.top = '-9999px';
                customBlocks.appendChild(newBlock);
                
                // Update blocks collection to include the new block
                blocks = document.querySelectorAll('.custom-block');

                let targetLeft;
                let targetTop;
                let restoredPosition = false;

                if (options.position) {
                    const savedLeft = typeof options.position.left === 'number' ? options.position.left : parseFloat(options.position.left);
                    const savedTop = typeof options.position.top === 'number' ? options.position.top : parseFloat(options.position.top);
                    if (!isNaN(savedLeft) && !isNaN(savedTop)) {
                        targetLeft = savedLeft;
                        targetTop = savedTop;
                        restoredPosition = true;
                    }
                }

                if (!restoredPosition) {
                    const blockWidth = newBlock.offsetWidth || parseInt(resolvedWidth, 10) || adaptiveWidth;
                    const blockHeight = newBlock.offsetHeight || parseInt(resolvedHeight, 10) || adaptiveHeight;
                    const preferredX = Math.max(0, (containerWidth - blockWidth) / 2);
                    const preferredY = Math.max(0, (customBlocks.offsetHeight - blockHeight) / 2);
                    const freePosition = findFreePosition(newBlock, preferredX, preferredY);
                    targetLeft = freePosition.left;
                    targetTop = freePosition.top;
                }

                newBlock.style.left = targetLeft + 'px';
                newBlock.style.top = targetTop + 'px';

                // Add delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '×';
                deleteBtn.title = 'Изтрий блок';
                newBlock.appendChild(deleteBtn);

                // Create content based on type
                const content = createBlockContent(type, blockConfig);
                newBlock.appendChild(content);

                newBlock.dataset.blockType = type;
                if (blockConfig && Object.keys(blockConfig).length) {
                    try {
                        newBlock.dataset.blockConfig = JSON.stringify(blockConfig);
                    } catch (err) {
                        delete newBlock.dataset.blockConfig;
                    }
                }

                const normalizedColor = normalizeColorValue(blockConfig.color || DEFAULT_BLOCK_COLOR);
                blockConfig.color = normalizedColor;
                applyBlockColor(newBlock, normalizedColor);

                // Apply edit mode if active
                if (editMode) {
                    newBlock.classList.add('edit-mode');
                    enableDragAndDrop(newBlock);
                    enableResizeMonitoring(newBlock);
                }

                // Save position and dimensions
                saveBlockPosition(newBlock);
                saveBlockDimensions(newBlock);
                updateContainerHeight();

                // Set up block-specific functionality
                setupBlockFunctionality(newBlock, type, blockConfig);

                if (!options.restoring) {
                    persistCustomBlockData(blockId, type, blockConfig);
                }
            }

            function createBlockContent(type, config = {}) {
                const content = document.createElement('div');

                switch(type) {
                    case 'reminder':
                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">📝</div>
                                <h4>Напомняния</h4>
                            </div>
                            <div class="block-content">
                                <div class="reminder-list">
                                    <div class="reminder-item">
                                        <input type="checkbox" id="remind1_${Date.now()}">
                                        <input type="text" placeholder="Добави напомняне..." value="Примерно напомняне">
                                    </div>
                                </div>
                                <button class="link-btn" onclick="addReminderItem(this)">+ Добави</button>
                            </div>
                        `;
                        break;

                    case 'music': {
                        const title = config.title || 'Музика';
                        const platform = config.platform || 'spotify';
                        const url = (config.url || '').trim();
                        const note = config.note || '';
                        const platformLabels = {
                            spotify: 'Spotify',
                            apple: 'Apple Music',
                            youtube: 'YouTube Music',
                            soundcloud: 'SoundCloud',
                            custom: 'Друго'
                        };
                        const badgeLabel = platformLabels[platform] || 'Music';
                        const hasLink = Boolean(url);
                        const safeUrl = hasLink ? url : '#';

                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">🎵</div>
                                <h4>${title}</h4>
                            </div>
                            <div class="block-content">
                                <div class="music-platform-tag ${platform}">${badgeLabel}</div>
                                <div class="song-info">
                                    <div class="song-title">${note ? note : 'Вашият музикален ъгъл'}</div>
                                    <div class="song-meta">${hasLink ? 'Връзка активна' : 'Добавете връзка от редактора'}</div>
                                </div>
                                <div class="music-controls">
                                    <button class="music-btn" data-action="previous">⏮️</button>
                                    <button class="music-btn play" data-action="toggle">▶️</button>
                                    <button class="music-btn" data-action="next">⏭️</button>
                                </div>
                                <a class="link-btn music-link${hasLink ? '' : ' disabled'}" href="${safeUrl}" ${hasLink ? 'target="_blank" rel="noopener"' : 'data-disabled="true" aria-disabled="true" tabindex="-1"'}>
                                    ${hasLink ? 'Отвори плейлист' : 'Добави линк от редактора'}
                                </a>
                            </div>
                        `;
                        break;
                    }

                    case 'storage':
                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">☁️</div>
                                <h4>Cloud Storage</h4>
                            </div>
                            <div class="block-content">
                                <div class="storage-options">
                                    <div class="storage-option active" data-service="dropbox">Dropbox</div>
                                    <div class="storage-option" data-service="gdrive">Google Drive</div>
                                </div>
                                <a href="https://www.dropbox.com" target="_blank" class="storage-link">
                                    Отвори Dropbox
                                </a>
                            </div>
                        `;
                        break;

                    case 'weather': {
                        const title = config.title || 'Време';
                        const location = config.location || 'София, България';
                        const normalizedUnits = (config.units === 'imperial' || config.units === 'f') ? 'imperial' : 'metric';
                        const unitSymbol = normalizedUnits === 'imperial' ? '°F' : '°C';
                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">🌤️</div>
                                <h4>${title}</h4>
                            </div>
                            <div class="block-content">
                                <div class="weather-info">
                                    <div class="weather-icon">☀️</div>
                                    <div class="weather-details">
                                        <div class="weather-temp">22${unitSymbol}</div>
                                        <div class="weather-desc">Персонализирано време</div>
                                        <div class="weather-desc">${location}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                        break;
                    }

                    case 'quote':
                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">💭</div>
                                <h4>Мотивация</h4>
                            </div>
                            <div class="block-content">
                                <div class="quote-text">
                                    "Успехът е сумата от малките усилия, повтаряни ден след ден."
                                </div>
                                <div class="quote-author">- Робърт Колиър</div>
                            </div>
                        `;
                        break;

                    case 'link':
                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">🔗</div>
                                <h4>Бърз линк</h4>
                            </div>
                            <div class="block-content">
                                <input type="url" class="link-input" placeholder="Въведете URL..." value="https://example.com">
                                <button class="link-btn" onclick="openCustomLink(this)">Отвори линк</button>
                            </div>
                        `;
                        break;

                    case 'checklist': {
                        const title = config.title || 'Чеклист';
                        const items = (config.items && config.items.length) ? config.items : ['Нова задача'];
                        const itemsHtml = items.map((item, index) => `
                            <label class="checklist-item">
                                <input type="checkbox" data-index="${index}">
                                <span>${item}</span>
                            </label>
                        `).join('');
                        const completedText = `0 от ${items.length} завършени`;

                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">✅</div>
                                <h4>${title}</h4>
                            </div>
                            <div class="block-content">
                                ${itemsHtml}
                                <div class="checklist-progress" data-total="${items.length}">
                                    <span>${completedText}</span>
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width:0%"></div>
                                    </div>
                                </div>
                            </div>
                        `;
                        break;
                    }
                }

                return content;
            }

            function setupBlockFunctionality(block, type, config = {}) {
                // Add click handlers and other functionality based on block type
                const addBlockClickHandler = (block, handler) => {
                    block.addEventListener('click', (e) => {
                        if (!editMode && !isResizing && !e.target.closest('.delete-btn')) {
                            handler(e);
                        }
                    });
                };

                // Add delete functionality
                const deleteBtn = block.querySelector('.delete-btn');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (editMode) {
                        deleteBlock(block);
                    }
                });

                // Add hover effects
                block.addEventListener('mouseenter', () => {
                    if (!editMode && !isResizing) {
                        block.style.transform = 'translateY(-4px)';
                        block.style.boxShadow = '0 20px 48px rgba(2,18,40,0.15)';
                    }
                });
                
                block.addEventListener('mouseleave', () => {
                    if (!editMode && !isResizing) {
                        block.style.transform = 'translateY(0)';
                        block.style.boxShadow = '0 12px 32px rgba(2,18,40,0.08)';
                    }
                });

                if (type === 'checklist') {
                    const progressWrap = block.querySelector('.checklist-progress');
                    const progressLabel = progressWrap ? progressWrap.querySelector('span') : null;
                    const progressBar = progressWrap ? progressWrap.querySelector('.progress-fill') : null;
                    const checkboxes = block.querySelectorAll('.checklist-item input[type="checkbox"]');
                    const total = progressWrap ? parseInt(progressWrap.getAttribute('data-total'), 10) || checkboxes.length : checkboxes.length;

                    const updateProgress = () => {
                        const completed = Array.from(checkboxes).filter(cb => cb.checked).length;
                        const percentage = total ? Math.round((completed / total) * 100) : 0;
                        if (progressLabel) {
                            progressLabel.textContent = `${completed} от ${total} завършени`;
                        }
                        if (progressBar) {
                            progressBar.style.width = `${percentage}%`;
                        }
                    };

                    checkboxes.forEach(cb => cb.addEventListener('change', updateProgress));
                }

                if (type === 'music') {
                    const musicLink = block.querySelector('.music-link');
                    const controls = block.querySelectorAll('.music-btn');
                    if (config.url) {
                        block.dataset.musicUrl = config.url;
                    }
                    if (config.platform) {
                        block.dataset.musicPlatform = config.platform;
                    }
                    controls.forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            const action = btn.dataset.action;
                            if (action === 'previous') {
                                previousTrack();
                            } else if (action === 'next') {
                                nextTrack();
                            } else if (action === 'toggle') {
                                togglePlay(btn);
                            }
                        });
                    });
                    if (musicLink && musicLink.dataset.disabled === 'true') {
                        musicLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            if (!editMode) {
                                return;
                            }
                            openBlockBuilder('music');
                        });
                    }
                }

                if (type === 'weather' && config.location) {
                    const normalizedUnits = (config.units === 'imperial' || config.units === 'f') ? 'imperial' : 'metric';
                    block.dataset.weatherLocation = config.location;
                    block.dataset.weatherUnits = normalizedUnits;
                }
            }

            function deleteBlock(block) {
                const blockId = block.getAttribute('data-block-id');
                const defaultBlock = isDefaultBlock(block);
                if (defaultBlock) {
                    markDefaultBlockRemoved(blockId);
                } else {
                    removeCustomBlockData(blockId);
                }
                
                // Remove from localStorage
                let savedPositions = {};
                let savedDimensions = {};
                try {
                    savedPositions = JSON.parse(localStorage.getItem('blockPositions') || '{}') || {};
                } catch (err) {
                    savedPositions = {};
                }
                try {
                    savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}') || {};
                } catch (err) {
                    savedDimensions = {};
                }
                delete savedPositions[blockId];
                delete savedDimensions[blockId];
                localStorage.setItem('blockPositions', JSON.stringify(savedPositions));
                localStorage.setItem('blockDimensions', JSON.stringify(savedDimensions));

                // Remove from DOM
                block.remove();

                // Update blocks collection
                blocks = document.querySelectorAll('.custom-block');
                updateContainerHeight();
            }

            // Add delete functionality to existing blocks
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (editMode) {
                        deleteBlock(btn.closest('.custom-block'));
                    }
                });
            });

            // Original functionality (only when not in edit mode)
            const calendarBlock = document.querySelector('.calendar-block');
            const homeworkBlock = document.querySelector('.homework-block');
            const curriculumBlock = document.querySelector('.curriculum-block');

            function addBlockClickHandler(block, handler) {
                block.addEventListener('click', (e) => {
                    if (!editMode && !isResizing) {
                        handler(e);
                    }
                });
            }

            // Calendar block click handler
            addBlockClickHandler(calendarBlock, () => {
                window.open('https://calendar.google.com', '_blank');
            });

            // Homework block functionality
            const homeworkCheckboxes = document.querySelectorAll('.homework-item input[type="checkbox"]');
            const progressElement = document.querySelector('.homework-progress span');
            
            function updateHomeworkProgress() {
                const total = homeworkCheckboxes.length;
                const completed = Array.from(homeworkCheckboxes).filter(cb => cb.checked).length;
                progressElement.textContent = `${completed} от ${total} завършени`;
            }

            homeworkCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', updateHomeworkProgress);
            });

            // Homework block click handler
            addBlockClickHandler(homeworkBlock, (e) => {
                if (e.target.type === 'checkbox' || e.target.tagName === 'LABEL') return;
                alert('Домашни задания - функцията ще бъде добавена скоро!');
            });

            // Curriculum block click handler
            addBlockClickHandler(curriculumBlock, () => {
                alert('Учебна програма - настройките ще бъдат достъпни в менюто Settings!');
            });

            // Add hover effects to custom blocks (only when not in edit mode or resizing)
            blocks.forEach(block => {
                block.addEventListener('mouseenter', () => {
                    if (!editMode && !isResizing) {
                        block.style.transform = 'translateY(-4px)';
                        block.style.boxShadow = '0 20px 48px rgba(2,18,40,0.15)';
                    }
                });
                
                block.addEventListener('mouseleave', () => {
                    if (!editMode && !isResizing) {
                        block.style.transform = 'translateY(0)';
                        block.style.boxShadow = '0 12px 32px rgba(2,18,40,0.08)';
                    }
                });
            });
        })();
    </script>

    <script>
        // Add 'lift' on mouseenter and 'land' on mouseleave for cards and icon buttons
        (function(){
            if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
            const els = document.querySelectorAll('.card, .icon-btn');
            els.forEach(el=>{
                el.addEventListener('mouseenter', ()=>{
                    el.classList.remove('land');
                    el.classList.add('lift');
                });
                el.addEventListener('mouseleave', ()=>{
                    // on leave, remove lift and run land animation once
                    el.classList.remove('lift');
                    // force reflow so animation can replay reliably
                    void el.offsetWidth;
                    el.classList.add('land');
                });
                // Clean up class when animation ends
                el.addEventListener('animationend', (ev)=>{
                    // only remove when our land animation finishes
                    if(ev.animationName && ev.animationName.indexOf('land')!==-1){
                        el.classList.remove('land');
                    }
                });
            });
        })();
    </script>

    <script>
        // single-run sheen control for icon buttons, cards, and custom blocks
        (function(){
            if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
            const targets = document.querySelectorAll('.icon-btn, .card, .custom-block');
            function finishOutgoing(){
                document.querySelectorAll('.sheen-back').forEach(el=>{
                    // force it to its end state, then remove classes shortly after
                    el.classList.add('sheen-end');
                    // force reflow so styles apply
                    void el.offsetWidth;
                    setTimeout(()=> el.classList.remove('sheen-back','sheen-end'), 50);
                });
            }
            function addOnce(el, cls){
                // Don't add sheen if resizing, in edit mode, or actively being resized
                if (el.classList.contains('resizing') || 
                    el.classList.contains('dragging') ||
                    (el.classList.contains('custom-block') && 
                     (el.closest('.custom-blocks').classList.contains('resizing-active') ||
                      el.classList.contains('edit-mode')))) {
                    return;
                }
                
                // finish any outgoing sheen animations first so they don't linger
                finishOutgoing();
                el.classList.remove('sheen-run','sheen-back');
                // force reflow
                void el.offsetWidth;
                el.classList.add(cls);
            }
            targets.forEach(el=>{
                el.addEventListener('mouseenter', ()=> addOnce(el,'sheen-run'));
                el.addEventListener('mouseleave', ()=> addOnce(el,'sheen-back'));
                el.addEventListener('animationend', (ev)=>{
                    // only remove when our sheen animation finishes
                    if(ev.animationName && ev.animationName.indexOf('button-sheen')!==-1){
                        el.classList.remove('sheen-run','sheen-back');
                    }
                });
            });
        })();
    </script>

    <script>
        // reflection: update --mx/--my and fade the reflection according to pointer
        (function(){
            if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
            const btns = document.querySelectorAll('.icon-btn');
            btns.forEach(btn=>{
                btn.addEventListener('mousemove', (e)=>{
                    const r = btn.getBoundingClientRect();
                    const x = ((e.clientX - r.left)/r.width)*100;
                    const y = ((e.clientY - r.top)/r.height)*100;
                    btn.style.setProperty('--mx', x + '%');
                    btn.style.setProperty('--my', y + '%');
                    btn.style.setProperty('--ref-opacity', '0.9');
                });
                btn.addEventListener('mouseenter', ()=> btn.style.setProperty('--ref-opacity','0.9'));
                btn.addEventListener('mouseleave', ()=> btn.style.setProperty('--ref-opacity','0'));
            });

            // pill reflection
            const pills = document.querySelectorAll('.pill');
            pills.forEach(pill=>{
                pill.addEventListener('mousemove', (e)=>{
                    const r = pill.getBoundingClientRect();
                    const x = ((e.clientX - r.left)/r.width)*100;
                    const y = ((e.clientY - r.top)/r.height)*100;
                    pill.style.setProperty('--mx', x + '%');
                    pill.style.setProperty('--my', y + '%');
                    pill.style.setProperty('--pill-ref-opacity', '0.85');
                });
                pill.addEventListener('mouseenter', ()=> pill.style.setProperty('--pill-ref-opacity','0.85'));
                pill.addEventListener('mouseleave', ()=> pill.style.setProperty('--pill-ref-opacity','0'));
            });
        })();
    </script>

    <script>
        // Helper functions for specific block types
        function addReminderItem(button) {
            const reminderList = button.parentElement.querySelector('.reminder-list');
            const newItem = document.createElement('div');
            newItem.className = 'reminder-item';
            const itemId = 'remind' + Date.now();
            newItem.innerHTML = `
                <input type="checkbox" id="${itemId}">
                <input type="text" placeholder="Добави напомняне..." value="">
            `;
            reminderList.appendChild(newItem);
        }

        function togglePlay(button) {
            const playBtn = button || (typeof event !== 'undefined' ? event.target : null);
            if (!playBtn) return;
            if (playBtn.textContent === '▶️') {
                playBtn.textContent = '⏸️';
                // Here you would add actual music playing logic
            } else {
                playBtn.textContent = '▶️';
                // Here you would add actual music pausing logic
            }
        }

        function previousTrack() {
            // Add previous track logic
            console.log('Previous track');
        }

        function nextTrack() {
            // Add next track logic
            console.log('Next track');
        }

        function openCustomLink(button) {
            const linkInput = button.parentElement.querySelector('.link-input');
            const url = linkInput.value;
            if (url && url.trim() !== '') {
                window.open(url, '_blank');
            }
        }

        // Storage service switching
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('storage-option')) {
                const storageOptions = e.target.parentElement;
                const storageLink = storageOptions.parentElement.querySelector('.storage-link');
                
                // Remove active class from all options
                storageOptions.querySelectorAll('.storage-option').forEach(opt => {
                    opt.classList.remove('active');
                });
                
                // Add active class to clicked option
                e.target.classList.add('active');
                
                // Update link
                const service = e.target.getAttribute('data-service');
                if (service === 'dropbox') {
                    storageLink.href = 'https://www.dropbox.com';
                    storageLink.textContent = 'Отвори Dropbox';
                } else if (service === 'gdrive') {
                    storageLink.href = 'https://drive.google.com';
                    storageLink.textContent = 'Отвори Google Drive';
                }
            }
        });

        // Prevent edit mode activation when interacting with form elements
        document.addEventListener('click', function(e) {
            if (e.target.matches('input, button, .storage-option, .music-btn') && 
                e.target.closest('.custom-block')) {
                e.stopPropagation();
            }
        });

        // Add click handler for "Нова +" button to redirect to Flashcardcreate.html
        document.addEventListener('DOMContentLoaded', function() {
            const newCardButton = document.querySelector('.card.add');
            if (newCardButton) {
                newCardButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    window.location.href = 'Flashcardcreate.html';
                });
            }

            // Fetch and render recent flashcards for authenticated users
            const recentContainer = document.getElementById('recentCards');
            function stripAndSnippet(html, limit = 110){
                const text = (html || '').replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
                if(!text) return '';
                return text.length <= limit ? text : text.slice(0, limit) + '…';
            }
            async function renderRecentCards(){
                if(!recentContainer || !window.ssApi) return;
                try{
                    const resp = await ssApi.getRecentFlashcards();
                    if(!resp || !resp.ok) return;
                    const cards = resp.cards || [];
                    const addBtn = recentContainer.querySelector('.card.add');
                    recentContainer.innerHTML = '';
                    if(addBtn) recentContainer.appendChild(addBtn);
                    if(cards.length === 0){
                        const placeholder = document.createElement('div');
                        placeholder.className = 'card';
                        placeholder.innerHTML = '<div class="card-content" style="text-align:center"><div style="font-size:14px;font-weight:800">Няма последни карти</div><div class="label">Започнете с Нова</div></div>';
                        recentContainer.appendChild(placeholder);
                    } else {
                        cards.forEach(c => {
                            const item = document.createElement('div');
                            item.className = 'card';
                            item.dataset.id = c.id || '';
                            const content = document.createElement('div');
                            content.className = 'card-content';
                            content.style.textAlign = 'center';
                            const front = document.createElement('div');
                            front.style.fontSize = '14px'; front.style.fontWeight = '800';
                            front.textContent = stripAndSnippet(c.front || (c.metadata && c.metadata.front) || '');
                            const label = document.createElement('div');
                            label.className = 'label';
                            label.textContent = c.tags || '';
                            content.appendChild(front); content.appendChild(label);
                            item.appendChild(content);
                            item.addEventListener('click', () => { window.location.href = `Flashcardcreate.html?cardId=${encodeURIComponent(c.id)}`; });
                            recentContainer.appendChild(item);
                        });
                        // If URL requested a highlightCard, apply visual highlight and remove after timeout
                        try{
                            const params = new URLSearchParams(location.search);
                            const highlight = params.get('highlightCard');
                            if(highlight){
                                const hit = recentContainer.querySelector(`.card[data-id="${highlight}"]`);
                                if(hit){
                                    hit.classList.add('selected');
                                    try{ hit.scrollIntoView({ behavior: 'smooth', block: 'center' }); }catch(e){}
                                    setTimeout(() => { hit.classList.remove('selected'); }, 3500);
                                }
                            }
                        }catch(e){/* ignore */}
                    }
                }catch(err){
                    console.warn('Failed to load recent flashcards', err);
                }
            }
            // Attempt initial render and refresh every minute
            setTimeout(renderRecentCards, 800);
            setInterval(renderRecentCards, 60000);
            // Load user customization (blocks, theme) when authenticated
            async function loadUserCustomization(){
                if(!window.ssApi) return;
                const token = localStorage.getItem('ss_token');
                if(!token) return; // not logged in
                try{
                    const resp = await ssApi.getBlocks();
                    if(!resp || !resp.ok) return;
                    const blocksFromServer = resp.blocks || [];
                    // Apply global theme if present
                    const themeBlock = blocksFromServer.find(b => b.block_key === 'global_theme');
                    if(themeBlock && themeBlock.style){
                        try{
                            const style = themeBlock.style;
                            Object.keys(style).forEach(k => {
                                try{ document.documentElement.style.setProperty('--' + k, style[k]); }catch(e){}
                            });
                        }catch(e){ console.warn('apply theme failed', e); }
                    }
                    // Restore custom blocks (ignore global_theme)
                    const customBlocksFromServer = blocksFromServer.filter(b => b.block_key && b.block_key !== 'global_theme');
                    if(customBlocksFromServer.length){
                        // Clear any previously restored server blocks to avoid duplicates
                        // We'll rely on createNewBlock to place them respecting given positions
                        for(const b of customBlocksFromServer){
                            try{
                                const cfg = Object.assign({}, b.style || {});
                                const pos = b.position || {};
                                // Use numeric id as stable block identifier when possible
                                const blockId = b.id || b.block_key || ('block_' + Date.now());
                                // createNewBlock(type, config, options)
                                // Use block_key as type hint; fallback to 'custom'
                                const type = b.block_key || 'custom';
                                createNewBlock(type, cfg, { blockId: String(blockId), position: pos, restoring: true });
                            }catch(e){ console.warn('restore block failed', e); }
                        }
                        blocks = document.querySelectorAll('.custom-block');
                        // Re-apply block sizes/positions persistence helpers
                        loadBlockDimensions();
                        loadBlockPositions();
                    }
                }catch(err){ console.warn('Failed to load user customization', err); }
            }
            // Try to load customization after recent cards render
            setTimeout(loadUserCustomization, 1200);
        });
</script> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

    <style>
        /* Оправяме видимостта на менюто */
        .profile-dropdown { 
            display: none; 
            position: absolute; 
            right: 20px; 
            top: 70px; 
            background: white; 
            border-radius: 12px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.15); 
            width: 220px; 
            z-index: 99999; 
            padding: 10px 0;
        }
        .profile-dropdown.active { display: block !important; }
        .profile-dropdown ul { list-style: none; padding: 0; margin: 0; }
        .profile-dropdown ul li a { 
            display: flex !important; 
            align-items: center !important; 
            padding: 12px 20px !important; 
            gap: 12px; 
            color: #333 !important; 
            text-decoration: none !important;
            font-size: 14px;
        }
        .profile-dropdown ul li a:hover { background: #f8faff; }
        .profile-dropdown ul li a i { color: #4a90e2; width: 20px; text-align: center; }
    </style>

    <script>
        // Функция за Logout
        async function logoutNow() {
            if (window.supabaseClient) {
                await window.supabaseClient.auth.signOut();
            }
            localStorage.clear();
            window.location.href = 'login.html';
        }

        // Главна функция за оправяне на UI
        async function initializeUI() {
            const profileImg = document.querySelector('.user-pic, .profile-img');
            const dropdown = document.querySelector('.profile-dropdown');

            // 1. Отваряне/затваряне на менюто
            if (profileImg && dropdown) {
                profileImg.style.cursor = 'pointer';
                profileImg.onclick = (e) => {
                    e.stopPropagation();
                    dropdown.classList.toggle('active');
                };
                document.addEventListener('click', () => dropdown.classList.remove('active'));
            }

            // 2. Слагаме новите икони в менюто
            const menuList = document.querySelector('.profile-dropdown ul');
            if (menuList) {
                menuList.innerHTML = `
                    <li><a href="#"><i class="fa-solid fa-user-gear"></i> Настройки</a></li>
                    <li><a href="javascript:void(0)" onclick="logoutNow()"><i class="fa-solid fa-right-from-bracket"></i> Изход</a></li>
                `;
            }

            // 3. Зареждаме името от Supabase (ако е зареден)
            if (window.supabaseClient) {
                const { data: { user } } = await supabaseClient.auth.getUser();
                if (user) {
                    const nameTag = document.querySelector('.user-info h3');
                    if (nameTag) nameTag.textContent = user.user_metadata.full_name || user.email.split('@')[0];
                }
            }
        }

        // Стартираме, когато всичко е заредено
        window.addEventListener('load', initializeUI);
    </script>
</body>
</html>
