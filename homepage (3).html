<!DOCTYPE html>
<html lang="bg">
<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Supabase config (added by assistant) -->
    <meta name="supabase-url" content="https://zfqpfhtbpfdudbpqzbbg.supabase.co">
    <meta name="supabase-key" content="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpmcXBmaHRicGZkdWRicHF6YmJnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgyOTQ5NzQsImV4cCI6MjA4Mzg3MDk3NH0.QnmNeFn9LX9ZIc-bINH_4DNKFeJj9LCYU7QF5ZwfaDE">
    <title>Study Space</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root{
            --bg:#e6f2ff;
            --glass-1: rgba(255,255,255,0.65);
            --glass-2: rgba(230,245,255,0.40);
            --accent:#0b63c7; /* stronger blue */
            --accent-2:#009fe6;
            --accent-dark:#05294a;
            --muted:#6b87b7;
            --soft:#f6fbff;
            /* Themeable gradient colors */
            --grad-start: rgba(32, 102, 255, 0.72);
            --grad-end: rgba(255, 255, 255, 0.5);
            --frame-pad:clamp(14px,2.2vw,28px);
            --gap:clamp(10px,1.4vw,18px);
        }

        *{box-sizing:border-box}
        html,body{height:100%}
        /* Page background
           Smooth gradient that fades into solid background
           so tall pages don't show hard horizontal bands. */
        body{
            margin:0;
            font-family:'Montserrat',Arial,sans-serif;
            background:linear-gradient(
                180deg,
                var(--grad-start) 0,
                var(--grad-end) 420px,
                var(--bg) 840px,
                var(--bg) 100%
            );
            color:var(--accent-dark);
            display:block;
            padding:0;
            min-height:100vh;
        }

        /* Frame remains transparent */
        .frame{
            width:100vw;
            max-width:100%;
            background:transparent; /* no glass panel */
            border-radius:0;
            padding:clamp(18px,3.2vw,36px) clamp(20px,4vw,56px);
            -webkit-backdrop-filter: none;
            backdrop-filter: none;
            border:0;
            box-shadow:none;
            margin:0;
            position:relative;overflow:visible;
        }

        /* Top bar fully transparent so background shows through */
        .topbar{display:flex;align-items:center;justify-content:space-between;padding:12px 8px;gap:var(--gap);background:transparent}

        /* transparent, light glassy icon buttons */
        .icon-btn{width:56px;height:56px;border-radius:999px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(255,255,255,0.14), rgba(255,255,255,0.06));border:1px solid rgba(255,255,255,0.12);box-shadow:0 8px 20px rgba(4,30,60,0.12);position:relative;overflow:hidden;backdrop-filter:blur(6px)}

        /* faint mouse-position reflection (uses CSS vars set by JS) */
        .icon-btn::before{content:'';position:absolute;left:0;top:0;right:0;bottom:0;border-radius:999px;pointer-events:none;z-index:1;mix-blend-mode:screen;background:radial-gradient(circle at var(--mx,50%) var(--my,50%), rgba(255,255,255,0.92) 0%, rgba(255,255,255,0.40) 18%, rgba(255,255,255,0.18) 36%, rgba(255,255,255,0.04) 60%, transparent 75%);opacity:var(--ref-opacity,0);transition:opacity 360ms ease, transform 260ms ease;filter:blur(6px);}

        /* elongated center bar (wide pill) */
        .center-pill{flex:1;display:flex;justify-content:center;padding:0 8px}
        /* pill restored to semi-transparent glass */
        .pill{width:min(1100px,92%);background:linear-gradient(90deg, rgba(255,255,255,0.10), rgba(240,250,255,0.06));border-radius:40px;padding:12px 28px;border:1px solid rgba(255,255,255,0.12);display:flex;justify-content:center;gap:24px;font-weight:800;align-items:center;position:relative;overflow:visible;backdrop-filter:blur(6px)}
        .pill span{font-size:clamp(15px,1.4vw,18px);color:#e6f5ff;position:relative;z-index:2}

        /* subtle inside accent for pill (disabled) */
        .pill::after{content:'';position:absolute;left:6%;right:6%;top:50%;height:0;border-radius:999px;transform:translateY(-50%);background:transparent;opacity:0;pointer-events:none}

        /* white sheen animation for icon buttons (contained inside button) */
        .icon-btn::after{content:'';position:absolute;top:-20%;left:-60%;width:36%;height:140%;background:linear-gradient(120deg, rgba(255,255,255,0.95), rgba(255,255,255,0.65), rgba(255,255,255,0.28));transform:skewX(-22deg) translateX(0);opacity:0;transition:opacity 160ms;z-index:2;pointer-events:none}
        @keyframes button-sheen { from { transform:skewX(-22deg) translateX(-120%); opacity:0 } 10% { opacity:0.9 } to { transform:skewX(-22deg) translateX(220%); opacity:0 } }
        .icon-btn:hover::after{animation: button-sheen 640ms cubic-bezier(.2,.9,.3,1);}

        /* single-run sheen helpers: play only when the element has .sheen-run or .sheen-back */
        .icon-btn.sheen-run::after{animation: button-sheen 900ms cubic-bezier(.18,.8,.25,1) 1 forwards;}
        .icon-btn.sheen-back::after{animation: button-sheen 480ms cubic-bezier(.3,.9,.4,1) 1 reverse;}

        /* helper to force-finish an outgoing sheen so it doesn't linger when another button is hovered */
        .icon-btn.sheen-end::after{transform:skewX(-22deg) translateX(220%) !important;opacity:0 !important;transition:none !important}
        .card.sheen-end::before{transform:skewX(-18deg) translateX(220%) !important;opacity:0 !important;transition:none !important}

        /* Cards area */
        .cards-wrap{margin-top:calc(var(--gap) * 1.2);padding:18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.4), rgba(240,250,255,0.18));border:1px solid rgba(255,255,255,0.6);display:flex;align-items:flex-start;box-shadow:0 8px 24px rgba(45,80,150,0.04)}

        /* Responsive flow: cards will wrap and scale to available width */
        .cards{display:flex;gap:var(--gap);width:100%;flex-wrap:wrap;align-items:flex-start}

        /* Cards: make them light, glassy and button-like */
        .card{
            flex:1 1 clamp(200px,28%,320px);
            min-width:180px;
            min-height:140px;
            padding:18px 20px;
            border-radius:12px;
            background:linear-gradient(180deg, rgba(255,255,255,0.14), rgba(245,250,255,0.06));
            border:1px solid rgba(255,255,255,0.18);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            box-shadow:0 10px 30px rgba(2,18,40,0.12);
            display:flex;flex-direction:column;align-items:center;justify-content:center;font-weight:800;color:var(--accent-dark);text-align:center;
            gap:8px;position:relative;overflow:visible;z-index:2
        }
        .card.selected{outline:3px solid rgba(29,78,216,0.12);box-shadow:0 36px 92px rgba(11,99,199,0.28);transform:translateY(-6px)}
        .card::after{ /* subtle inner sheen */
            content:'';position:absolute;left:0;right:0;top:0;height:40%;border-radius:12px;pointer-events:none;background:linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0));mix-blend-mode:overlay;opacity:0.9;
        }

        /* animated contained sheen for cards (same behaviour as icon buttons) */
        .card::before{content:'';position:absolute;top:-40%;left:-80%;width:60%;height:200%;background:linear-gradient(120deg, rgba(255,255,255,0.9), rgba(255,255,255,0.12), rgba(255,255,255,0));transform:skewX(-20deg) translateX(0);opacity:0;transition:transform 620ms cubic-bezier(.2,.9,.3,1),opacity 220ms;z-index:1;pointer-events:none;border-radius:12px}
        .card:hover::before{transform:translateX(220%);opacity:1}
        .card > .card-content{position:relative;z-index:2}
        .card{cursor:pointer}

        /* single-run sheen helpers: play only when the element has .sheen-run or .sheen-back */
        .card.sheen-run::before{animation: button-sheen 900ms cubic-bezier(.18,.8,.25,1) 1;}
        .card.sheen-back::before{animation: button-sheen 480ms cubic-bezier(.3,.9,.4,1) 1 reverse;}

        /* ensure pseudo-elements are always clipped to the button area */
        .icon-btn,.card{overflow:hidden}

        @media (prefers-reduced-motion: reduce){
            .card::before{transition:none;opacity:0}
            .icon-btn::after{animation:none;opacity:0}
        }

        /* When there is little space, stack cards vertically */
        @media (max-width:640px){
            .topbar{gap:10px}
            .pill{min-width:160px;padding:clamp(8px,4vw,14px)}
            .cards{flex-direction:column}
            .card{width:100%;flex-basis:auto}
            .card.add{order:-1}
        }

        /* dark reduced motion preference */
        @media (prefers-reduced-motion: reduce){
            .card:hover{transform:none;transition:none}
            .card.land{animation:none}
            .icon-btn::after,.icon-btn::before{transition:none;opacity:0}
        }

        /* Glass only on icon buttons: controlled sheen animation that stays inside button */
        .icon-btn{overflow:hidden}
        .icon-btn::after{content:'';position:absolute;top:-40%;left:-80%;width:60%;height:200%;background:linear-gradient(120deg, rgba(255,255,255,0.9), rgba(255,255,255,0.12), rgba(255,255,255,0));transform:skewX(-20deg) translateX(0);opacity:0;transition:transform 620ms cubic-bezier(.2,.9,.3,1),opacity 220ms;z-index:1}
        .icon-btn:hover::after{transform:translateX(220%);opacity:1}
        .icon-btn > div{position:relative;z-index:3}

        /* Disable CSS-only hover sheen except when JS has applied the single-run classes */
        .icon-btn:not(.sheen-run):not(.sheen-back):hover::after,
        .card:not(.sheen-run):not(.sheen-back):hover::before{animation:none !important;transform:none !important;opacity:0 !important}

        /* gentle lift on hover (now JS-controlled via .lift) */
        .card.lift{transform:translateY(-6px);box-shadow:0 26px 64px rgba(6,40,90,0.12);transition:transform 240ms cubic-bezier(.2,.9,.3,1),box-shadow 240ms}
        .icon-btn.lift{transform:translateY(-4px);box-shadow:0 18px 44px rgba(6,40,90,0.10);transition:transform 220ms cubic-bezier(.2,.9,.3,1),box-shadow 220ms}

        /* Drag-over emphasis for the "Нова" card when dropping файлове */
        .card.add.drag-ready{
            transform:scale(1.04);
            box-shadow:0 32px 88px rgba(11,99,199,0.38);
            border-color:rgba(255,255,255,0.6);
        }

        /* 'Land' animation: smooth return to original position without overshoot */
        @keyframes land { from { transform: translateY(-8px); } to { transform: translateY(0); } }
        .card.land { animation: land 220ms cubic-bezier(0.22, 0.9, 0.36, 1); }
        .icon-btn.land { animation: land 200ms cubic-bezier(0.22, 0.9, 0.36, 1); }

        /* faint mouse-position reflection for pill */
        .pill{overflow:hidden}
        .pill::before{
            content:'';position:absolute;left:0;top:0;right:0;bottom:0;border-radius:40px;pointer-events:none;z-index:1;mix-blend-mode:screen;
            background:radial-gradient(circle at var(--mx,50%) var(--my,50%), rgba(255,255,255,0.92) 0%, rgba(255,255,255,0.42) 16%, rgba(255,255,255,0.18) 34%, rgba(255,255,255,0.06) 60%, transparent 76%);
            opacity:var(--pill-ref-opacity,0);transition:opacity 420ms ease, transform 260ms ease;filter:blur(8px);
        }
        .pill::after{z-index:2}
        .pill > span{position:relative;z-index:3}

        .home-clipboard{position:relative;display:flex;flex-direction:column;align-items:center;width:min(1100px,92%);gap:10px;z-index:1;padding-bottom:24px}
        .home-clipboard.open{z-index:460}
        .home-clipboard .pill{width:100%;position:relative;padding-right:110px;padding-left:28px;padding-top:10px;padding-bottom:10px;border-radius:34px}
        .home-capsule{justify-content:center;gap:20px;cursor:default;transition:transform 0.5s cubic-bezier(.25,.85,.35,1),box-shadow 0.4s ease,border-color 0.25s ease;min-height:48px;outline:none;position:relative;z-index:2;box-shadow:0 12px 34px rgba(6,40,90,0.14);will-change:transform,box-shadow}
        .home-capsule:focus-visible{box-shadow:0 0 0 3px rgba(11,99,199,0.28)}
        .home-capsule span{color:#e6f5ff;font-size:clamp(15px,1.4vw,18px);font-weight:inherit}
        .home-clipboard-count{position:absolute;top:50%;right:12px;min-width:32px;height:22px;padding:0 12px;border-radius:999px;background:linear-gradient(135deg,var(--accent),var(--accent-2));color:#fff;font-size:11px;font-weight:700;display:flex;align-items:center;justify-content:center;box-shadow:0 16px 36px rgba(11,99,199,0.32);transform:translateY(-50%) scale(0);opacity:0;transition:transform 0.3s ease,opacity 0.3s ease;pointer-events:none;z-index:4}
        .home-clipboard.has-items .home-clipboard-count{transform:translateY(-50%) scale(1);opacity:1}
        .home-clipboard.drag-ready{z-index:480}
        .home-clipboard.drag-ready .home-capsule{transform:scale(1.12);box-shadow:0 58px 120px rgba(6,40,90,0.26);border-color:rgba(255,255,255,0.32)}
        .home-clipboard.captured .home-capsule{animation:homeCapsuleSnap 0.6s cubic-bezier(.3,1.2,.3,1)}
        @keyframes homeCapsuleSnap{0%{transform:scale(1.08);}50%{transform:scale(0.96);}100%{transform:scale(1);}}
        .home-clipboard-panel{position:absolute;left:0;top:calc(100% - 10px);width:100%;background:linear-gradient(200deg, rgba(255,255,255,0.28), rgba(235,245,255,0.12));border:1px solid rgba(255,255,255,0.32);border-radius:30px;padding:0 24px;max-height:0;opacity:0;overflow:hidden;transition:max-height 0.45s cubic-bezier(.25,.9,.3,1),opacity 0.28s ease,padding 0.3s ease,transform 0.35s cubic-bezier(.3,.95,.4,1);pointer-events:none;backdrop-filter:blur(24px);box-shadow:0 44px 88px rgba(5,20,45,0.32);transform:translateY(-26px) scaleY(0.88);transform-origin:top center}
        .home-clipboard-panel::before{content:'';position:absolute;left:40px;right:40px;top:-28px;height:36px;border-radius:20px;background:linear-gradient(200deg, rgba(255,255,255,0.3), rgba(235,245,255,0.14));opacity:0;transform:translateY(12px);transition:opacity 0.32s ease,transform 0.32s cubic-bezier(.3,.95,.4,1);pointer-events:none}
        .home-clipboard.open .home-clipboard-panel{max-height:420px;opacity:1;padding:22px 24px 26px;pointer-events:auto;transform:translateY(0) scaleY(1);overflow:auto}
        .home-clipboard.open .home-clipboard-panel::before{opacity:1;transform:translateY(0)}
        .home-clipboard.open .home-clipboard-panel::-webkit-scrollbar{width:8px}
        .home-clipboard.open .home-clipboard-panel::-webkit-scrollbar-thumb{background:rgba(11,99,199,0.3);border-radius:999px}
        .home-clipboard-empty{margin:0 0 12px;font-size:13px;color:rgba(230,245,255,0.82);text-align:center}
        .home-clipboard.has-items .home-clipboard-empty{display:none}
        .home-clipboard-list{list-style:none;margin:0;padding:0;display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:14px}
        .home-clipboard-item{position:relative;display:flex;align-items:flex-start;gap:14px;padding:14px 16px;border-radius:18px;background:rgba(255,255,255,0.18);border:1px solid rgba(255,255,255,0.28);box-shadow:0 18px 42px rgba(5,20,45,0.18);cursor:grab;transition:transform 0.25s ease,box-shadow 0.25s ease,opacity 0.2s ease}
        .home-clipboard-item:hover{transform:translateY(-4px);box-shadow:0 24px 52px rgba(5,20,45,0.24)}
        .home-clipboard-item:active{cursor:grabbing}
        .home-clipboard-item.dragging{opacity:0.65;transform:scale(0.98)}
        .home-clipboard-preview{flex:0 0 64px;width:64px;height:64px;border-radius:14px;background:rgba(255,255,255,0.16);border:1px solid rgba(255,255,255,0.26);overflow:hidden;display:flex;align-items:center;justify-content:center;color:var(--accent-dark);text-align:center}
        .home-clipboard-preview img{width:100%;height:100%;object-fit:cover;display:block}
        .home-clipboard-preview-icon{font-size:24px}
        .home-clipboard-info{flex:1;display:flex;flex-direction:column;gap:6px;min-width:0}
        .home-clipboard-item-title{font-size:13px;font-weight:600;color:var(--accent-dark);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .home-clipboard-snippet{font-size:11px;line-height:1.35;color:var(--accent-dark);margin:0;overflow:hidden;display:-webkit-box;line-clamp:2;-webkit-line-clamp:2;-webkit-box-orient:vertical}
        .home-clipboard-item-details{font-size:10px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px}

        @media (max-width:640px){
            .home-capsule{flex-direction:column;align-items:center;gap:8px}
            .home-capsule span{text-align:center}
            .home-clipboard-count{top:50%;right:12px;transform:translateY(-50%) scale(0)}
            .home-clipboard.has-items .home-clipboard-count{transform:translateY(-50%) scale(1)}
        }

        @media (prefers-reduced-motion: reduce){
            .home-capsule{transition:none}
            .home-clipboard-panel{transition:none;transform:none}
            .home-clipboard.drag-ready .home-capsule{transform:none;box-shadow:0 12px 34px rgba(6,40,90,0.14)}
            .home-clipboard.captured .home-capsule{animation:none}
        }

        /* Custom Blocks Styles */
        .custom-blocks-wrap {
            margin-top: calc(var(--gap) * 2);
            padding: 0;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--gap);
            padding: 0 8px;
        }

        .section-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title {
            font-size: clamp(18px, 2.2vw, 24px);
            font-weight: 700;
            color: var(--accent-dark);
            margin: 0;
        }

        .edit-btn {
            padding: 8px 16px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            background: linear-gradient(180deg, rgba(255,255,255,0.2), rgba(245,250,255,0.08));
            backdrop-filter: blur(8px);
            font-family: 'Montserrat', sans-serif;
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-dark);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .edit-btn::before {
            content: '';
            position: absolute;
            top: -40%;
            left: -80%;
            width: 60%;
            height: 200%;
            background: linear-gradient(120deg, rgba(255, 255, 255, 0.9), rgba(255,255,255,0.12), rgba(255,255,255,0));
            transform: skewX(-20deg) translateX(0);
            opacity: 0;
            transition: transform 620ms cubic-bezier(.2,.9,.3,1), opacity 220ms;
            z-index: 1;
            pointer-events: none;
            border-radius: 12px;
        }

        .edit-btn:hover::before {
            transform: skewX(-20deg) translateX(220%);
            opacity: 1;
        }

        .edit-btn > span {
            position: relative;
            z-index: 2;
        }

        .edit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(6,40,90,0.12);
            border-color: rgba(255,255,255,0.4);
        }

        .edit-btn:disabled {
            opacity: 0.55;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .edit-btn:disabled::before {
            opacity: 0;
        }

        .edit-btn.active {
            background: linear-gradient(180deg, var(--accent-2), var(--accent));
            color: white;
            border-color: var(--accent);
        }

        .edit-btn.active:hover {
            background: linear-gradient(180deg, var(--accent), var(--accent-2));
        }

        .custom-blocks {
            display: block; /* Always use block layout for absolute positioning */
            position: relative;
            gap: var(--gap);
            width: 100%;
            transition: all 0.3s ease;
            min-height: 400px; /* Ensure minimum container height */
        }

        /* Grid mode for free positioning
           Grid is shown only while actively dragging a block. */
        .custom-blocks.edit-mode {
            position: relative;
            min-height: 600px;
            display: block; /* Change from grid to block for free positioning */
            overflow: visible; /* Allow content to extend beyond initial bounds */
            transition: min-height 0.3s ease, background-size 0.3s ease, background-image 0.25s ease;
        }

        .custom-blocks.edit-mode.show-grid {
            background-image: radial-gradient(circle, rgba(107, 135, 183, 0.3) 2px, transparent 2px);
            background-size: clamp(15px, 2vw, 25px) clamp(15px, 2vw, 25px);
            background-position: 0 0;
        }

        /* Exit state keeps behaviour but no longer controls grid visibility */
        .custom-blocks.edit-mode-exit {
            animation: gridFadeOut 0.3s ease;
        }

        .custom-block {
            --block-bg: linear-gradient(180deg, rgba(255,255,255,0.25), rgba(245,250,255,0.08));
            --block-border: rgba(255,255,255,0.25);
            --block-shadow: 0 12px 32px rgba(2,18,40,0.08);
            padding: clamp(16px, 3vw, 20px);
            border-radius: clamp(12px, 2vw, 16px);
            background: var(--block-bg);
            border: 1px solid var(--block-border);
            backdrop-filter: blur(10px);
            box-shadow: var(--block-shadow);
            position: absolute; /* Always use absolute positioning */
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            resize: none; /* Disabled by default */
            min-width: clamp(250px, 35vw, 280px);
            min-height: clamp(160px, 20vh, 180px);
            max-width: calc(100vw - clamp(40px, 8vw, 80px));
            width: clamp(280px, 40vw, 320px);
            height: clamp(180px, 25vh, 220px);
            z-index: 1;
        }

        .custom-block.long-press-preview {
            transform: translateY(-6px) scale(1.02);
            box-shadow: 0 20px 56px rgba(2,18,40,0.18);
        }

        .custom-block.long-press-morph {
            transform: translateY(-10px) scale(1.04);
            box-shadow: 0 32px 80px rgba(2,18,40,0.26);
        }

        /* Edit mode styles */
        .custom-blocks.edit-mode {
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }

        .custom-block.edit-mode {
            cursor: move;
            border: 2px dashed var(--accent-2);
            background: var(--block-bg);
            resize: both;
            overflow: hidden; /* Remove scrollbars and adapt content */
            transition: border-color 0.3s ease, background 0.3s ease, transform 0.2s ease;
            z-index: 10; /* Higher z-index in edit mode */
        }
        
        /* Adaptive content styling for edit mode */
        .custom-block.edit-mode .block-content {
            height: calc(100% - 60px); /* Account for header and padding */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding: 12px;
            box-sizing: border-box;
        }
        
        .custom-block.edit-mode .block-header {
            height: 48px;
            min-height: 48px;
            flex-shrink: 0;
            overflow: hidden;
        }
        
        .custom-block.edit-mode .block-header h4 {
            font-size: clamp(14px, 2vw, 18px);
            margin: 0;
            line-height: 1.2;
        }
        
        /* Responsive content elements */
        .custom-block.edit-mode .reminder-list,
        .custom-block.edit-mode .music-controls,
        .custom-block.edit-mode .storage-options,
        .custom-block.edit-mode .weather-info,
        .custom-block.edit-mode .quote-text {
            font-size: clamp(12px, 1.5vw, 16px);
            line-height: 1.3;
            overflow: hidden;
        }
        
        .custom-block.edit-mode .music-controls {
            justify-content: center;
            gap: clamp(8px, 1vw, 16px);
        }
        
        .custom-block.edit-mode .music-btn {
            min-width: clamp(32px, 3vw, 48px);
            height: clamp(32px, 3vw, 48px);
            font-size: clamp(12px, 1.5vw, 18px);
        }

        /* Enhanced responsive behavior for all block content */
        .custom-block .block-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .custom-block .block-content * {
            max-width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        /* Responsive text scaling */
        .custom-block .reminder-item input[type="text"],
        .custom-block .song-info,
        .custom-block .weather-details,
        .custom-block .quote-text,
        .custom-block .link-input {
            font-size: clamp(11px, 1.2vw, 15px);
            line-height: 1.4;
        }
        
        /* Responsive button scaling */
        .custom-block .music-btn,
        .custom-block .link-btn,
        .custom-block .storage-option {
            font-size: clamp(11px, 1.1vw, 14px);
            padding: clamp(6px, 0.8vw, 12px) clamp(10px, 1.2vw, 16px);
            min-height: clamp(28px, 2.5vw, 40px);
        }
        
        /* Responsive icon scaling */
        .custom-block .block-icon {
            width: clamp(32px, 3vw, 44px);
            height: clamp(32px, 3vw, 44px);
            font-size: clamp(18px, 2vw, 26px);
        }
        
        /* Enhanced content adaptation for very small blocks */
        @media (max-width: 480px) {
            .custom-block.edit-mode .block-header {
                margin-bottom: clamp(8px, 2vw, 16px);
                gap: clamp(6px, 1.5vw, 12px);
            }
            
            .custom-block.edit-mode .block-content {
                padding: clamp(8px, 2vw, 12px);
            }
        }

        /* Delete button for blocks */
        .delete-btn {
            position: absolute;
            top: 8px;
            left: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff4757, #ff3742);
            border: none;
            color: white;
            font-size: 14px;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 15;
            display: none; /* Hidden by default */
        }

        .custom-block.edit-mode .delete-btn {
            display: flex; /* Show only in edit mode */
        }

        .custom-block.edit-mode .delete-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(255, 71, 87, 0.4);
        }

        /* Add block trigger */
        .add-block-btn {
            position: fixed;
            bottom: clamp(24px, 5vw, 48px);
            right: clamp(24px, 6vw, 64px);
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color: #fff;
            font-size: 32px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 20px 50px rgba(11, 99, 199, 0.35);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.25s cubic-bezier(.2,.9,.3,1), box-shadow 0.25s ease, opacity 0.2s ease;
            z-index: 1800;
            opacity: 0;
            pointer-events: none;
            transform: scale(0.9);
            visibility: hidden;
        }

        .add-block-btn.visible {
            opacity: 1;
            pointer-events: auto;
            transform: scale(1);
            visibility: visible;
        }

        .add-block-btn:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 28px 62px rgba(11, 99, 199, 0.4);
        }

        .add-block-btn:focus-visible {
            outline: 3px solid rgba(255,255,255,0.7);
            outline-offset: 4px;
        }

        @media (max-width: 680px) {
            .add-block-btn {
                width: 56px;
                height: 56px;
                font-size: 28px;
                bottom: clamp(18px, 6vw, 32px);
                right: clamp(18px, 8vw, 36px);
            }
        }

        /* Block builder modal (used after choosing from the widget library) */
        .block-selector-modal {
            position: fixed;
            inset: 0;
            background: rgba(9, 23, 43, 0.55);
            backdrop-filter: blur(14px);
            display: none;
            align-items: center;
            justify-content: center;
            padding: clamp(20px, 4vw, 48px);
            z-index: 2400;
        }

        .block-selector-modal.show {
            display: flex;
        }

        .builder-panel {
            position: relative;
            width: min(980px, 94vw);
            background: linear-gradient(180deg, rgba(255,255,255,0.97), rgba(235,245,255,0.9));
            border-radius: 28px;
            padding: clamp(26px, 3vw, 36px);
            box-shadow: 0 40px 90px rgba(5,20,45,0.45);
            border: 1px solid rgba(255,255,255,0.75);
            display: flex;
            flex-direction: column;
            gap: clamp(16px, 2vw, 22px);
            max-height: 86vh;
            overflow: hidden;
        }

        .builder-layout {
            display: grid;
            grid-template-columns: minmax(300px, 1fr) minmax(360px, 1.2fr);
            gap: 18px;
            align-items: stretch;
            min-height: 0;
            flex: 1;
            overflow: hidden;
        }

        .builder-left,
        .builder-right {
            min-height: 0;
        }

        .builder-left {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .builder-right {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .builder-right-scroll {
            flex: 1;
            min-height: 0;
            overflow: auto;
            padding-right: 6px;
        }

        .builder-close {
            position: absolute;
            top: 14px;
            right: 16px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: rgba(11,99,199,0.12);
            color: var(--accent-dark);
            font-size: 22px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        .builder-close:hover {
            background: rgba(11,99,199,0.22);
            transform: rotate(90deg);
        }

        .builder-title {
            margin: 0;
            font-size: clamp(22px, 2.4vw, 28px);
            color: var(--accent-dark);
        }

        .builder-subtitle {
            margin: 0;
            font-size: clamp(13px, 1.4vw, 15px);
            color: var(--muted);
        }

        .builder-preview {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 14px;
            border-radius: 20px;
            border: 1px solid rgba(11,99,199,0.14);
            background: linear-gradient(180deg, rgba(255,255,255,0.62), rgba(235,245,255,0.38));
            flex: 1;
            min-height: 0;
        }

        .builder-preview-header {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 12px;
        }

        .builder-preview-title {
            font-size: 13px;
            font-weight: 700;
            color: var(--accent-dark);
        }

        .builder-preview-hint {
            font-size: 11px;
            color: var(--muted);
            text-align: right;
        }

        .builder-preview-stage {
            border-radius: 18px;
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.55);
            background: rgba(255,255,255,0.35);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            overflow: hidden;
            perspective: 900px;
            transform-style: preserve-3d;
            touch-action: none;
            flex: 1;
            min-height: 0;
            display: flex;
        }

        .builder-preview-inner {
            --builder-preview-margin: 14px;
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 260px;
            border-radius: 16px;
            overflow: hidden;
            padding: var(--builder-preview-margin);
            box-sizing: border-box;
            background: rgba(255,255,255,0.12);
        }

        .builder-preview-inner::before {
            content: '';
            position: absolute;
            inset: var(--builder-preview-margin);
            border-radius: 12px;
            background-image:
                radial-gradient(circle, rgba(11,99,199,0.16) 1px, transparent 1px);
            background-size: 18px 18px;
            background-position: 0 0;
            pointer-events: none;
        }

        .builder-preview-block {
            position: absolute;
            cursor: grab;
            pointer-events: auto;
            margin: 0;
            transform-style: preserve-3d;
            will-change: transform;
            transition: transform 160ms ease;
            touch-action: none;
        }

        .builder-preview-block:active {
            cursor: grabbing;
        }

        .builder-preview-resize-handle {
            position: absolute;
            right: 8px;
            bottom: 8px;
            width: 18px;
            height: 18px;
            border-radius: 6px;
            background: rgba(255,255,255,0.55);
            border: 1px solid rgba(11,99,199,0.18);
            box-shadow: 0 10px 24px rgba(11,99,199,0.12);
            pointer-events: auto;
            cursor: nwse-resize;
            z-index: 5;
        }

        .builder-preview-stage:hover .builder-preview-block {
            transition: transform 60ms linear;
        }

        .builder-preview-block.praglass {
            --rx: 0deg;
            --ry: 0deg;
            transform: rotateX(var(--rx)) rotateY(var(--ry));
        }

        @media (prefers-reduced-motion: reduce) {
            .builder-preview-block.praglass {
                transform: none;
            }

            .builder-preview-stage:hover .builder-preview-block {
                transition: none;
            }
        }

        .builder-preview-block * {
            pointer-events: none !important;
        }

        @media (max-width: 900px) {
            .builder-panel {
                width: min(720px, 94vw);
            }

            .builder-layout {
                grid-template-columns: 1fr;
            }

            .builder-right {
                overflow: visible;
                padding-right: 0;
            }
        }

        .builder-type-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .builder-type-btn {
            flex: 1;
            min-width: 140px;
            padding: 12px 16px;
            border-radius: 16px;
            border: 1px solid rgba(11,99,199,0.2);
            background: rgba(255,255,255,0.6);
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 14px;
            color: var(--accent-dark);
            cursor: pointer;
            transition: all 0.25s ease;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
        }

        .builder-type-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 26px rgba(11,99,199,0.2);
        }

        .builder-type-btn:disabled {
            opacity: 0.55;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .builder-type-btn.active {
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color: #fff;
            border-color: var(--accent);
            box-shadow: 0 16px 40px rgba(11,99,199,0.35);
        }

        .builder-type-icon {
            font-size: 18px;
        }

        .builder-type-main {
            font-size: 14px;
        }

        .builder-type-sub {
            font-size: 11px;
            opacity: 0.8;
        }

        #blockBuilderForm {
            display: flex;
            flex-direction: column;
            gap: clamp(18px, 2vw, 24px);
        }

        .builder-section {
            display: none;
            flex-direction: column;
            gap: clamp(12px, 1.6vw, 18px);
        }

        .builder-section.active {
            display: flex;
        }

        .builder-field {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .builder-field label {
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-dark);
        }

        .builder-field input,
        .builder-field select,
        .builder-field input[type="color"] {
            width: 64px;
            height: 40px;
            padding: 0;
            border-radius: 12px;
            border: 2px solid rgba(11,99,199,0.25);
            background: transparent;
            cursor: pointer;
        }

        .builder-field input[type="color"]:hover {
            border-color: rgba(11,99,199,0.45);
        }

        .builder-color-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .builder-color-palette {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }

        .builder-color-dot {
            width: 18px;
            height: 18px;
            border-radius: 999px;
            border: 1px solid rgba(0,0,0,0.08);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
            padding: 0;
            cursor: pointer;
            background-clip: padding-box;
        }

        .builder-color-value {
            font-size: 13px;
            font-weight: 600;
            color: var(--accent-dark);
            letter-spacing: 0.4px;
            text-transform: uppercase;
        }

        .builder-field textarea {
            font-family: 'Montserrat', sans-serif;
            font-size: 14px;
            border-radius: 12px;
            border: 1px solid rgba(11,99,199,0.16);
            padding: 12px;
            background: rgba(255,255,255,0.7);
            color: var(--accent-dark);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .builder-field textarea {
            resize: vertical;
            min-height: 80px;
        }

        .builder-field input:focus,
        .builder-field select:focus,
        .builder-field textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(11,99,199,0.18);
        }

        .builder-checklist-items {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .builder-checklist-item {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            align-items: center;
        }

        .builder-checklist-item input {
            width: 100%;
        }

        .builder-remove-item {
            border: none;
            background: rgba(11,99,199,0.1);
            color: var(--accent-dark);
            width: 36px;
            height: 36px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 18px;
            transition: background 0.2s ease, transform 0.2s ease;
        }

        .builder-remove-item:hover {
            background: rgba(11,99,199,0.22);
            transform: scale(1.05);
        }

        .builder-add-item {
            align-self: flex-start;
            padding: 10px 16px;
            border-radius: 12px;
            border: 1px dashed rgba(11,99,199,0.4);
            background: rgba(255,255,255,0.5);
            color: var(--accent);
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .builder-add-item:hover {
            border-style: solid;
            transform: translateY(-1px);
            box-shadow: 0 12px 26px rgba(11,99,199,0.25);
        }

        .builder-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 10px;
            padding: 14px 0 2px;
            border-top: 1px solid rgba(11,99,199,0.12);
            background: linear-gradient(180deg, rgba(255,255,255,0), rgba(255,255,255,0.92) 40%, rgba(235,245,255,0.92));
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .builder-primary,
        .builder-secondary {
            border-radius: 14px;
            padding: 12px 22px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(.2,.9,.3,1), box-shadow 0.2s ease;
            border: 1px solid transparent;
        }

        .builder-primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color: #fff;
            box-shadow: 0 16px 40px rgba(11,99,199,0.3);
        }

        .builder-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 22px 54px rgba(11,99,199,0.38);
        }

        .builder-secondary {
            background: rgba(255,255,255,0.7);
            color: var(--accent-dark);
            border-color: rgba(11,99,199,0.18);
        }

        .builder-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 30px rgba(11,99,199,0.18);
        }

        @media (max-width: 540px) {
            .builder-actions {
                flex-direction: column;
                align-items: stretch;
            }

            .builder-primary,
            .builder-secondary {
                width: 100%;
                text-align: center;
            }

            .builder-type-grid {
                flex-direction: column;
            }

            .builder-remove-item {
                width: 32px;
                height: 32px;
                border-radius: 10px;
            }
        }

        /* Floating widget library (Apple-style overlay) */
        .block-library-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: flex-end;
            justify-content: stretch;
            padding: 0;
            background: transparent; /* no page dimming */
            backdrop-filter: none;
            z-index: 2300;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.35s ease;
        }

        .block-library-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .block-library-panel {
            width: 100%;
            max-width: 100%;
            min-height: 170px;
            max-height: min(520px, 72vh);
            background: linear-gradient(180deg, rgba(255,255,255,0.74), rgba(230,245,255,0.52));
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            /* Rounded only on the top corners so the bottom edge sits
               flush with the page edge. */
            border-radius: 24px 24px 0 0;
            padding: clamp(20px, 3vw, 26px);
            box-shadow: 0 40px 90px rgba(5,20,45,0.28);
            border: 1px solid rgba(255,255,255,0.55);
            display: flex;
            flex-direction: column;
            gap: 16px;
            /* Tight to the page edges horizontally and to the bottom. */
            margin: 0 clamp(10px, 1.8vw, 22px) 0;
            transform: translateY(60px) scale(0.97);
            opacity: 0;
            transition: transform 0.45s cubic-bezier(.25,.9,.3,1), opacity 0.35s ease, margin 0.35s ease;
        }

        .block-library-overlay.show .block-library-panel {
            transform: translateY(0) scale(1);
            opacity: 1;
        }

        /* While dragging a widget out of the library, keep the library visible
           but slide it further down so it doesn't block the homepage. */
        .block-library-overlay.show.dragging-out .block-library-panel {
            transform: translateY(clamp(240px, 46vh, 520px)) scale(0.98);
        }

        /* Expanded mode intentionally disabled (buggy UX). */

        .block-library-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }

        .block-library-header-main h3 {
            margin: 0 0 4px;
            font-size: clamp(18px, 2.3vw, 22px);
            font-weight: 700;
            color: var(--accent-dark);
        }

        .block-library-header-main p {
            margin: 0;
            font-size: 13px;
            color: var(--muted);
        }

        .block-library-close {
            width: 32px;
            height: 32px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.65);
            background: linear-gradient(180deg, rgba(255,255,255,0.72), rgba(230,245,255,0.45));
            color: var(--accent-dark);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 10px 26px rgba(11,99,199,0.18);
            transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
        }

        .block-library-close:hover {
            transform: rotate(90deg) scale(1.05);
            background: linear-gradient(180deg, rgba(255,255,255,0.86), rgba(230,245,255,0.58));
            box-shadow: 0 14px 34px rgba(11,99,199,0.22);
        }

        .block-library-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 16px;
            padding-top: 10px;
            overflow-y: hidden;
        }

        .block-library-overlay.expanded .block-library-grid {
            overflow-y: auto;
        }

        .library-block {
            position: relative;
            border-radius: 22px;
            padding: 16px 18px;
            background: radial-gradient(circle at top left, rgba(255,255,255,0.36), rgba(255,255,255,0.05)) ,
                        linear-gradient(135deg, var(--lib-color, #2563eb), var(--lib-color-soft, #4f46e5));
            box-shadow: none;
            border: 1px solid rgba(255,255,255,0.28);
            cursor: pointer;
            overflow: hidden;
            color: #f9fafb;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-height: 140px;
            transition: transform 0.22s cubic-bezier(.25,.9,.3,1), border-color 0.22s ease;
        }

        .library-block.tall {
            min-height: 190px;
        }
        
        
        .library-block::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at top left, rgba(255,255,255,0.45), transparent 55%);
            opacity: 0.85;
            mix-blend-mode: screen;
            pointer-events: none;
        }

        .library-block-inner {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .library-block-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .library-block-title {
            font-size: 16px;
            font-weight: 700;
        }

        .library-block-chip {
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(15,23,42,0.2);
            font-size: 11px;
            font-weight: 600;
            backdrop-filter: blur(12px);
        }

        .library-block-preview-lines {
            display: flex;
            flex-direction: column;
            gap: 4px;
            opacity: 0.92;
        }

        .library-block-line {
            height: 6px;
            border-radius: 999px;
            background: rgba(15,23,42,0.2);
        }

        .library-block-line.short {
            width: 60%;
        }

        .library-block-line.medium {
            width: 78%;
        }

        .library-block-line.tiny {
            width: 32%;
        }

        .library-block:hover {
            transform: translateY(-6px) scale(1.02);
            box-shadow: none;
            border-color: rgba(255,255,255,0.6);
        }

        @media (max-width: 720px) {
            .block-library-panel {
                max-height: 78vh;
                border-radius: 28px;
            }

            .block-library-grid {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            }
        }

        /* New Block Types Styles */
        .reminder-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            padding: 6px 0;
        }

        .reminder-item input[type="text"] {
            flex: 1;
            background: rgba(255,255,255,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--accent-dark);
        }

        .reminder-item input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-2);
            background: rgba(255,255,255,0.4);
        }

        .music-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 12px;
        }

        .music-platform-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(11,99,199,0.12);
            color: var(--accent-dark);
            font-size: 12px;
            font-weight: 600;
        }

        .music-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(255,255,255,0.4), rgba(255,255,255,0.2));
            border: 1px solid rgba(255,255,255,0.3);
            color: var(--accent);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .music-btn:hover {
            transform: scale(1.1);
            background: linear-gradient(135deg, rgba(255,255,255,0.6), rgba(255,255,255,0.4));
        }

        .music-btn.play {
            width: 50px;
            height: 50px;
            font-size: 20px;
        }

        .song-info {
            text-align: center;
            font-size: 12px;
            color: var(--accent-dark);
        }

        .weather-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .weather-icon {
            font-size: 32px;
            line-height: 1;
        }

        .weather-details {
            flex: 1;
        }

        .weather-temp {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 4px;
        }

        .weather-desc {
            font-size: 12px;
            color: var(--muted);
        }

        .quote-text {
            font-size: 14px;
            font-style: italic;
            color: var(--accent-dark);
            line-height: 1.4;
            margin-bottom: 10px;
            text-align: center;
        }

        .quote-author {
            font-size: 12px;
            color: var(--muted);
            text-align: right;
        }

        .link-input {
            width: 100%;
            background: rgba(255,255,255,0.3);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 14px;
            color: var(--accent-dark);
            margin-bottom: 10px;
        }

        .link-input:focus {
            outline: none;
            border-color: var(--accent-2);
            background: rgba(255,255,255,0.4);
        }

        .link-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .link-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(11, 99, 199, 0.3);
        }

        .link-btn.disabled {
            background: rgba(255,255,255,0.6);
            color: var(--muted);
            cursor: not-allowed;
            box-shadow: none;
        }

        .link-btn.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .storage-options {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .storage-option {
            flex: 1;
            padding: 12px;
            background: rgba(255,255,255,0.3);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .storage-option.active {
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color: white;
            border-color: var(--accent);
        }

        .storage-link {
            display: block;
            padding: 12px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            text-decoration: none;
            color: var(--accent-dark);
            font-size: 14px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .storage-link:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .checklist-progress {
            margin-top: 10px;
            font-size: 12px;
            font-weight: 600;
            color: var(--muted);
            text-align: right;
        }

        /* Responsive adjustments for custom blocks */
        @media (max-width: 768px) {
            .custom-blocks {
                grid-template-columns: 1fr;
            }
            
            .custom-block {
                min-width: 100%;
                resize: vertical;
            }
            
            .custom-block.edit-mode {
                max-width: calc(100vw - 40px); /* Adjust for mobile */
            }
            
            .calendar-preview {
                flex-direction: column;
                gap: 12px;
            }
            
            .calendar-date {
                align-self: flex-start;
            }

            .section-header {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }

            .section-actions {
                align-self: flex-end;
            }
        }

        @media (max-width: 480px) {
            .custom-block {
                padding: 16px;
                min-width: 100%;
                resize: none;
            }
            
            .custom-block.edit-mode {
                max-width: calc(100vw - 20px);
                min-width: 250px;
            }
            
            .section-title {
                font-size: 18px;
            }

            .section-header {
                padding: 0 4px;
            }

            .custom-block.edit-mode::after {
                font-size: 14px;
                top: 6px;
                right: 6px;
            }
        }

            
        /* --- Profile Dropdown --- */
        .profile-container {
            position: relative;
        }

        .profile-icon {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            transition: 0.2s;
        }

        .profile-icon:hover {
            transform: scale(1.07);
        }

        .profile-dropdown {
            position: absolute;
            right: 0;
            top: 58px;
            width: 220px;
            background: #fff;
            border-radius: 12px;
            padding: 10px 0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.22s ease;
            z-index: 999;
        }

        .profile-dropdown.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .dropdown-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
        }

        .dropdown-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .profile-dropdown ul {
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .profile-dropdown li a {
            display: block;
            padding: 12px 18px;
            font-size: 15px;
            color: #333;
            text-decoration: none;
            transition: 0.2s;
        }

        .profile-dropdown li a:hover {
            background: #f5f5f5;
            transform: translateX(3px);
        }
        /* Icon inside dropdown list */
        .profile-dropdown .icon {
            width: 18px;
            height: 18px;
            margin-right: 10px;
            opacity: 0.85;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .profile-dropdown i.icon{font-size:16px;line-height:1}
        .profile-dropdown img.icon{object-fit:contain;display:block}
        
        /* Arrow that appears on hover */
        .profile-dropdown .arrow {
            margin-left: auto;
            opacity: 0;
            transform: translateX(-6px);
            transition: 0.25s ease;
            font-size: 13px;
            color: #666;
        }
        
        /* Hover effect: slide arrow in */
        .profile-dropdown ul li a:hover .arrow {
            opacity: 1;
            transform: translateX(0);
        }
        
        /* Slight move to the right when hovering */
        .profile-dropdown ul li a:hover {
            background: #f5f5f5;
            transform: translateX(4px);
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .custom-block.edit-mode {
                touch-action: none;
            }
            
            .custom-block.edit-mode::before {
                width: 30px;
                height: 30px;
            }
        }

        /* Settings modal (Apple-like) */
        .settings-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.25);
            backdrop-filter: blur(18px);
            z-index: 999;
        }
        .settings-overlay.hidden { display: none; }
        .settings-card {
            width: 100%;
            max-width: 420px;
            background: rgba(255,255,255,0.92);
            border-radius: 32px;
            padding: 22px 22px 18px;
            box-shadow: 0 24px 80px rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.7);
        }
        .settings-header {
            display:flex;
            align-items:flex-start;
            justify-content:space-between;
            gap:16px;
            margin-bottom:14px;
        }
        .settings-header h3 {
            margin:0;
            font-size:18px;
            font-weight:700;
            color:var(--accent-dark);
        }
        .settings-header p {
            margin:4px 0 0;
            font-size:12px;
            color:var(--muted);
        }
        .settings-close {
            width:28px;
            height:28px;
            border-radius:999px;
            border:none;
            background:rgba(240,240,245,0.9);
            display:flex;
            align-items:center;
            justify-content:center;
            cursor:pointer;
            font-size:14px;
        }
        .settings-section {
            padding:10px 0 6px;
            border-top:1px solid rgba(0,0,0,0.04);
        }
        .settings-section:first-of-type { border-top:none; }
        .settings-section h4 {
            margin:2px 0 8px;
            font-size:13px;
            font-weight:600;
            color:var(--accent-dark);
        }
        .settings-label {
            display:block;
            font-size:11px;
            font-weight:600;
            color:var(--muted);
            margin-bottom:6px;
        }
        .color-row {
            display:flex;
            align-items:center;
            gap:10px;
        }
        .color-input {
            width:42px;
            height:26px;
            border-radius:10px;
            border:1px solid rgba(0,0,0,0.08);
            padding:0;
            background:white;
        }
        .color-preview-label {
            font-size:11px;
            color:var(--muted);
        }
        .toggle-row {
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap:10px;
            padding:4px 0;
        }
        .toggle-title { font-size:13px; font-weight:500; color:var(--accent-dark); }
        .toggle-sub { font-size:11px; color:var(--muted); }

        .switch { position:relative; display:inline-block; width:44px; height:24px; }
        .switch input { opacity:0; width:0; height:0; }
        .slider {
            position:absolute; cursor:pointer; inset:0;
            background:#d1d5db; border-radius:999px;
            transition:0.25s ease;
        }
        .slider:before {
            position:absolute; content:""; height:20px; width:20px;
            left:2px; top:2px; border-radius:999px;
            background:white; box-shadow:0 1px 4px rgba(0,0,0,0.2);
            transition:0.25s ease;
        }
        .switch input:checked + .slider { background:#34c759; }
        .switch input:checked + .slider:before { transform:translateX(20px); }

        .settings-footer {
            display:flex;
            justify-content:flex-end;
            gap:8px;
            padding-top:10px;
            margin-top:4px;
            border-top:1px solid rgba(0,0,0,0.04);
        }
        .btn-secondary,
        .btn-primary {
            border-radius:999px;
            padding:7px 16px;
            font-size:13px;
            font-weight:500;
            border:none;
            cursor:pointer;
        }
        .btn-secondary { background:#f2f2f7; color:#111827; }
        .btn-primary { background:#007aff; color:#fff; box-shadow:0 8px 18px rgba(0,122,255,0.35); }

        /* Simple dark mode override
           Dark gradient that smoothly fades into solid dark background
           without visible bands on long pages. */
        body.dark-mode {
            --bg: #020617;
            --accent-dark: #e5e7eb;
            --muted: rgba(226,232,240,0.68);
            --soft: rgba(2,6,23,0.96);
            --glass-1: rgba(15,23,42,0.72);
            --glass-2: rgba(2,6,23,0.44);
            color:#e5e7eb;
            background:linear-gradient(
                180deg,
                rgba(15,23,42,0.96) 0,
                rgba(15,23,42,0.96) 360px,
                #020617 840px,
                #020617 100%
            );
        }
        body.dark-mode .frame { color:#e5e7eb; }
        body.dark-mode .card { background:linear-gradient(180deg, rgba(30,41,59,0.88), rgba(15,23,42,0.9)); border-color:rgba(148,163,184,0.5); }
        body.dark-mode .pill { background:linear-gradient(90deg, rgba(15,23,42,0.9), rgba(30,64,175,0.75)); border-color:rgba(148,163,184,0.5); }
        body.dark-mode .section-title { color:#e5e7eb; }

        /* Dark mode: settings modal */
        body.dark-mode .settings-overlay { background: rgba(0,0,0,0.55); }
        body.dark-mode .settings-card {
            background: linear-gradient(180deg, rgba(15,23,42,0.96), rgba(2,6,23,0.92));
            border-color: rgba(148,163,184,0.24);
            box-shadow: 0 28px 90px rgba(0,0,0,0.55);
        }
        body.dark-mode .settings-close {
            background: rgba(148,163,184,0.14);
            color: #e5e7eb;
        }
        body.dark-mode .settings-section { border-top-color: rgba(148,163,184,0.14); }
        body.dark-mode .settings-footer { border-top-color: rgba(148,163,184,0.14); }
        body.dark-mode .color-input {
            background: rgba(15,23,42,0.9);
            border-color: rgba(148,163,184,0.24);
        }
        body.dark-mode .btn-secondary { background: rgba(30,41,59,0.72); color:#e5e7eb; }
        body.dark-mode .btn-primary { box-shadow: 0 10px 26px rgba(37,99,235,0.6); }

        /* Dark mode: profile dropdown */
        body.dark-mode .profile-dropdown {
            background: rgba(15,23,42,0.92);
            border: 1px solid rgba(148,163,184,0.22);
            box-shadow: 0 18px 50px rgba(0,0,0,0.55);
        }
        body.dark-mode .dropdown-header { border-bottom-color: rgba(148,163,184,0.16); }
        body.dark-mode .profile-dropdown li a { color: rgba(226,232,240,0.92); }
        body.dark-mode .profile-dropdown .arrow { color: rgba(226,232,240,0.62); }
        body.dark-mode .profile-dropdown li a:hover { background: rgba(148,163,184,0.12); }

        /* Dark mode: clipboard capsule panel */
        body.dark-mode .home-clipboard-panel {
            background: linear-gradient(200deg, rgba(15,23,42,0.74), rgba(2,6,23,0.64));
            border-color: rgba(148,163,184,0.22);
            box-shadow: 0 44px 90px rgba(0,0,0,0.55);
        }
        body.dark-mode .home-clipboard-panel::before {
            background: linear-gradient(200deg, rgba(148,163,184,0.18), rgba(2,6,23,0.06));
        }
        body.dark-mode .home-clipboard-item {
            background: rgba(30,41,59,0.48);
            border-color: rgba(148,163,184,0.18);
            box-shadow: 0 18px 42px rgba(0,0,0,0.35);
        }
        body.dark-mode .home-clipboard-preview {
            background: rgba(2,6,23,0.26);
            border-color: rgba(148,163,184,0.22);
            color: rgba(226,232,240,0.9);
        }
        body.dark-mode .home-clipboard-item-title,
        body.dark-mode .home-clipboard-snippet { color: rgba(226,232,240,0.92); }
        body.dark-mode .home-clipboard-item-details { color: rgba(226,232,240,0.62); }
        body.dark-mode .home-clipboard.open .home-clipboard-panel::-webkit-scrollbar-thumb { background: rgba(148,163,184,0.28); }

        /* Dark mode: block builder popup + block library */
        body.dark-mode .block-selector-modal {
            background: rgba(0,0,0,0.62);
        }
        body.dark-mode .builder-panel {
            background: linear-gradient(180deg, rgba(15,23,42,0.96), rgba(2,6,23,0.92));
            border-color: rgba(148,163,184,0.24);
            box-shadow: 0 40px 100px rgba(0,0,0,0.6);
        }
        body.dark-mode .builder-title { color: rgba(226,232,240,0.96); }
        body.dark-mode .builder-subtitle { color: rgba(226,232,240,0.66); }
        body.dark-mode .builder-close {
            background: rgba(148,163,184,0.14);
            color: rgba(226,232,240,0.9);
        }
        body.dark-mode .builder-preview {
            background: linear-gradient(180deg, rgba(30,41,59,0.60), rgba(15,23,42,0.30));
            border-color: rgba(148,163,184,0.20);
        }
        body.dark-mode .builder-preview-title { color: rgba(226,232,240,0.92); }
        body.dark-mode .builder-preview-hint { color: rgba(226,232,240,0.56); }
        body.dark-mode .builder-preview-stage {
            background: rgba(2,6,23,0.26);
            border-color: rgba(148,163,184,0.18);
        }
        body.dark-mode .builder-preview-inner { background: rgba(2,6,23,0.20); }
        body.dark-mode .builder-preview-inner::before {
            background-image: radial-gradient(circle, rgba(148,163,184,0.22) 1px, transparent 1px);
        }
        body.dark-mode .builder-type-btn {
            background: rgba(15,23,42,0.62);
            border-color: rgba(148,163,184,0.22);
            color: rgba(226,232,240,0.92);
        }
        body.dark-mode .builder-type-btn:hover { box-shadow: 0 10px 26px rgba(0,0,0,0.35); }
        body.dark-mode .builder-field textarea {
            background: rgba(15,23,42,0.72);
            border-color: rgba(148,163,184,0.18);
            color: rgba(226,232,240,0.92);
        }
        body.dark-mode .builder-field input,
        body.dark-mode .builder-field select {
            border-color: rgba(148,163,184,0.22);
        }
        body.dark-mode .builder-actions {
            border-top-color: rgba(148,163,184,0.14);
            background: linear-gradient(180deg, rgba(2,6,23,0), rgba(2,6,23,0.86) 35%, rgba(15,23,42,0.92));
        }
        body.dark-mode .builder-secondary {
            background: rgba(30,41,59,0.72);
            color: rgba(226,232,240,0.92);
            border-color: rgba(148,163,184,0.18);
        }

        body.dark-mode .block-library-panel {
            background: linear-gradient(180deg, rgba(15,23,42,0.88), rgba(2,6,23,0.78));
            border-color: rgba(148,163,184,0.20);
            box-shadow: 0 40px 100px rgba(0,0,0,0.55);
        }
        body.dark-mode .block-library-header-main h3 { color: rgba(226,232,240,0.92); }
        body.dark-mode .block-library-header-main p { color: rgba(226,232,240,0.58); }
        body.dark-mode .block-library-close {
            border-color: rgba(148,163,184,0.24);
            background: rgba(30,41,59,0.72);
            color: rgba(226,232,240,0.9);
            box-shadow: 0 10px 26px rgba(0,0,0,0.35);
        }
    </style>
    <!-- Supabase and auth.js are already included in the page head; avoid duplicates here -->
 </head>
 <body>
     <div class="frame">
         <div class="topbar">
             <div class="icon-btn" id="settingsBtn" title="Settings">⚙️</div>

             <div class="center-pill">
                 <div class="home-clipboard" id="homeClipboard">
                     <div class="pill home-capsule" id="homeClipboardCapsule" role="button" tabindex="0" aria-expanded="false" aria-controls="homeClipboardPanel">
                         <span id="date">10 Oct 2025</span>
                         <span id="time">10:48</span>
                         <span class="home-clipboard-count" id="homeClipboardCount" aria-hidden="true">0</span>
                     </div>
                     <div class="home-clipboard-panel" id="homeClipboardPanel" aria-hidden="true">
                         <p class="home-clipboard-empty" id="homeClipboardEmpty">Плъзни файлове върху капсулата, за да ги запазиш временно.</p>
                         <ul class="home-clipboard-list" id="homeClipboardList"></ul>
                     </div>
                 </div>
             </div>

             <div class="profile-container">
                     <img src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22128%22%20height%3D%22128%22%20viewBox%3D%220%200%20128%20128%22%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22g%22%20x1%3D%220%22%20x2%3D%221%22%20y1%3D%220%22%20y2%3D%221%22%3E%3Cstop%20stop-color%3D%22%23009fe6%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%230b63c7%22%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Ccircle%20cx%3D%2264%22%20cy%3D%2264%22%20r%3D%2264%22%20fill%3D%22url%28%23g%29%22%2F%3E%3Ccircle%20cx%3D%2264%22%20cy%3D%2250%22%20r%3D%2222%22%20fill%3D%22rgba%28255%2C255%2C255%2C0.92%29%22%2F%3E%3Cpath%20d%3D%22M24%20118c9-20%2027-32%2040-32s31%2012%2040%2032%22%20fill%3D%22rgba%28255%2C255%2C255%2C0.92%29%22%2F%3E%3C%2Fsvg%3E" id="profileBtn" class="profile-icon" alt="Profile">

                <div class="profile-dropdown" id="profileDropdown">

                    <div class="dropdown-header">
                        <img src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22128%22%20height%3D%22128%22%20viewBox%3D%220%200%20128%20128%22%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22g%22%20x1%3D%220%22%20x2%3D%221%22%20y1%3D%220%22%20y2%3D%221%22%3E%3Cstop%20stop-color%3D%22%23009fe6%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%230b63c7%22%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Ccircle%20cx%3D%2264%22%20cy%3D%2264%22%20r%3D%2264%22%20fill%3D%22url%28%23g%29%22%2F%3E%3Ccircle%20cx%3D%2264%22%20cy%3D%2250%22%20r%3D%2222%22%20fill%3D%22rgba%28255%2C255%2C255%2C0.92%29%22%2F%3E%3Cpath%20d%3D%22M24%20118c9-20%2027-32%2040-32s31%2012%2040%2032%22%20fill%3D%22rgba%28255%2C255%2C255%2C0.92%29%22%2F%3E%3C%2Fsvg%3E" class="dropdown-avatar" alt="Avatar">
                        <h4>Your Name</h4>
                    </div>

                    <ul>
                        <li>
                            <a href="account.html">
                                <i class="fa-solid fa-user-pen icon" aria-hidden="true"></i>
                                <span data-i18n="menu.editProfile">Редактирай профил</span>
                                <span class="arrow">▶</span>
                            </a>
                        </li>

                        <li>
                            <a href="account.html">
                                <i class="fa-regular fa-user icon" aria-hidden="true"></i>
                                <span data-i18n="menu.yourAccount">Твоят акаунт</span>
                                <span class="arrow">▶</span>
                            </a>
                        </li>

                        <li>
                            <a href="log-in.html">
                                <i class="fa-solid fa-right-from-bracket icon" aria-hidden="true"></i>
                                <span data-i18n="menu.logout">Изход</span>
                                <span class="arrow">▶</span>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
         </div>

           <div class="cards-wrap">
               <div class="cards" id="recentCards">
                 <div class="card add" role="button" aria-label="Добави нова колекция" onclick="location.href='Flashcardcreate.html'">
                     <div class="card-content" style="text-align:center">
                         <div class="plus">＋</div>
                         <div class="label">Нова</div>
                     </div>
                 </div>

                 <div class="card">
                     <div class="card-content" style="text-align:center">
                         <div style="font-size:14px;font-weight:800">Последно използвани</div>
                         <div class="label">карта</div>
                     </div>
                 </div>

                 <div class="card">
                     <div class="card-content" style="text-align:center">
                         <div style="font-size:14px;font-weight:800">Последно използвани</div>
                         <div class="label">карта</div>
                     </div>
                 </div>

                 <!-- extra placeholders to show adaptive flow -->
                 <div class="card">
                     <div class="card-content" style="text-align:center;color:var(--muted)">Още</div>
                 </div>
              </div>
          </div>

          <!-- Custom Blocks Section -->
          <div class="custom-blocks-wrap">
              <div class="section-header">
                  <h3 class="section-title">Персонализирани блокове</h3>
                  <div class="section-actions">
                      <button class="edit-btn" id="removeAllBlocksBtn" type="button" disabled>
                          <span>Премахни всички</span>
                      </button>
                      <button class="edit-btn" id="editBlocksBtn" type="button">
                          <span>Редактиране</span>
                      </button>
                  </div>
              </div>
              <div class="custom-blocks" id="customBlocks">
                  <div class="custom-block calendar-block" role="button" aria-label="Календар" data-block-id="calendar" data-default-block="true">
                      <button class="delete-btn" title="Изтрий блок">×</button>
                      <div class="block-header">
                          <div class="block-icon">📅</div>
                          <h4>Календар</h4>
                      </div>
                      <div class="block-content">
                          <div class="calendar-preview">
                              <div class="calendar-date">
                                  <span class="day" id="calendar-day">09</span>
                                  <span class="month">Окт</span>
                              </div>
                              <div class="calendar-events">
                                  <div class="event">📚 Математика - 14:00</div>
                                  <div class="event">📖 История - 16:30</div>
                              </div>
                          </div>
                      </div>
                  </div>

                  <div class="custom-block homework-block" role="button" aria-label="Домашни" data-block-id="homework" data-default-block="true">
                      <button class="delete-btn" title="Изтрий блок">×</button>
                      <div class="block-header">
                          <div class="block-icon">📝</div>
                          <h4>Домашни</h4>
                      </div>
                      <div class="block-content">
                          <div class="homework-list">
                              <div class="homework-item">
                                  <input type="checkbox" id="hw1" checked>
                                  <label for="hw1">Физика - упражнения</label>
                              </div>
                              <div class="homework-item">
                                  <input type="checkbox" id="hw2">
                                  <label for="hw2">Химия - лабораторен отчет</label>
                              </div>
                              <div class="homework-item">
                                  <input type="checkbox" id="hw3">
                                  <label for="hw3">Английски - есе</label>
                              </div>
                          </div>
                          <div class="homework-progress">
                              <span>1 от 3 завършени</span>
                          </div>
                      </div>
                  </div>

                  <div class="custom-block curriculum-block" role="button" aria-label="Учебна програма" data-block-id="curriculum" data-default-block="true">
                      <button class="delete-btn" title="Изтрий блок">×</button>
                      <div class="block-header">
                          <div class="block-icon">🎓</div>
                          <h4>Учебна програма</h4>
                      </div>
                      <div class="block-content">
                          <div class="curriculum-overview">
                              <div class="subject-progress">
                                  <div class="subject">
                                      <span class="subject-name">Математика</span>
                                      <div class="progress-bar">
                                          <div class="progress-fill" style="width: 75%"></div>
                                      </div>
                                  </div>
                                  <div class="subject">
                                      <span class="subject-name">Физика</span>
                                      <div class="progress-bar">
                                          <div class="progress-fill" style="width: 60%"></div>
                                      </div>
                                  </div>
                                  <div class="subject">
                                      <span class="subject-name">Химия</span>
                                      <div class="progress-bar">
                                          <div class="progress-fill" style="width: 45%"></div>
                                      </div>
                                  </div>
                              </div>
                          </div>
                      </div>
                  </div>
              </div>
          </div>
      </div>

      <!-- Add Block Button -->
      <button class="add-block-btn" id="addBlockBtn">+</button>

      <!-- Floating Block Library (Apple-style widget gallery) -->
      <div class="block-library-overlay" id="blockLibrary">
          <div class="block-library-panel" id="blockLibraryPanel" role="dialog" aria-modal="true" aria-labelledby="blockLibraryTitle">
              <div class="block-library-header">
                  <div class="block-library-header-main">
                      <h3 id="blockLibraryTitle">Библиотека с блокове</h3>
                      <p></p>
                  </div>
                  <button type="button" class="block-library-close" id="blockLibraryClose" aria-label="Затвори библиотеката">×</button>
              </div>
              <div class="block-library-grid" id="blockLibraryGrid"></div>
          </div>
      </div>

      <!-- Block Selector Modal -->
      <div class="block-selector-modal" id="blockBuilder">
          <div class="builder-panel" role="dialog" aria-modal="true" aria-labelledby="builderTitle">
              <button class="builder-close" type="button" id="builderCloseBtn" aria-label="Затвори">×</button>
              <h3 class="builder-title" id="builderTitle">Добави персонализиран блок</h3>
              <p class="builder-subtitle">Изберете тип и настройте съдържанието преди да го закачите на таблото.</p>
              <div class="builder-layout">
                  <div class="builder-left">
                      <div class="builder-preview" aria-label="Преглед на блока">
                          <div class="builder-preview-header">
                              <span class="builder-preview-title">Преглед</span>
                              <span class="builder-preview-hint">Промените се прилагат след „Запази“</span>
                          </div>
                          <div class="builder-preview-stage">
                              <div class="builder-preview-inner" id="builderLivePreviewInner"></div>
                          </div>
                      </div>
                  </div>
                  <div class="builder-right">
                      <div class="builder-right-scroll">
                          <div class="builder-type-grid">
                              <button type="button" class="builder-type-btn active" data-builder-type="music">
                                  <span class="builder-type-icon">🎵</span>
                                  <span class="builder-type-main">Музика</span>
                                  <span class="builder-type-sub">Spotify, Apple Music, YouTube</span>
                              </button>
                              <button type="button" class="builder-type-btn" data-builder-type="weather">
                                  <span class="builder-type-icon">🌤️</span>
                                  <span class="builder-type-main">Време</span>
                                  <span class="builder-type-sub">Автоматична локация и прогноза</span>
                              </button>
                              <button type="button" class="builder-type-btn" data-builder-type="checklist">
                                  <span class="builder-type-icon">✅</span>
                                  <span class="builder-type-main">Чеклист</span>
                                  <span class="builder-type-sub">AI идеи за задачи</span>
                              </button>
                              <button type="button" class="builder-type-btn" data-builder-type="calendar">
                                  <span class="builder-type-icon">📅</span>
                                  <span class="builder-type-main">Календар</span>
                                  <span class="builder-type-sub">Google Calendar връзка</span>
                              </button>
                              <button type="button" class="builder-type-btn" data-builder-type="reminder">
                                  <span class="builder-type-icon">📝</span>
                                  <span class="builder-type-main">Напомняния</span>
                                  <span class="builder-type-sub">Малки бързи бележки</span>
                              </button>
                              <button type="button" class="builder-type-btn" data-builder-type="quote">
                                  <span class="builder-type-icon">💭</span>
                                  <span class="builder-type-main">Мотивация</span>
                                  <span class="builder-type-sub">Цитати и афирмации</span>
                              </button>
                              <button type="button" class="builder-type-btn" data-builder-type="link">
                                  <span class="builder-type-icon">🔗</span>
                                  <span class="builder-type-main">Бърз линк</span>
                                  <span class="builder-type-sub">Любим сайт или ресурс</span>
                              </button>
                          </div>
                          <form id="blockBuilderForm">
                              <div class="builder-form-fields">
                  <div class="builder-field" data-builder-shared>
                      <label for="blockColor">Цвят на блока</label>
                      <div class="builder-color-row">
                          <input type="color" id="blockColor" name="blockColor" value="#4d7cff">
                          <span class="builder-color-value" id="builderColorValue">#4D7CFF</span>
                      </div>
                  </div>
                  <div class="builder-section active" data-builder-section="music">
                      <div class="builder-field">
                          <label for="musicTitle">Заглавие</label>
                          <input type="text" id="musicTitle" name="musicTitle" value="Музика" required>
                      </div>
                      <div class="builder-field">
                          <label for="musicPlatform">Платформа</label>
                          <select id="musicPlatform" name="musicPlatform">
                              <option value="spotify">Spotify</option>
                              <option value="apple">Apple Music</option>
                              <option value="youtube">YouTube Music</option>
                              <option value="custom">Друго</option>
                          </select>
                      </div>
                      <div class="builder-field">
                          <label for="musicUrl">Линк към плейлист или албум</label>
                          <input type="url" id="musicUrl" name="musicUrl" placeholder="https://...">
                      </div>
                      <div class="builder-field">
                          <label for="musicNote">Описание (по избор)</label>
                          <textarea id="musicNote" name="musicNote" rows="2" placeholder="Добави кратко описание или настроение"></textarea>
                      </div>
                  </div>

                  <div class="builder-section" data-builder-section="weather" hidden>
                      <div class="builder-field">
                          <label for="weatherTitle">Заглавие</label>
                          <input type="text" id="weatherTitle" name="weatherTitle" value="Време" required>
                      </div>
                      <div class="builder-field">
                          <label for="weatherLocation">Локация</label>
                          <input type="text" id="weatherLocation" name="weatherLocation" placeholder="София, България" required>
                      </div>
                      <div class="builder-field">
                          <label for="weatherUnits">Единици</label>
                          <select id="weatherUnits" name="weatherUnits">
                              <option value="metric">Целзий (°C)</option>
                              <option value="imperial">Фаренхайт (°F)</option>
                          </select>
                      </div>
                  </div>

                  <div class="builder-section" data-builder-section="checklist" hidden>
                      <div class="builder-field">
                          <label for="checklistTitle">Заглавие</label>
                          <input type="text" id="checklistTitle" name="checklistTitle" value="Чеклист" required>
                      </div>
                      <div class="builder-field checklist-ai-row">
                          <span class="settings-label">AI помощ за задачи</span>
                          <label class="switch">
                              <input type="checkbox" id="checklistAiToggle" checked>
                              <span class="slider"></span>
                          </label>
                      </div>
                      <div class="builder-field">
                          <label>Елементи</label>
                          <div class="builder-checklist-items" id="builderChecklistItems"></div>
                          <button type="button" class="builder-add-item" id="builderAddChecklistItem">+ Добави елемент</button>
                      </div>
                  </div>

                  <div class="builder-section" data-builder-section="calendar" hidden>
                      <div class="builder-field">
                          <label for="calendarTitle">Заглавие</label>
                          <input type="text" id="calendarTitle" name="calendarTitle" value="Календар" required>
                      </div>
                      <div class="builder-field">
                          <label for="calendarMode">Режим</label>
                          <select id="calendarMode" name="calendarMode">
                              <option value="link">Отваря Google Calendar</option>
                              <option value="embed">Вграден изглед (публичен линк)</option>
                          </select>
                      </div>
                      <div class="builder-field">
                          <label for="calendarUrl">Google Calendar линк (по избор)</label>
                          <input type="url" id="calendarUrl" name="calendarUrl" placeholder="https://calendar.google.com/calendar/embed?...">
                      </div>
                  </div>

                              </div>
                          </form>
                      </div>

                      <div class="builder-actions">
                          <button type="button" class="builder-secondary" id="builderCancelBtn">Отказ</button>
                          <button type="submit" form="blockBuilderForm" class="builder-primary" id="builderSaveBtn">Запази</button>
                      </div>
                  </div>
              </div>
          </div>
      </div>

      <!-- Settings Modal -->
      <div id="settingsModal" class="settings-overlay hidden">
          <div class="settings-card">
              <div class="settings-header">
                  <div>
                      <h3>Настройки</h3>
                      <p>Персонализирай изгледа и звука на StudySpace.</p>
                  </div>
                  <button type="button" class="settings-close" id="settingsCloseBtn">✕</button>
              </div>

              <div class="settings-section">
                  <h4>Цветове</h4>
                  <label class="settings-label" for="accentColor">Основен цвят (градиент &amp; акцент)</label>
                  <div class="color-row">
                      <input type="color" id="accentColor" class="color-input">
                      <span class="color-preview-label">Избери цвят за горния градиент и акцентите.</span>
                  </div>
              </div>

              <div class="settings-section">
                  <h4>Режим</h4>
                  <div class="toggle-row">
                      <div>
                          <div class="toggle-title">Тъмен режим</div>
                          <div class="toggle-sub">По-мек контраст за вечерно учене.</div>
                      </div>
                      <label class="switch">
                          <input type="checkbox" id="darkModeToggle">
                          <span class="slider"></span>
                      </label>
                  </div>
              </div>

              <div class="settings-section">
                  <h4>Звук</h4>
                  <div class="toggle-row">
                      <div>
                          <div class="toggle-title">Звуци от интерфейса</div>
                          <div class="toggle-sub">Кликове и основни звуци.</div>
                      </div>
                      <label class="switch">
                          <input type="checkbox" id="soundToggle">
                          <span class="slider"></span>
                      </label>
                  </div>
                  <div class="toggle-row">
                      <div>
                          <div class="toggle-title">SFX ефекти</div>
                          <div class="toggle-sub">По-анимирани звукови ефекти.</div>
                      </div>
                      <label class="switch">
                          <input type="checkbox" id="sfxToggle">
                          <span class="slider"></span>
                      </label>
                  </div>
              </div>

              <div class="settings-footer">
                  <button type="button" class="btn-secondary" id="settingsCancelBtn">Отказ</button>
                  <button type="button" class="btn-primary" id="settingsSaveBtn">Запази</button>
              </div>
          </div>
      </div>

      <script>
        // Account Dropdown Toggle
        const profileBtn = document.getElementById("profileBtn");
        const profileDropdown = document.getElementById("profileDropdown");
    
        profileBtn.addEventListener("click", () => {
            profileDropdown.classList.toggle("show");
        });
    
        // Close dropdown on outside click
        document.addEventListener("click", (e) => {
            const pBtn = document.querySelector('.profile-icon');
            const pDrop = document.querySelector('.profile-dropdown');
            if (pBtn && pDrop && !pBtn.contains(e.target) && !pDrop.contains(e.target)) {
                pDrop.classList.remove("show");
                pDrop.classList.remove("active");
            }
        });

        (function(){
            const LANG_KEY = 'studyspace_language';
            const FALLBACK = 'bg';
            function normalizeLang(v){
                const x = String(v || '').toLowerCase();
                if(x === 'en') return 'en';
                return 'bg';
            }
            function getLang(){
                try{ return normalizeLang(localStorage.getItem(LANG_KEY) || FALLBACK); }catch(e){ return FALLBACK; }
            }
            function localeForLang(lang){
                return (lang === 'en') ? 'en-GB' : 'bg-BG';
            }

            const DICT = {
                bg: {
                    'menu.editProfile': 'Редактирай профил',
                    'menu.yourAccount': 'Твоят акаунт',
                    'menu.logout': 'Изход'
                },
                en: {
                    'menu.editProfile': 'Edit profile',
                    'menu.yourAccount': 'Your account',
                    'menu.logout': 'Logout'
                }
            };

            function applyI18n(){
                const lang = getLang();
                document.documentElement.setAttribute('lang', lang);
                const t = DICT[lang] || DICT[FALLBACK] || {};
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if(key && t[key]) el.textContent = t[key];
                });
            }

            window.studyspaceI18n = window.studyspaceI18n || {};
            window.studyspaceI18n.getLang = getLang;
            window.studyspaceI18n.setLang = (lang) => {
                const norm = normalizeLang(lang);
                try{ localStorage.setItem(LANG_KEY, norm); }catch(e){}
                applyI18n();
            };
            window.studyspaceI18n.localeForLang = localeForLang;
            window.studyspaceI18n.apply = applyI18n;
            applyI18n();

            // Optional: sync language from profile if user is logged in
            setTimeout(async () => {
                try{
                    const sb = window.supabaseClient;
                    if(!sb || !sb.auth || !sb.from) return;
                    const { data: { user } } = await sb.auth.getUser();
                    if(!user) return;
                    const { data } = await sb.from('profiles').select('language').eq('id', user.id).single();
                    if(data && data.language){
                        window.studyspaceI18n.setLang(data.language);
                    }
                }catch(e){
                    // ignore
                }
            }, 0);
        })();

        function updateDateTime(){
            const d = new Date();
            const dateEl = document.getElementById('date');
            const timeEl = document.getElementById('time');
            const lang = (window.studyspaceI18n && window.studyspaceI18n.getLang) ? window.studyspaceI18n.getLang() : 'bg';
            const locale = (window.studyspaceI18n && window.studyspaceI18n.localeForLang) ? window.studyspaceI18n.localeForLang(lang) : 'bg-BG';
            if(dateEl) dateEl.textContent = d.toLocaleDateString(locale);
            if(timeEl) timeEl.textContent = d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        }
        updateDateTime();
        setInterval(updateDateTime, 60000);

        // SETTINGS: state + modal logic
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsModal = document.getElementById('settingsModal');
        const settingsCloseBtn = document.getElementById('settingsCloseBtn');
        const settingsCancelBtn = document.getElementById('settingsCancelBtn');
        const settingsSaveBtn = document.getElementById('settingsSaveBtn');
        const accentColorInput = document.getElementById('accentColor');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const soundToggle = document.getElementById('soundToggle');
        const sfxToggle = document.getElementById('sfxToggle');

        const DEFAULT_SETTINGS = {
            accentColor: '#2f6bff',
            darkMode: false,
            sound: true,
            sfx: true
        };

        // savedSettings = последно запазени (локално/облак)
        // currentSettings = това, което редактираме в модала (за live preview)
        let savedSettings = { ...DEFAULT_SETTINGS };
        let currentSettings = { ...DEFAULT_SETTINGS };

        function applySettingsToUI() {
            if (accentColorInput) accentColorInput.value = currentSettings.accentColor;
            if (darkModeToggle) darkModeToggle.checked = currentSettings.darkMode;
            if (soundToggle) soundToggle.checked = currentSettings.sound;
            if (sfxToggle) sfxToggle.checked = currentSettings.sfx;
        }

        function hexToRgbaStart(hex) {
            if (!hex || hex[0] !== '#' || (hex.length !== 7 && hex.length !== 4)) return 'rgba(32, 102, 255, 0.72)';
            let r,g,b;
            if (hex.length === 7) {
                r = parseInt(hex.slice(1,3),16);
                g = parseInt(hex.slice(3,5),16);
                b = parseInt(hex.slice(5,7),16);
            } else {
                r = parseInt(hex[1] + hex[1],16);
                g = parseInt(hex[2] + hex[2],16);
                b = parseInt(hex[3] + hex[3],16);
            }
            return `rgba(${r}, ${g}, ${b}, 0.72)`;
        }

        function applySettingsToTheme() {
            const root = document.documentElement;
            const accent = currentSettings.accentColor || DEFAULT_SETTINGS.accentColor;
            root.style.setProperty('--accent', accent);
            root.style.setProperty('--accent-2', accent);
            root.style.setProperty('--grad-start', hexToRgbaStart(accent));
            document.body.classList.toggle('dark-mode', !!currentSettings.darkMode);

            // Expose for other scripts that may use sound/sfx
            window.studyspaceSettings = {
                soundEnabled: !!currentSettings.sound,
                sfxEnabled: !!currentSettings.sfx
            };
        }

        function loadSettingsFromLocal() {
            try {
                const raw = localStorage.getItem('studyspace_settings');
                if (!raw) return;
                const parsed = JSON.parse(raw);
                savedSettings = { ...savedSettings, ...parsed };
            } catch (e) {
                console.warn('settings local load failed', e);
            }
        }

        function saveSettingsToLocal() {
            try {
                localStorage.setItem('studyspace_settings', JSON.stringify(currentSettings));
            } catch (e) {
                console.warn('settings local save failed', e);
            }
        }

        async function loadSettingsFromCloud() {
            try {
                const sb = window.supabaseClient;
                if (!sb) return;
                const { data: { user } } = await sb.auth.getUser();
                if (!user) return;
                const { data, error } = await sb
                    .from('user_settings')
                    .select('*')
                    .eq('user_id', user.id)
                    .maybeSingle();
                if (error && error.code !== 'PGRST116') { console.warn('user_settings select error', error); return; }
                if (data) {
                    savedSettings.accentColor = data.accent_color || savedSettings.accentColor;
                    savedSettings.darkMode = !!data.dark_mode;
                    savedSettings.sound = data.sound_enabled ?? savedSettings.sound;
                    savedSettings.sfx = data.sfx_enabled ?? savedSettings.sfx;
                }
            } catch (e) {
                console.warn('cloud settings load failed', e);
            }
        }

        async function saveSettingsToCloud() {
            try {
                const sb = window.supabaseClient;
                if (!sb) return;
                const { data: { user } } = await sb.auth.getUser();
                if (!user) return;
                const payload = {
                    user_id: user.id,
                    accent_color: savedSettings.accentColor,
                    dark_mode: savedSettings.darkMode,
                    sound_enabled: savedSettings.sound,
                    sfx_enabled: savedSettings.sfx,
                    updated_at: new Date().toISOString()
                };
                await sb.from('user_settings').upsert(payload, { onConflict: 'user_id' });
            } catch (e) {
                console.warn('cloud settings save failed', e);
            }
        }

        function openSettingsModal() {
            // започваме от последно запазените настройки
            currentSettings = { ...savedSettings };
            applySettingsToUI();
            applySettingsToTheme();
            settingsModal.classList.remove('hidden');
        }

        function closeSettingsModal() {
            // връщаме изгледа към запазените стойности
            currentSettings = { ...savedSettings };
            applySettingsToTheme();
            settingsModal.classList.add('hidden');
        }

        if (settingsBtn && settingsModal) {
            settingsBtn.addEventListener('click', openSettingsModal);
        }
        if (settingsCloseBtn) settingsCloseBtn.addEventListener('click', closeSettingsModal);
        if (settingsCancelBtn) settingsCancelBtn.addEventListener('click', closeSettingsModal);
        if (settingsModal) {
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) closeSettingsModal();
            });
        }

        if (settingsSaveBtn) {
            settingsSaveBtn.addEventListener('click', async () => {
                // Commit current -> saved and persist
                savedSettings = { ...currentSettings };
                applySettingsToTheme();
                saveSettingsToLocal();
                await saveSettingsToCloud();
                closeSettingsModal();
            });
        }

        // Live preview while changing controls
        if (accentColorInput) {
            accentColorInput.addEventListener('input', () => {
                currentSettings.accentColor = accentColorInput.value || currentSettings.accentColor;
                applySettingsToTheme();
            });
        }
        if (darkModeToggle) {
            darkModeToggle.addEventListener('change', () => {
                currentSettings.darkMode = !!darkModeToggle.checked;
                applySettingsToTheme();
            });
        }
        if (soundToggle) {
            soundToggle.addEventListener('change', () => {
                currentSettings.sound = !!soundToggle.checked;
                applySettingsToTheme();
            });
        }
        if (sfxToggle) {
            sfxToggle.addEventListener('change', () => {
                currentSettings.sfx = !!sfxToggle.checked;
                applySettingsToTheme();
            });
        }

        // Initial load of settings
        (async () => {
            loadSettingsFromLocal();
            await loadSettingsFromCloud();
            currentSettings = { ...savedSettings };
            applySettingsToTheme();
        })();

    // Край на основния скрипт блок
    </script>

    <script>
        // Стартираме Clipboard логиката в нов, чист блок
        (async function(){
            const clipboard = document.getElementById('homeClipboard');
            const capsule = document.getElementById('homeClipboardCapsule');
            const panel = document.getElementById('homeClipboardPanel');
            const list = document.getElementById('homeClipboardList');
            const countEl = document.getElementById('homeClipboardCount');
            const emptyEl = document.getElementById('homeClipboardEmpty');
            
            if(!clipboard || !capsule || !panel || !list) return;

            const reducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            const clipboardElementMap = new Map();
            const TEXT_SNIPPET_TYPES = new Set([
                'application/json',
                'application/xml',
                'application/javascript',
                'application/x-javascript',
                'application/svg+xml'
            ]);
            const MAX_TEXT_PREVIEW_CHARS = 160;
            let clipboardItems = [];
            let clipboardOpen = false;
            let dragDepth = 0;
            let dragGhostEl = null;

            const STUDY_CLIPBOARD_DB_NAME = 'studyspace_clipboard_db_v1';
            const STUDY_CLIPBOARD_STORE = 'files';

            function openStudyClipboardDb(){
                if(!('indexedDB' in window)){
                    return Promise.reject(new Error('IndexedDB unavailable'));
                }
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(STUDY_CLIPBOARD_DB_NAME, 1);
                    request.onupgradeneeded = () => {
                        const db = request.result;
                        if(!db.objectStoreNames.contains(STUDY_CLIPBOARD_STORE)){
                            db.createObjectStore(STUDY_CLIPBOARD_STORE, { keyPath: 'id' });
                        }
                    };
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error || new Error('IndexedDB open failed'));
                });
            }

            async function persistClipboardItem(item){
                if(!item || !item.id || !item.file) return;
                try{
                    const db = await openStudyClipboardDb();
                    await new Promise((resolve, reject) => {
                        const tx = db.transaction(STUDY_CLIPBOARD_STORE, 'readwrite');
                        tx.oncomplete = () => resolve();
                        tx.onerror = () => reject(tx.error || new Error('IndexedDB transaction failed'));
                        const store = tx.objectStore(STUDY_CLIPBOARD_STORE);
                        store.put({
                            id: item.id,
                            name: item.name,
                            size: item.size,
                            type: item.type || '',
                            lastModified: item.file.lastModified || Date.now(),
                            createdAt: item.createdAt || Date.now(),
                            blob: item.file
                        });
                    });
                } catch(err){
                    // Ignore persistence errors (private mode / blocked / quota)
                }
            }

            async function loadPersistedClipboardItems(){
                try{
                    const db = await openStudyClipboardDb();
                    const records = await new Promise((resolve, reject) => {
                        const tx = db.transaction(STUDY_CLIPBOARD_STORE, 'readonly');
                        const store = tx.objectStore(STUDY_CLIPBOARD_STORE);
                        const request = store.getAll();
                        request.onsuccess = () => resolve(request.result || []);
                        request.onerror = () => reject(request.error || new Error('IndexedDB getAll failed'));
                    });
                    return (records || []).map(rec => {
                        const blob = rec && rec.blob;
                        const fallbackName = (rec && rec.name) || (blob && blob.name) || 'file';
                        const fallbackType = (rec && rec.type) || (blob && blob.type) || '';
                        const fallbackLastModified = (rec && rec.lastModified) || (blob && blob.lastModified) || Date.now();
                        const file = new File([blob], fallbackName, { type: fallbackType, lastModified: fallbackLastModified });
                        const mime = rec && rec.type ? rec.type : (file.type || '');
                        return {
                            id: rec.id,
                            name: rec.name || file.name,
                            size: rec.size || file.size,
                            type: mime,
                            displayType: mime || 'Файл',
                            file,
                            previewUrl: null,
                            previewKind: null,
                            previewIcon: null,
                            snippet: '',
                            previewPrepared: false,
                            createdAt: rec.createdAt || 0
                        };
                    }).filter(Boolean);
                } catch(err){
                    return [];
                }
            }

            async function syncClipboardFromDb(){
                try{
                    const persisted = await loadPersistedClipboardItems();
                    if(Array.isArray(persisted) && persisted.length > 0){
                        const existingById = new Map(clipboardItems.map(item => [item.id, item]));
                        persisted.forEach(item => {
                            if(item && item.id && !existingById.has(item.id)){
                                clipboardItems.push(item);
                            }
                        });
                        clipboardItems.sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
                    }
                } catch(err){
                    // Ignore sync errors
                }
                updateClipboardUI();
            }

            function formatBytes(bytes){
                if(typeof bytes !== 'number' || Number.isNaN(bytes)) return '0 B';
                const units = ['B','KB','MB','GB','TB'];
                let value = bytes;
                let index = 0;
                while(value >= 1024 && index < units.length - 1){
                    value /= 1024;
                    index++;
                }
                const formatted = value % 1 === 0 ? value : value.toFixed(1);
                return `${formatted} ${units[index]}`;
            }

            function pickPreviewIcon(type){
                if(!type) return '📄';
                if(type.includes('sheet') || type.includes('excel') || type.includes('spreadsheet')) return '📊';
                if(type.includes('presentation') || type.includes('powerpoint') || type.includes('slideshow')) return '📽️';
                if(type.includes('word') || type.includes('document') || type.includes('msword')) return '📃';
                if(type.includes('audio')) return '🎵';
                if(type.includes('video')) return '🎬';
                if(type.includes('pdf')) return '📕';
                if(type.includes('zip') || type.includes('compressed') || type.includes('archive')) return '🗜️';
                return '📄';
            }

            function fillPreview(previewEl, item){
                previewEl.innerHTML = '';
                if(item.previewKind === 'image' && item.previewUrl){
                    const img = document.createElement('img');
                    img.src = item.previewUrl;
                    img.alt = item.name;
                    previewEl.appendChild(img);
                } else {
                    const iconEl = document.createElement('div');
                    iconEl.className = 'home-clipboard-preview-icon';
                    iconEl.textContent = item.previewIcon || pickPreviewIcon((item.type || '').toLowerCase());
                    previewEl.appendChild(iconEl);
                }
            }

            function refreshItemPreview(item){
                const record = clipboardElementMap.get(item.id);
                if(record){
                    fillPreview(record.preview, item);
                }
            }

            function updateSnippetDisplay(item){
                const record = clipboardElementMap.get(item.id);
                if(!record) return;
                if(item.snippet){
                    if(record.snippet){
                        record.snippet.textContent = item.snippet;
                    } else {
                        const snippetEl = document.createElement('p');
                        snippetEl.className = 'home-clipboard-snippet';
                        snippetEl.textContent = item.snippet;
                        record.info.insertBefore(snippetEl, record.details);
                        record.snippet = snippetEl;
                    }
                } else if(record.snippet){
                    record.snippet.remove();
                    record.snippet = null;
                }
            }

            function prepareItemPreview(item){
                if(!item || !item.file || item.previewPrepared) return;
                const mime = (item.type || item.file.type || '').toLowerCase();
                if(mime.startsWith('image/')){
                    item.previewKind = 'image';
                    if(!item.previewUrl){
                        item.previewUrl = URL.createObjectURL(item.file);
                    }
                    refreshItemPreview(item);
                } else if(mime.startsWith('text/') || TEXT_SNIPPET_TYPES.has(mime)){
                    item.previewKind = 'icon';
                    item.previewIcon = '📝';
                    refreshItemPreview(item);
                    const snippetSource = item.file.slice(0, 4096);
                    snippetSource.text().then(text => {
                        if(typeof text !== 'string'){
                            item.previewKind = 'icon';
                            item.previewIcon = pickPreviewIcon(mime);
                            refreshItemPreview(item);
                            item.snippet = '';
                            updateSnippetDisplay(item);
                            return;
                        }
                        const cleaned = text.replace(/\s+/g,' ').trim();
                        if(!cleaned){
                            item.previewKind = 'icon';
                            item.previewIcon = pickPreviewIcon(mime);
                            refreshItemPreview(item);
                            item.snippet = '';
                            updateSnippetDisplay(item);
                            return;
                        }
                        item.snippet = cleaned.slice(0, MAX_TEXT_PREVIEW_CHARS);
                        if(cleaned.length > MAX_TEXT_PREVIEW_CHARS){
                            item.snippet = `${item.snippet}…`;
                        }
                        updateSnippetDisplay(item);
                        refreshItemPreview(item);
                    }).catch(()=>{
                        item.previewKind = 'icon';
                        item.previewIcon = pickPreviewIcon(mime);
                        refreshItemPreview(item);
                        item.snippet = '';
                        updateSnippetDisplay(item);
                    });
                } else if(mime.startsWith('video/')){
                    item.previewKind = 'icon';
                    item.previewIcon = '🎬';
                    refreshItemPreview(item);
                } else if(mime.startsWith('audio/')){
                    item.previewKind = 'icon';
                    item.previewIcon = '🎵';
                    refreshItemPreview(item);
                } else if(mime.includes('pdf')){
                    item.previewKind = 'icon';
                    item.previewIcon = '📕';
                    refreshItemPreview(item);
                } else if(mime.includes('sheet') || mime.includes('excel')){
                    item.previewKind = 'icon';
                    item.previewIcon = '📊';
                    refreshItemPreview(item);
                } else if(mime.includes('presentation') || mime.includes('powerpoint')){
                    item.previewKind = 'icon';
                    item.previewIcon = '📽️';
                    refreshItemPreview(item);
                } else if(mime.includes('zip') || mime.includes('compressed')){
                    item.previewKind = 'icon';
                    item.previewIcon = '🗜️';
                    refreshItemPreview(item);
                } else {
                    item.previewKind = 'icon';
                    item.previewIcon = pickPreviewIcon(mime);
                    refreshItemPreview(item);
                }
                item.previewPrepared = true;
            }

            function createDragGhost(entry){
                const ghost = entry.cloneNode(true);
                ghost.style.position = 'absolute';
                ghost.style.top = '-9999px';
                ghost.style.left = '-9999px';
                ghost.style.pointerEvents = 'none';
                ghost.style.width = `${entry.offsetWidth}px`;
                document.body.appendChild(ghost);
                return ghost;
            }

            function handleItemDragStart(event, item, entry){
                entry.classList.add('dragging');
                if(event.dataTransfer){
                    event.dataTransfer.effectAllowed = 'copy';
                    event.dataTransfer.setData('text/plain', item.name);
                    event.dataTransfer.setData('application/x-studyspace-clipboard-id', item.id);
                    try{
                        event.dataTransfer.setData('application/x-study-clipboard', JSON.stringify({ name: item.name, size: item.size, type: item.displayType || 'Файл', mime: item.type || '' }));
                    } catch(err){
                        // Ignore unsupported structured data
                    }
                    if(event.dataTransfer.items && typeof event.dataTransfer.items.add === 'function' && item.file){
                        try{
                            event.dataTransfer.items.add(item.file);
                        } catch(err){
                            // Some browsers disallow adding files programmatically
                        }
                    }
                    const ghost = createDragGhost(entry);
                    if(ghost){
                        dragGhostEl = ghost;
                        event.dataTransfer.setDragImage(ghost, ghost.offsetWidth / 2, ghost.offsetHeight / 2);
                    }
                }
            }

            function handleItemDragEnd(event){
                event.currentTarget.classList.remove('dragging');
                if(dragGhostEl && dragGhostEl.parentNode){
                    dragGhostEl.parentNode.removeChild(dragGhostEl);
                }
                dragGhostEl = null;
            }

            function createClipboardEntry(item){
                const entry = document.createElement('li');
                entry.className = 'home-clipboard-item';
                entry.setAttribute('draggable', 'true');
                entry.dataset.itemId = item.id;

                const preview = document.createElement('div');
                preview.className = 'home-clipboard-preview';
                fillPreview(preview, item);

                const title = document.createElement('div');
                title.className = 'home-clipboard-item-title';
                title.textContent = item.name;

                const info = document.createElement('div');
                info.className = 'home-clipboard-info';
                info.appendChild(title);

                let snippetEl = null;
                if(item.snippet){
                    snippetEl = document.createElement('p');
                    snippetEl.className = 'home-clipboard-snippet';
                    snippetEl.textContent = item.snippet;
                    info.appendChild(snippetEl);
                }

                const details = document.createElement('div');
                details.className = 'home-clipboard-item-details';
                details.textContent = `${item.displayType || 'Файл'} · ${formatBytes(item.size)}`;
                info.appendChild(details);

                entry.append(preview, info);
                entry.addEventListener('dragstart', (event) => handleItemDragStart(event, item, entry));
                entry.addEventListener('dragend', handleItemDragEnd);

                clipboardElementMap.set(item.id, { entry, preview, info, details, snippet: snippetEl });
                return entry;
            }

            function clearClipboardPreviews(){
                clipboardItems.forEach(item => {
                    if(item.previewUrl){
                        URL.revokeObjectURL(item.previewUrl);
                        item.previewUrl = null;
                    }
                });
            }

            function updateClipboardUI(){
                if(countEl){
                    countEl.textContent = clipboardItems.length.toString();
                    countEl.setAttribute('aria-hidden', clipboardItems.length > 0 ? 'false' : 'true');
                }
                clipboard.classList.toggle('has-items', clipboardItems.length > 0);
                if(emptyEl){
                    emptyEl.setAttribute('aria-hidden', clipboardItems.length > 0 ? 'true' : 'false');
                }
                clipboardElementMap.clear();
                list.innerHTML = '';
                clipboardItems.forEach(item => {
                    prepareItemPreview(item);
                    const entry = createClipboardEntry(item);
                    list.appendChild(entry);
                });
            }

            function setClipboardOpen(nextState){
                if(nextState === clipboardOpen) return;
                clipboardOpen = nextState;
                clipboard.classList.toggle('open', nextState);
                capsule.setAttribute('aria-expanded', nextState ? 'true' : 'false');
                panel.setAttribute('aria-hidden', nextState ? 'false' : 'true');
                if(!nextState){
                    panel.scrollTop = 0;
                }
            }

            async function captureClipboardFiles(files){
                let captured = false;
                const tasks = [];
                Array.from(files || []).forEach(file => {
                    const mime = file.type || '';
                    const item = {
                        id: `${file.name}-${Date.now()}-${Math.random().toString(16).slice(2)}`,
                        name: file.name,
                        size: file.size,
                        type: mime,
                        displayType: mime || 'Файл',
                        file,
                        previewUrl: null,
                        previewKind: null,
                        previewIcon: null,
                        snippet: '',
                        previewPrepared: false,
                        createdAt: Date.now()
                    };
                    clipboardItems.push(item);
                    tasks.push(persistClipboardItem(item));
                    captured = true;
                });
                if(tasks.length){
                    await Promise.allSettled(tasks);
                }
                if(captured){
                    updateClipboardUI();
                }
                return captured;
            }

            const isFileDrag = (event) => {
                const dt = event.dataTransfer;
                if(!dt) return false;
                const types = dt.types ? Array.from(dt.types) : [];
                if(types.includes('Files')) return true;
                if(types.length === 0) return true;
                return dt.files && dt.files.length > 0;
            };

            clipboard.addEventListener('dragenter', (event) => {
                if(!isFileDrag(event)) return;
                event.preventDefault();
                dragDepth += 1;
                clipboard.classList.add('drag-ready');
                if(event.dataTransfer){
                    event.dataTransfer.dropEffect = 'copy';
                }
            });

            clipboard.addEventListener('dragover', (event) => {
                if(!isFileDrag(event)) return;
                event.preventDefault();
                if(event.dataTransfer){
                    event.dataTransfer.dropEffect = 'copy';
                }
            });

            clipboard.addEventListener('dragleave', (event) => {
                if(!isFileDrag(event)) return;
                event.preventDefault();
                dragDepth = Math.max(dragDepth - 1, 0);
                if(dragDepth === 0){
                    clipboard.classList.remove('drag-ready');
                }
            });

            clipboard.addEventListener('drop', async (event) => {
                if(!isFileDrag(event)) return;
                event.preventDefault();
                dragDepth = 0;
                clipboard.classList.remove('drag-ready');
                const files = event.dataTransfer ? event.dataTransfer.files : null;
                if(await captureClipboardFiles(files)){
                    if(!reducedMotion){
                        clipboard.classList.remove('captured');
                        void clipboard.offsetWidth;
                        clipboard.classList.add('captured');
                        setTimeout(() => clipboard.classList.remove('captured'), 600);
                    }
                    setTimeout(() => setClipboardOpen(false), 180);
                }
            });

            capsule.addEventListener('dblclick', async () => {
                await syncClipboardFromDb();
                setClipboardOpen(!clipboardOpen);
            });

            let hoverIntentTimer = null;

            function scheduleAutoClose(){
                if(hoverIntentTimer){
                    clearTimeout(hoverIntentTimer);
                }
                hoverIntentTimer = setTimeout(() => {
                    if(!clipboard.matches(':hover') && clipboardOpen){
                        setClipboardOpen(false);
                    }
                }, 260);
            }

            clipboard.addEventListener('mouseleave', () => {
                if(!clipboardOpen) return;
                scheduleAutoClose();
            });

            clipboard.addEventListener('mouseenter', () => {
                if(hoverIntentTimer){
                    clearTimeout(hoverIntentTimer);
                    hoverIntentTimer = null;
                }
            });

            capsule.addEventListener('keydown', async (event) => {
                if(event.key === 'Enter' || event.key === ' '){
                    event.preventDefault();
                    await syncClipboardFromDb();
                    setClipboardOpen(!clipboardOpen);
                } else if(event.key === 'Escape' && clipboardOpen){
                    setClipboardOpen(false);
                }
            });

            document.addEventListener('click', (event) => {
                if(clipboardOpen && !clipboard.contains(event.target)){
                    setClipboardOpen(false);
                }
            });

            document.addEventListener('keydown', (event) => {
                if(event.key === 'Escape' && clipboardOpen){
                    setClipboardOpen(false);
                }
            });

            window.addEventListener('beforeunload', clearClipboardPreviews);
            window.addEventListener('blur', () => {
                if(clipboardOpen){
                    setClipboardOpen(false);
                }
            });

            await syncClipboardFromDb();
            setClipboardOpen(false);
        })();
    </script>

    <script>
        // Custom blocks functionality
        (function(){
            let editMode = false;
            let draggedElement = null;
            let dragOffset = { x: 0, y: 0 };
            let isResizing = false;
            let resizeObserver = null;
            let originalDimensions = new Map(); // Store original dimensions
            let originalPositions = new Map(); // Store original positions
            
            // Dynamic grid size calculation
            function getGridSize() {
                const viewportWidth = window.innerWidth;
                // Grid size scales between 15px (mobile) and 25px (desktop)
                return Math.max(15, Math.min(25, Math.round(viewportWidth * 0.02)));
            }
            
            let gridSize = getGridSize(); // Initialize grid size
            const MAX_CONTAINER_HEIGHT = 2400; // safety cap for layout height

            const editBtn = document.getElementById('editBlocksBtn');
            const removeAllBtn = document.getElementById('removeAllBlocksBtn');
            const customBlocks = document.getElementById('customBlocks');
            const addBlockBtn = document.getElementById('addBlockBtn');
            const blockBuilderModal = document.getElementById('blockBuilder');
            const blockLibraryOverlay = document.getElementById('blockLibrary');
            const blockLibraryPanel = document.getElementById('blockLibraryPanel');
            const blockLibraryGrid = document.getElementById('blockLibraryGrid');
            const blockLibraryCloseBtn = document.getElementById('blockLibraryClose');
            const builderForm = document.getElementById('blockBuilderForm');
            const builderTitleEl = document.getElementById('builderTitle');
            const builderSubtitleEl = blockBuilderModal ? blockBuilderModal.querySelector('.builder-subtitle') : null;
            const builderPreviewInner = document.getElementById('builderLivePreviewInner');
            const builderPreviewHintEl = blockBuilderModal ? blockBuilderModal.querySelector('.builder-preview-hint') : null;
            const builderPreviewStageEl = blockBuilderModal ? blockBuilderModal.querySelector('.builder-preview-stage') : null;
            const builderTypeButtons = blockBuilderModal ? blockBuilderModal.querySelectorAll('.builder-type-btn') : [];
            const builderSections = blockBuilderModal ? blockBuilderModal.querySelectorAll('.builder-section') : [];
            const builderCancelBtn = document.getElementById('builderCancelBtn');
            const builderCloseBtn = document.getElementById('builderCloseBtn');
            const builderSaveBtn = document.getElementById('builderSaveBtn');
            const builderChecklistItems = document.getElementById('builderChecklistItems');
            const builderAddChecklistItemBtn = document.getElementById('builderAddChecklistItem');
            const builderColorInput = document.getElementById('blockColor');
            const builderColorValue = document.getElementById('builderColorValue');
            const checklistTitleInput = document.getElementById('checklistTitle');
            const checklistAiToggle = document.getElementById('checklistAiToggle');
            let activeBuilderType = 'music';
            let builderEditingBlock = null;
            let builderEditingBlockId = null;
            let builderLockedType = null;
            let builderPreviewRaf = null;
            const builderDefaultTitle = builderTitleEl ? builderTitleEl.textContent : '';
            const builderDefaultSubtitle = builderSubtitleEl ? builderSubtitleEl.textContent : '';
            const builderDefaultPreviewHint = builderPreviewHintEl ? builderPreviewHintEl.textContent : '';
            const builderReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            let builderPraglassWired = false;
            let builderPreviewState = {
                left: null,
                top: null,
                width: 360,
                height: 220
            };
            let builderPreviewDrag = null;
            let builderPreviewResize = null;
            let blocks = document.querySelectorAll('.custom-block');
            const CUSTOM_BLOCKS_STORAGE_KEY = 'customBlocksData';
            const REMOVED_DEFAULT_BLOCKS_KEY = 'removedDefaultBlocks';
            const DEFAULT_BLOCK_COLOR = '#4d7cff';
            const AI_WORKER_ENDPOINT = window.WORKER || window.STUDYSPACE_AI_ENDPOINT || window.STUDYSPACE_AI_WORKER || null;
            let checklistAIEnabled = checklistAiToggle ? checklistAiToggle.checked : false;
            window.checklistAIEnabled = checklistAIEnabled;
            let checklistAIDebounce = null;
            let libraryExpanded = false;
            let libraryDragType = null;
            let libraryWasExpandedOnDragStart = false;
            let libraryHiddenForDrag = false;
            let libraryDragConfig = null;

            const LONG_PRESS_DELAY = 550;
            const LONG_PRESS_MOVE_TOLERANCE = 6;
            let longPressTimer = null;
            let longPressTarget = null;
            let longPressStartPos = { x: 0, y: 0 };

            const LIBRARY_BLOCK_TEMPLATES = [
                { type: 'calendar', title: 'Calendar Block', chip: 'Събития', lines: ['medium', 'short', 'tiny'] },
                { type: 'music', title: 'Music Block', chip: 'Spotify / Apple', lines: ['medium', 'medium', 'short'] },
                { type: 'link', title: 'Useful links', chip: 'Любими сайтове', lines: ['medium', 'short'] },
                { type: 'weather', title: 'Weather', chip: 'Текуща локация', lines: ['medium', 'tiny'] },
                { type: 'checklist', title: 'Checklist', chip: 'Задачи', lines: ['medium', 'medium', 'short'] },
                { type: 'reminder', title: 'Notes', chip: 'Бързи бележки', lines: ['medium', 'short', 'tiny'] }
            ];

            const LIBRARY_COLORS = [
                { base: '#0ea5e9', soft: '#38bdf8' },
                { base: '#6366f1', soft: '#4f46e5' },
                { base: '#a855f7', soft: '#ec4899' },
                { base: '#22c55e', soft: '#16a34a' },
                { base: '#f97316', soft: '#fb923c' },
                { base: '#facc15', soft: '#fbbf24' }
            ];

            function setLibraryExpanded(next) {
                libraryExpanded = !!next;
                if (!blockLibraryOverlay) return;
                blockLibraryOverlay.classList.toggle('expanded', libraryExpanded);
            }

            function scheduleBuilderPreviewUpdate() {
                if (!builderPreviewInner) return;
                if (builderPreviewRaf) {
                    cancelAnimationFrame(builderPreviewRaf);
                }
                builderPreviewRaf = requestAnimationFrame(() => {
                    builderPreviewRaf = null;
                    renderBuilderLivePreview();
                });
            }

            function ensureBuilderPraglassWired() {
                if (builderPraglassWired) return;
                if (!builderPreviewStageEl || !builderPreviewInner) return;
                builderPraglassWired = true;

                const getPreviewBlock = () => builderPreviewInner.querySelector('.builder-preview-block');
                const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

                const getCanvasMargin = () => {
                    try {
                        const raw = getComputedStyle(builderPreviewInner).getPropertyValue('--builder-preview-margin').trim();
                        const px = parseFloat(raw);
                        return Number.isFinite(px) ? px : 14;
                    } catch (err) {
                        return 14;
                    }
                };

                const applyState = () => {
                    const el = getPreviewBlock();
                    if (!el) return;
                    const rect = builderPreviewInner.getBoundingClientRect();
                    const margin = getCanvasMargin();

                    const minW = 240;
                    const minH = 160;
                    const maxWByCanvas = Math.max(minW, Math.floor(rect.width - (margin * 2)));
                    const maxHByCanvas = Math.max(minH, Math.floor(rect.height - (margin * 2)));

                    builderPreviewState.width = clamp(builderPreviewState.width || (el.offsetWidth || 360), minW, maxWByCanvas);
                    builderPreviewState.height = clamp(builderPreviewState.height || (el.offsetHeight || 220), minH, maxHByCanvas);

                    const maxLeft = Math.max(margin, rect.width - margin - builderPreviewState.width);
                    const maxTop = Math.max(margin, rect.height - margin - builderPreviewState.height);

                    if (builderPreviewState.left == null || builderPreviewState.top == null) {
                        // Center by default.
                        builderPreviewState.left = Math.round((margin + maxLeft) / 2);
                        builderPreviewState.top = Math.round((margin + maxTop) / 2);
                    }

                    builderPreviewState.left = clamp(builderPreviewState.left, margin, maxLeft);
                    builderPreviewState.top = clamp(builderPreviewState.top, margin, maxTop);

                    el.style.left = builderPreviewState.left + 'px';
                    el.style.top = builderPreviewState.top + 'px';
                    if (builderPreviewState.width) el.style.width = builderPreviewState.width + 'px';
                    if (builderPreviewState.height) el.style.height = builderPreviewState.height + 'px';
                };

                const reset = () => {
                    const el = getPreviewBlock();
                    if (!el) return;
                    el.style.setProperty('--rx', '0deg');
                    el.style.setProperty('--ry', '0deg');
                    applyState();
                };

                const onMove = (event) => {
                    if (builderReducedMotion) return;
                    const el = getPreviewBlock();
                    if (!el) return;
                    const rect = builderPreviewStageEl.getBoundingClientRect();
                    const x = rect.width ? (event.clientX - rect.left) / rect.width : 0.5;
                    const y = rect.height ? (event.clientY - rect.top) / rect.height : 0.5;
                    const cx = Math.max(0, Math.min(1, x));
                    const cy = Math.max(0, Math.min(1, y));

                    // Stronger tilt (tilt-only, no gloss).
                    const ry = (cx - 0.5) * 24;  // deg
                    const rx = (0.5 - cy) * 18;  // deg

                    el.style.setProperty('--rx', rx.toFixed(2) + 'deg');
                    el.style.setProperty('--ry', ry.toFixed(2) + 'deg');
                };

                // Drag + resize within the preview canvas.
                const onPointerDownBlock = (event) => {
                    const el = getPreviewBlock();
                    if (!el) return;
                    const handle = event.target && event.target.closest ? event.target.closest('.builder-preview-resize-handle') : null;
                    if (handle) return; // handled by resize handler
                    event.preventDefault();
                    event.stopPropagation();

                    const blockRect = el.getBoundingClientRect();
                    const canvasRect = builderPreviewInner.getBoundingClientRect();
                    const startX = event.clientX;
                    const startY = event.clientY;
                    const startLeft = blockRect.left - canvasRect.left;
                    const startTop = blockRect.top - canvasRect.top;

                    builderPreviewDrag = { pointerId: event.pointerId, startX, startY, startLeft, startTop };
                    try { el.setPointerCapture(event.pointerId); } catch (err) {}
                };

                const onPointerDownResize = (event) => {
                    const el = getPreviewBlock();
                    if (!el) return;
                    const handle = event.target && event.target.closest ? event.target.closest('.builder-preview-resize-handle') : null;
                    if (!handle) return;
                    event.preventDefault();
                    event.stopPropagation();

                    const startX = event.clientX;
                    const startY = event.clientY;
                    const startW = el.offsetWidth || builderPreviewState.width;
                    const startH = el.offsetHeight || builderPreviewState.height;
                    builderPreviewResize = { pointerId: event.pointerId, startX, startY, startW, startH };
                    try { handle.setPointerCapture(event.pointerId); } catch (err) {}
                };

                const onPointerMoveGlobal = (event) => {
                    const el = getPreviewBlock();
                    if (!el) return;
                    const canvasRect = builderPreviewInner.getBoundingClientRect();
                    const margin = getCanvasMargin();

                    if (builderPreviewDrag && builderPreviewDrag.pointerId === event.pointerId) {
                        const dx = event.clientX - builderPreviewDrag.startX;
                        const dy = event.clientY - builderPreviewDrag.startY;
                        builderPreviewState.left = Math.round(builderPreviewDrag.startLeft + dx);
                        builderPreviewState.top = Math.round(builderPreviewDrag.startTop + dy);
                        applyState();
                    }

                    if (builderPreviewResize && builderPreviewResize.pointerId === event.pointerId) {
                        const dx = event.clientX - builderPreviewResize.startX;
                        const dy = event.clientY - builderPreviewResize.startY;
                        const nextW = Math.round(builderPreviewResize.startW + dx);
                        const nextH = Math.round(builderPreviewResize.startH + dy);

                        const minW = 240;
                        const minH = 160;

                        const currentLeft = (builderPreviewState.left != null)
                            ? builderPreviewState.left
                            : Math.round(el.getBoundingClientRect().left - canvasRect.left);
                        const currentTop = (builderPreviewState.top != null)
                            ? builderPreviewState.top
                            : Math.round(el.getBoundingClientRect().top - canvasRect.top);

                        const maxW = Math.max(minW, Math.floor(canvasRect.width - margin - currentLeft));
                        const maxH = Math.max(minH, Math.floor(canvasRect.height - margin - currentTop));

                        // Also never exceed canvas minus both margins.
                        const maxWByCanvas = Math.max(minW, Math.floor(canvasRect.width - (margin * 2)));
                        const maxHByCanvas = Math.max(minH, Math.floor(canvasRect.height - (margin * 2)));

                        builderPreviewState.width = clamp(nextW, minW, Math.min(maxW, maxWByCanvas));
                        builderPreviewState.height = clamp(nextH, minH, Math.min(maxH, maxHByCanvas));
                        applyState();
                    }
                };

                const onPointerUpGlobal = (event) => {
                    if (builderPreviewDrag && builderPreviewDrag.pointerId === event.pointerId) {
                        builderPreviewDrag = null;
                    }
                    if (builderPreviewResize && builderPreviewResize.pointerId === event.pointerId) {
                        builderPreviewResize = null;
                    }
                };

                builderPreviewStageEl.addEventListener('pointermove', onMove);
                builderPreviewStageEl.addEventListener('pointerleave', reset);
                builderPreviewStageEl.addEventListener('pointercancel', reset);
                builderPreviewStageEl.addEventListener('pointerdown', (e) => {
                    // capture pointer so movement continues while pressed
                    try { builderPreviewStageEl.setPointerCapture(e.pointerId); } catch (err) {}
                    onMove(e);
                });

                // Wire drag/resize events on the preview canvas.
                builderPreviewInner.addEventListener('pointerdown', (e) => {
                    // If user clicks on the block or its resize handle.
                    const el = getPreviewBlock();
                    if (!el) return;
                    if (e.target && e.target.closest && e.target.closest('.builder-preview-resize-handle')) {
                        onPointerDownResize(e);
                        return;
                    }
                    if (e.target && e.target.closest && e.target.closest('.builder-preview-block')) {
                        onPointerDownBlock(e);
                    }
                });

                window.addEventListener('pointermove', onPointerMoveGlobal);
                window.addEventListener('pointerup', onPointerUpGlobal);
                window.addEventListener('pointercancel', onPointerUpGlobal);

                reset();
            }

            function renderBuilderLivePreview() {
                if (!builderPreviewInner) return;
                const type = builderLockedType || activeBuilderType;
                const config = collectBuilderConfig(type);
                builderPreviewInner.innerHTML = '';

                const previewBlock = document.createElement('div');
                previewBlock.className = 'custom-block builder-preview-block praglass';

                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'builder-preview-resize-handle';
                previewBlock.appendChild(resizeHandle);

                const content = createBlockContent(type, config);
                previewBlock.appendChild(content);

                applyBlockColor(previewBlock, config.color || DEFAULT_BLOCK_COLOR);
                builderPreviewInner.appendChild(previewBlock);

                ensureBuilderPraglassWired();
            }

            function isDefaultBlock(block) {
                return block && block.getAttribute('data-default-block') === 'true';
            }

            function getRemovedDefaultBlocks() {
                try {
                    const raw = localStorage.getItem(REMOVED_DEFAULT_BLOCKS_KEY);
                    return raw ? JSON.parse(raw) : [];
                } catch (err) {
                    return [];
                }
            }

            function markDefaultBlockRemoved(blockId) {
                const removed = new Set(getRemovedDefaultBlocks());
                removed.add(blockId);
                localStorage.setItem(REMOVED_DEFAULT_BLOCKS_KEY, JSON.stringify(Array.from(removed)));
            }

            function applyRemovedDefaultBlocks() {
                const removed = new Set(getRemovedDefaultBlocks());
                if (!removed.size) return;
                removed.forEach(blockId => {
                    const block = customBlocks.querySelector(`.custom-block[data-block-id="${blockId}"][data-default-block="true"]`);
                    if (block) {
                        block.remove();
                    }
                });
            }

            function updateBuilderColorValue(color) {
                if (builderColorValue) {
                    builderColorValue.textContent = (color || DEFAULT_BLOCK_COLOR).toUpperCase();
                }
            }

            function normalizeColorValue(color) {
                if (!color || typeof color !== 'string') return DEFAULT_BLOCK_COLOR;
                if (color.startsWith('#')) {
                    return color.length === 4 || color.length === 7 ? color : DEFAULT_BLOCK_COLOR;
                }
                const hexMatch = color.match(/#?[0-9a-fA-F]{6}/);
                return hexMatch ? (hexMatch[0].startsWith('#') ? hexMatch[0] : `#${hexMatch[0]}`) : DEFAULT_BLOCK_COLOR;
            }

            function hexToRgb(hex) {
                if (!hex) return null;
                let normalized = hex.replace('#', '');
                if (normalized.length === 3) {
                    normalized = normalized.split('').map(ch => ch + ch).join('');
                }
                if (normalized.length !== 6) return null;
                const r = parseInt(normalized.slice(0, 2), 16);
                const g = parseInt(normalized.slice(2, 4), 16);
                const b = parseInt(normalized.slice(4, 6), 16);
                if ([r, g, b].some(v => Number.isNaN(v))) return null;
                return { r, g, b };
            }

            function rgbaString(rgb, alpha) {
                if (!rgb) return `rgba(11, 99, 199, ${alpha})`;
                return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
            }

            function applyBlockColor(block, color) {
                if (!block) return;
                const normalized = normalizeColorValue(color);
                const rgb = hexToRgb(normalized) || { r: 77, g: 124, b: 255 };
                const primary = rgbaString(rgb, 0.42);
                const secondary = rgbaString(rgb, 0.18);
                const border = rgbaString(rgb, 0.46);
                const shadow = `0 18px 40px ${rgbaString(rgb, 0.24)}`;
                block.style.setProperty('--block-bg', `linear-gradient(180deg, ${primary}, ${secondary})`);
                block.style.setProperty('--block-border', border);
                block.style.setProperty('--block-shadow', shadow);
                block.dataset.blockColor = normalized;

                // Never sync preview-only blocks.
                if (block.classList && block.classList.contains('builder-preview-block')) return;
                if (typeof syncBlockToCloud === 'function') { syncBlockToCloud(block); }
            }

            function getCustomBlocksData() {
                try {
                    const raw = localStorage.getItem(CUSTOM_BLOCKS_STORAGE_KEY);
                    return raw ? JSON.parse(raw) : {};
                } catch (err) {
                    return {};
                }
            }

            function persistCustomBlockData(blockId, type, config) {
                const data = getCustomBlocksData();
                data[blockId] = { type, config: { ...(config || {}) } };
                localStorage.setItem(CUSTOM_BLOCKS_STORAGE_KEY, JSON.stringify(data));
            }

            function removeCustomBlockData(blockId) {
                const data = getCustomBlocksData();
                if (data[blockId]) {
                    delete data[blockId];
                    localStorage.setItem(CUSTOM_BLOCKS_STORAGE_KEY, JSON.stringify(data));
                }
            }

            function addBuilderChecklistItem(value = '') {
                if (!builderChecklistItems) return;
                const row = document.createElement('div');
                row.className = 'builder-checklist-item';

                const input = document.createElement('input');
                input.type = 'text';
                input.name = 'checklistItem';
                input.placeholder = 'Например: Подготви презентация';
                input.value = value;

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'builder-remove-item';
                removeBtn.setAttribute('aria-label', 'Премахни елемент');
                removeBtn.textContent = '×';

                row.append(input, removeBtn);
                builderChecklistItems.appendChild(row);
            }

            function restoreSavedCustomBlocks() {
                const savedData = getCustomBlocksData();
                const entries = Object.entries(savedData);
                if (!entries.length) {
                    return;
                }
                let savedPositions = {};
                let savedDimensions = {};
                try {
                    savedPositions = JSON.parse(localStorage.getItem('blockPositions') || '{}');
                } catch (err) {
                    savedPositions = {};
                }
                try {
                    savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}');
                } catch (err) {
                    savedDimensions = {};
                }

                entries.forEach(([blockId, payload]) => {
                    if (!payload || !payload.type) return;
                    if (customBlocks.querySelector(`.custom-block[data-block-id="${blockId}"]`)) return;

                    const position = savedPositions[blockId] || null;
                    const dimensions = savedDimensions[blockId] || null;
                    createNewBlock(payload.type, payload.config || {}, {
                        blockId,
                        position,
                        dimensions,
                        restoring: true
                    });
                });
                blocks = document.querySelectorAll('.custom-block');
            }

            function setActiveBuilderType(type) {
                if (!type) return;
                activeBuilderType = type;
                builderTypeButtons.forEach(btn => {
                    const btnType = btn.getAttribute('data-builder-type');
                    btn.classList.toggle('active', btnType === type);
                });
                builderSections.forEach(section => {
                    const sectionType = section.getAttribute('data-builder-section');
                    const isActive = sectionType === type;
                    section.hidden = !isActive;
                    section.classList.toggle('active', isActive);
                    section.querySelectorAll('input, select, textarea').forEach(field => {
                        field.disabled = !isActive;
                    });
                });
                scheduleBuilderPreviewUpdate();
            }

            function resetBuilderFormFields(defaultType = 'music') {
                if (!builderForm) return;
                builderForm.reset();
                if (builderColorInput) {
                    updateBuilderColorValue(builderColorInput.value || DEFAULT_BLOCK_COLOR);
                }
                if (builderChecklistItems) {
                    builderChecklistItems.innerHTML = '';
                    addBuilderChecklistItem('Примерна задача');
                    addBuilderChecklistItem('');
                }
                setActiveBuilderType(defaultType);
            }

            function applyConfigToBuilder(type, config = {}) {
                if (!builderForm) return;
                const color = config.color || DEFAULT_BLOCK_COLOR;
                if (builderColorInput) {
                    builderColorInput.value = color;
                    updateBuilderColorValue(color);
                }
                switch (type) {
                    case 'music':
                        if (builderForm.musicTitle) builderForm.musicTitle.value = config.title || 'Музика';
                        if (builderForm.musicPlatform) builderForm.musicPlatform.value = config.platform || 'spotify';
                        if (builderForm.musicUrl) builderForm.musicUrl.value = config.url || '';
                        if (builderForm.musicNote) builderForm.musicNote.value = config.note || '';
                        break;
                    case 'weather':
                        if (builderForm.weatherTitle) builderForm.weatherTitle.value = config.title || 'Време';
                        if (builderForm.weatherLocation) builderForm.weatherLocation.value = config.location || '';
                        if (builderForm.weatherUnits) builderForm.weatherUnits.value = config.units || 'metric';
                        break;
                    case 'checklist': {
                        if (builderForm.checklistTitle) builderForm.checklistTitle.value = config.title || 'Чеклист';
                        if (builderChecklistItems) {
                            builderChecklistItems.innerHTML = '';
                            const items = (config.items && config.items.length) ? config.items : ['Нова задача'];
                            items.forEach(text => addBuilderChecklistItem(text));
                        }
                        break;
                    }
                    case 'calendar':
                        if (builderForm.calendarTitle) builderForm.calendarTitle.value = config.title || 'Календар';
                        if (builderForm.calendarMode) builderForm.calendarMode.value = config.mode || 'link';
                        if (builderForm.calendarUrl) builderForm.calendarUrl.value = config.url || '';
                        break;
                    default:
                        break;
                }
            }

            function setBuilderTypeLock(type) {
                builderLockedType = type || null;
                builderTypeButtons.forEach(btn => {
                    const btnType = btn.getAttribute('data-builder-type');
                    btn.disabled = Boolean(builderLockedType && btnType !== builderLockedType);
                });
            }

            function clearBuilderEditingTarget() {
                builderEditingBlock = null;
                builderEditingBlockId = null;
                setBuilderTypeLock(null);
                if (builderTitleEl && builderDefaultTitle) {
                    builderTitleEl.textContent = builderDefaultTitle;
                }
                if (builderSubtitleEl && builderDefaultSubtitle) {
                    builderSubtitleEl.textContent = builderDefaultSubtitle;
                }
                if (builderPreviewHintEl && builderDefaultPreviewHint) {
                    builderPreviewHintEl.textContent = builderDefaultPreviewHint;
                }
                if (builderSaveBtn) builderSaveBtn.textContent = 'Запази';
            }

            function openBlockBuilder(defaultType = 'music', existingConfig, targetBlock) {
                if (!blockBuilderModal) return;
                if (targetBlock) {
                    builderEditingBlock = targetBlock;
                    builderEditingBlockId = targetBlock.getAttribute('data-block-id') || null;
                    // Allow changing the block type from the settings UI.
                    setBuilderTypeLock(null);
                    if (builderTitleEl) {
                        builderTitleEl.textContent = 'Редактирай блок';
                    }
                    if (builderSubtitleEl) {
                        builderSubtitleEl.textContent = 'Промените се виждат само тук до „Запази“. ';
                    }
                    if (builderPreviewHintEl) {
                        builderPreviewHintEl.textContent = 'Промените се прилагат след „Запази“';
                    }
                    if (builderSaveBtn) builderSaveBtn.textContent = 'Запази';
                } else {
                    clearBuilderEditingTarget();
                    if (builderPreviewHintEl) {
                        builderPreviewHintEl.textContent = 'Промените се прилагат след „Запази“';
                    }
                }
                resetBuilderFormFields(defaultType);
                if (existingConfig) {
                    applyConfigToBuilder(defaultType, existingConfig);
                }
                blockBuilderModal.classList.add('show');
                scheduleBuilderPreviewUpdate();
                requestAnimationFrame(() => {
                    const focusTarget = blockBuilderModal.querySelector(`[data-builder-section="${activeBuilderType}"] input, [data-builder-section="${activeBuilderType}"] select`);
                    if (focusTarget) {
                        focusTarget.focus({ preventScroll: true });
                    }
                });
            }

            function closeBlockBuilder() {
                if (!blockBuilderModal) return;
                blockBuilderModal.classList.remove('show');
                clearBuilderEditingTarget();
            }

            function applyConfigToExistingBlock(block, type, config) {
                if (!block) return;
                const normalizedConfig = config && typeof config === 'object' ? { ...(config || {}) } : {};
                const normalizedColor = normalizeColorValue(normalizedConfig.color || DEFAULT_BLOCK_COLOR);
                normalizedConfig.color = normalizedColor;

                // Replace block content while keeping the delete button element.
                const deleteBtn = block.querySelector('.delete-btn');
                Array.from(block.children).forEach(child => {
                    if (child !== deleteBtn) child.remove();
                });

                const content = createBlockContent(type, normalizedConfig);
                block.appendChild(content);

                block.dataset.blockType = type;
                try {
                    block.dataset.blockConfig = JSON.stringify(normalizedConfig);
                } catch (err) {
                    delete block.dataset.blockConfig;
                }

                applyBlockColor(block, normalizedColor);
                saveBlockDimensions(block);
                updateContainerHeight();

                // Rewire type-specific internals against the new DOM.
                setupBlockFunctionality(block, type, normalizedConfig);

                // Persist only for non-default blocks (default blocks are static).
                if (!isDefaultBlock(block)) {
                    const blockId = block.getAttribute('data-block-id');
                    if (blockId) {
                        persistCustomBlockData(blockId, type, normalizedConfig);
                    }
                }
            }

            function getDefaultBlockConfig(type) {
                const color = DEFAULT_BLOCK_COLOR;
                switch (type) {
                    case 'music':
                        return { title: 'Музика', platform: 'spotify', url: '', note: '', color };
                    case 'weather':
                        return { title: 'Време', location: 'София, България', units: 'metric', color };
                    case 'checklist':
                        return { title: 'Чеклист', items: ['Задача 1', 'Задача 2'], color };
                    case 'calendar':
                        return { title: 'Календар', mode: 'link', url: '', color };
                    case 'reminder':
                        return { title: 'Напомняния', color };
                    case 'quote':
                        return { title: 'Мотивация', color };
                    case 'link':
                        return { title: 'Бърз линк', color };
                    default:
                        return { color };
                }
            }

            function populateBlockLibrary() {
                if (!blockLibraryGrid) return;
                blockLibraryGrid.innerHTML = '';

                // Duplicate templates so the gallery feels "full" and varied
                const templatesPool = [...LIBRARY_BLOCK_TEMPLATES, ...LIBRARY_BLOCK_TEMPLATES];
                const shuffledTemplates = templatesPool.sort(() => Math.random() - 0.5);

                shuffledTemplates.forEach((tpl, index) => {
                    const colorPair = LIBRARY_COLORS[index % LIBRARY_COLORS.length];
                    const blockEl = document.createElement('div');
                    const targetType = tpl.type || 'music';
                    const baseConfig = getDefaultBlockConfig(targetType);
                    const previewConfig = {
                        ...baseConfig,
                        color: colorPair ? colorPair.base : baseConfig.color
                    };
                    let extraSizeClass = '';
                    if (Math.random() < 0.5) {
                        extraSizeClass = ' tall';
                    }
                    blockEl.className = 'library-block' + extraSizeClass;
                    blockEl.dataset.blockType = targetType;
                    blockEl.setAttribute('role', 'button');
                    blockEl.setAttribute('tabindex', '0');
                    blockEl.setAttribute('draggable', 'true');
                    if (colorPair) {
                        blockEl.style.setProperty('--lib-color', colorPair.base);
                        blockEl.style.setProperty('--lib-color-soft', colorPair.soft);
                    }
                    // Store the exact config so dropped blocks match 1:1
                    try {
                        blockEl.dataset.blockConfig = JSON.stringify(previewConfig);
                    } catch (err) {}

                    // Use the real block content as a miniature preview so
                    // the widget looks the same as the one placed later.
                    const previewShell = document.createElement('div');
                    previewShell.className = 'library-block-inner';
                    const previewContent = createBlockContent(targetType, previewConfig);
                    previewContent.classList.add('library-preview-content');
                    previewShell.appendChild(previewContent);
                    blockEl.appendChild(previewShell);

                    const spawnBlockOnHomepage = () => {
                        if (!customBlocks || !editMode) return;
                        let config = previewConfig;
                        try {
                            if (blockEl.dataset.blockConfig) {
                                config = JSON.parse(blockEl.dataset.blockConfig);
                            }
                        } catch (err) {}
                        createNewBlock(targetType, config);
                    };

                    // Click or keyboard activation from the library creates a
                    // block directly on the homepage without opening any
                    // additional popups. Customisation happens later when the
                    // user clicks the placed block.
                    blockEl.addEventListener('click', (event) => {
                        // If this click immediately follows a drag, ignore it
                        // so we don't spawn a second block.
                        if (blockEl._wasDraggedRecently) return;
                        event.preventDefault();
                        event.stopPropagation();
                        spawnBlockOnHomepage();
                    });
                    blockEl.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter' || event.key === ' ') {
                            event.preventDefault();
                            spawnBlockOnHomepage();
                        }
                    });

                    blockEl.addEventListener('dragstart', (event) => {
                        if (!editMode) return;
                        blockEl._wasDraggedRecently = true;
                        setTimeout(() => { blockEl._wasDraggedRecently = false; }, 400);

                        libraryDragType = targetType;
                        libraryDragConfig = previewConfig;
                        // Shrink to compact shelf while dragging so more of
                        // the homepage stays visible.
                        setLibraryExpanded(false);
                        if (blockLibraryOverlay) {
                            blockLibraryOverlay.classList.add('dragging-out');
                        }
                        if (customBlocks) {
                            customBlocks.classList.add('show-grid');
                        }
                        if (event.dataTransfer) {
                            event.dataTransfer.effectAllowed = 'copy';
                            event.dataTransfer.setData('text/plain', 'block:' + libraryDragType);
                        }
                    });

                    blockEl.addEventListener('dragend', () => {
                        libraryDragType = null;
                        libraryDragConfig = null;
                        if (blockLibraryOverlay) {
                            blockLibraryOverlay.classList.remove('dragging-out');
                        }
                        if (customBlocks) {
                            customBlocks.classList.remove('show-grid');
                        }
                    });

                    blockLibraryGrid.appendChild(blockEl);
                });
            }

            function openBlockLibrary() {
                if (!blockLibraryOverlay || !editMode) return;
                populateBlockLibrary();
                // Start in compact "shelf" mode along the bottom edge so
                // the homepage remains mostly visible. The user can expand
                // to a larger window when needed.
                setLibraryExpanded(false);
                blockLibraryOverlay.classList.add('show');
            }

            function closeBlockLibrary() {
                if (!blockLibraryOverlay) return;
                setLibraryExpanded(false);
                blockLibraryOverlay.classList.remove('show');
            }

            function collectBuilderConfig(type) {
                if (!builderForm) return {};
                const color = builderColorInput ? normalizeColorValue(builderColorInput.value || DEFAULT_BLOCK_COLOR) : DEFAULT_BLOCK_COLOR;
                switch (type) {
                    case 'music': {
                        const title = builderForm.musicTitle.value.trim() || 'Музика';
                        const platform = builderForm.musicPlatform.value;
                        const url = builderForm.musicUrl.value.trim();
                        const note = builderForm.musicNote.value.trim();
                        return { title, platform, url, note, color };
                    }
                    case 'weather': {
                        const title = builderForm.weatherTitle.value.trim() || 'Време';
                        const location = builderForm.weatherLocation.value.trim();
                        const units = builderForm.weatherUnits.value;
                        return { title, location, units, color };
                    }
                    case 'checklist': {
                        const title = builderForm.checklistTitle.value.trim() || 'Чеклист';
                        const items = builderChecklistItems ? Array.from(builderChecklistItems.querySelectorAll('input[name="checklistItem"]')).map(input => input.value.trim()).filter(Boolean) : [];
                        if (!items.length) {
                            items.push('Нова задача');
                        }
                        return { title, items, color };
                    }
                    case 'calendar': {
                        const title = builderForm.calendarTitle.value.trim() || 'Календар';
                        const mode = builderForm.calendarMode.value || 'link';
                        const url = builderForm.calendarUrl.value.trim();
                        return { title, mode, url, color };
                    }
                    case 'reminder': {
                        const title = 'Напомняния';
                        return { title, color };
                    }
                    case 'quote': {
                        const title = 'Мотивация';
                        return { title, color };
                    }
                    case 'link': {
                        const title = 'Бърз линк';
                        return { title, color };
                    }
                    default:
                        return { color };
                }
            }

            if (addBlockBtn) {
                addBlockBtn.addEventListener('click', () => {
                    if (!editMode) return;
                    openBlockLibrary();
                });
            }

            builderTypeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const type = btn.getAttribute('data-builder-type');
                    if (builderLockedType && type !== builderLockedType) return;
                    setActiveBuilderType(type);
                });
            });

            if (builderColorInput) {
                builderColorInput.addEventListener('input', () => {
                    updateBuilderColorValue(builderColorInput.value || DEFAULT_BLOCK_COLOR);
                    scheduleBuilderPreviewUpdate();
                });
                updateBuilderColorValue(builderColorInput.value || DEFAULT_BLOCK_COLOR);

                // Apple-like малки цветни точки за бърз избор
                const paletteColors = ['#4D7CFF', '#FF7C7C', '#FFB74D', '#34C759', '#A855F7', '#00C7BE'];
                const row = builderColorInput.parentElement;
                if (row) {
                    const palette = document.createElement('div');
                    palette.className = 'builder-color-palette';
                    paletteColors.forEach(hex => {
                        const dot = document.createElement('button');
                        dot.type = 'button';
                        dot.className = 'builder-color-dot';
                        dot.style.background = hex;
                        dot.addEventListener('click', () => {
                            builderColorInput.value = hex;
                            updateBuilderColorValue(hex);
                            scheduleBuilderPreviewUpdate();
                        });
                        palette.appendChild(dot);
                    });
                    row.appendChild(palette);
                }
            }

            if (builderForm) {
                builderForm.addEventListener('input', scheduleBuilderPreviewUpdate);
                builderForm.addEventListener('change', scheduleBuilderPreviewUpdate);
            }

            if (builderAddChecklistItemBtn) {
                builderAddChecklistItemBtn.addEventListener('click', () => {
                    addBuilderChecklistItem('');
                    if (builderChecklistItems) {
                        const lastInput = builderChecklistItems.querySelector('.builder-checklist-item:last-child input');
                        if (lastInput) {
                            lastInput.focus();
                        }
                    }
                });
            }

            if (builderChecklistItems) {
                builderChecklistItems.addEventListener('click', (e) => {
                    const removeBtn = e.target.closest('.builder-remove-item');
                    if (!removeBtn) return;
                    e.preventDefault();
                    const row = removeBtn.closest('.builder-checklist-item');
                    if (!row) return;
                    if (builderChecklistItems.children.length > 1) {
                        row.remove();
                    } else {
                        const input = row.querySelector('input');
                        if (input) input.value = '';
                    }
                });

                // AI довършване за елементи от чеклиста
                builderChecklistItems.addEventListener('input', (e) => {
                    const input = e.target.closest('input[name="checklistItem"]');
                    if (!input) return;
                    if (typeof maybeScheduleChecklistAI === 'function') {
                        maybeScheduleChecklistAI(input);
                    }
                });
            }

            if (checklistTitleInput) {
                checklistTitleInput.addEventListener('input', () => {
                    if (typeof maybeScheduleChecklistAI === 'function') {
                        maybeScheduleChecklistAI(checklistTitleInput);
                    }
                });
            }

            if (checklistAiToggle) {
                checklistAiToggle.addEventListener('change', () => {
                    checklistAIEnabled = checklistAiToggle.checked;
                    window.checklistAIEnabled = checklistAIEnabled;
                });
            }

            if (builderCancelBtn) {
                builderCancelBtn.addEventListener('click', closeBlockBuilder);
            }

            if (builderCloseBtn) {
                builderCloseBtn.addEventListener('click', closeBlockBuilder);
            }

            if (blockBuilderModal) {
                blockBuilderModal.addEventListener('click', (e) => {
                    if (e.target === blockBuilderModal) {
                        closeBlockBuilder();
                    }
                });
            }

            if (builderForm) {
                builderForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    if (!builderForm.reportValidity()) return;
                    const targetType = builderLockedType || activeBuilderType;
                    const config = collectBuilderConfig(targetType);

                    if (builderEditingBlock) {
                        applyConfigToExistingBlock(builderEditingBlock, targetType, config);
                    } else {
                        createNewBlock(targetType, config);
                    }
                    closeBlockBuilder();
                });
            }

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (blockBuilderModal && blockBuilderModal.classList.contains('show')) {
                        closeBlockBuilder();
                    }
                    if (blockLibraryOverlay && blockLibraryOverlay.classList.contains('show')) {
                        closeBlockLibrary();
                    }
                }
            });

            if (blockBuilderModal) {
                setActiveBuilderType(activeBuilderType);
            }

            if (blockLibraryOverlay) {
                // Clicking on the dimmed area outside the panel closes it.
                blockLibraryOverlay.addEventListener('click', (e) => {
                    if (e.target === blockLibraryOverlay) {
                        closeBlockLibrary();
                    }
                });
            }

            // Expanded mode disabled: keep only the compact shelf.

            if (blockLibraryCloseBtn) {
                blockLibraryCloseBtn.addEventListener('click', () => {
                    closeBlockLibrary();
                });
            }

            restoreSavedCustomBlocks();
            applyRemovedDefaultBlocks();
            blocks = document.querySelectorAll('.custom-block');
            updateContainerHeight();

            // Allow dropping a widget almost anywhere on the homepage.
            document.addEventListener('dragover', (event) => {
                if (!libraryDragType) return;
                event.preventDefault();
                // Auto-scroll the page while dragging near viewport edges
                const edge = 80;
                if (event.clientY > window.innerHeight - edge) {
                    window.scrollBy({ top: 24, behavior: 'smooth' });
                } else if (event.clientY < edge) {
                    window.scrollBy({ top: -24, behavior: 'smooth' });
                }

                // Show the edit grid only when dragging over the custom blocks area
                if (customBlocks) {
                    const rect = customBlocks.getBoundingClientRect();
                    const overHomepage =
                        event.clientX >= rect.left &&
                        event.clientX <= rect.right &&
                        event.clientY >= rect.top &&
                        event.clientY <= rect.bottom;
                    customBlocks.classList.toggle('show-grid', overHomepage);
                }
                if (event.dataTransfer) {
                    event.dataTransfer.dropEffect = 'copy';
                }
            });

            document.addEventListener('drop', (event) => {
                if (!libraryDragType || !customBlocks) return;
                event.preventDefault();
                // Hide the grid once the drop is finished
                customBlocks.classList.remove('show-grid');
                if (blockLibraryOverlay) {
                    blockLibraryOverlay.classList.remove('dragging-out');
                }
                const type = libraryDragType;
                const dragConfig = libraryDragConfig;
                libraryDragType = null;
                libraryDragConfig = null;
                const rect = customBlocks.getBoundingClientRect();
                let dropLeft = event.clientX - rect.left - 140;
                let dropTop = event.clientY - rect.top - 90;

                // Clamp drop position so we never spawn blocks at absurd
                // coordinates that would explode the layout height.
                if (!Number.isFinite(dropLeft)) dropLeft = 0;
                if (!Number.isFinite(dropTop)) dropTop = 0;
                dropLeft = Math.max(0, Math.min(dropLeft, rect.width - 200));
                dropTop = Math.max(0, Math.min(dropTop, MAX_CONTAINER_HEIGHT - 260));

                const config = dragConfig || getDefaultBlockConfig(type);
                createNewBlock(type, config, {
                    position: { left: dropLeft, top: dropTop }
                });
            });

            // Create ResizeObserver for monitoring resize operations
            if (window.ResizeObserver) {
                resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        const block = entry.target;
                        if (block.classList.contains('edit-mode')) {
                            handleBlockResize(block, entry);
                        }
                    }
                });
            }

            function handleBlockResize(block, entry) {
                if (!isResizing) {
                    isResizing = true;
                    customBlocks.classList.add('resizing-active');
                    block.classList.add('resizing');
                    
                    // Clear any existing timeout
                    if (block.resizeTimeout) {
                        clearTimeout(block.resizeTimeout);
                    }
                    
                    // Ultra-smooth resize completion with longer debounce
                    block.resizeTimeout = setTimeout(() => {
                        isResizing = false;
                        customBlocks.classList.remove('resizing-active');
                        block.classList.remove('resizing');
                        
                        // Check for collisions and adjust if needed
                        const blockLeft = parseFloat(block.style.left) || block.offsetLeft || 0;
                        const blockTop = parseFloat(block.style.top) || block.offsetTop || 0;
                        const currentWidth = block.offsetWidth;
                        const currentHeight = block.offsetHeight;
                        
                        if (checkCollisionWithSize(block, blockLeft, blockTop, currentWidth, currentHeight)) {
                            adjustBlockSizeAfterResize(block);
                        } else {
                            // Smooth collision indicator removal
                            block.style.transition = 'all 0.3s ease';
                            block.classList.remove('collision');
                            setTimeout(() => {
                                block.style.transition = '';
                            }, 300);
                        }
                        
                        // Save resize dimensions
                        saveBlockDimensions(block);
                    }, 600); // Longer timeout for ultra-smooth experience
                }

                // Enhanced adaptive minimum dimensions with better responsive scaling
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const minWidth = Math.max(220, Math.min(300, viewportWidth * 0.28));
                const minHeight = Math.max(140, Math.min(200, viewportHeight * 0.18));
                
                const currentWidth = block.offsetWidth;
                const currentHeight = block.offsetHeight;
                
                // Smooth enforcement of minimum dimensions
                if (currentWidth < minWidth - 15 || currentHeight < minHeight - 15) {
                    requestAnimationFrame(() => {
                        block.style.transition = 'width 0.2s ease, height 0.2s ease';
                        if (currentWidth < minWidth - 15) {
                            block.style.width = minWidth + 'px';
                        }
                        if (currentHeight < minHeight - 15) {
                            block.style.height = minHeight + 'px';
                        }
                        setTimeout(() => {
                            block.style.transition = '';
                        }, 200);
                    });
                }
            }

            function saveBlockDimensions(block) {
                const blockId = block.getAttribute('data-block-id');
                const rect = block.getBoundingClientRect();
                const dimensions = {
                    width: block.offsetWidth + 'px',
                    height: block.offsetHeight + 'px'
                };
                
                // Save to localStorage
                const savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}');
                savedDimensions[blockId] = dimensions;
                localStorage.setItem('blockDimensions', JSON.stringify(savedDimensions));
                
                // Update container height if block is near the bottom
                const blockTop = parseInt(block.style.top) || 0;
                const blockBottom = blockTop + block.offsetHeight;
                const currentMinHeight = parseFloat(getComputedStyle(customBlocks).minHeight) || 600;
                // Respect the global safety cap so resizes can't explode layout height
                const targetHeight = Math.min(blockBottom + 100, MAX_CONTAINER_HEIGHT);
                if (targetHeight > currentMinHeight) {
                    customBlocks.style.minHeight = targetHeight + 'px';
                }
            }

            function storeOriginalDimensions() {
                // Store current dimensions before entering edit mode
                blocks.forEach(block => {
                    const blockId = block.getAttribute('data-block-id');
                    const rect = block.getBoundingClientRect();
                    const containerRect = customBlocks.getBoundingClientRect();
                    
                    originalDimensions.set(blockId, {
                        width: block.offsetWidth,
                        height: block.offsetHeight,
                        computedWidth: getComputedStyle(block).width,
                        computedHeight: getComputedStyle(block).height
                    });
                    
                    // Store relative position within the container
                    originalPositions.set(blockId, {
                        left: rect.left - containerRect.left,
                        top: rect.top - containerRect.top
                    });
                });
            }

            function restoreOriginalLayout() {
                // Don't restore to grid layout - maintain absolute positioning with saved positions
                blocks.forEach(block => {
                    const blockId = block.getAttribute('data-block-id');
                    
                    // Keep absolute positioning but remove edit-specific styling
                    block.style.position = 'absolute';
                    // Don't clear left and top - keep the positions!
                    block.style.zIndex = '1';
                    
                    // Restore saved dimensions if they exist
                    const savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}');
                    if (savedDimensions[blockId]) {
                        block.style.width = savedDimensions[blockId].width;
                        block.style.height = savedDimensions[blockId].height;
                    }
                });
            }

            function snapToGrid(value) {
                return Math.round(value * 100) / 100;
            }

            // Collision detection and prevention functions
            function getBlockBounds(block) {
                const left = parseFloat(block.style.left) || block.offsetLeft || 0;
                const top = parseFloat(block.style.top) || block.offsetTop || 0;
                const width = block.offsetWidth || parseFloat(block.style.width) || 280;
                const height = block.offsetHeight || parseFloat(block.style.height) || 180;
                
                return {
                    left: left,
                    top: top,
                    right: left + width,
                    bottom: top + height,
                    width: width,
                    height: height
                };
            }

            function blocksOverlap(bounds1, bounds2) {
                // Add small margin to prevent blocks from touching
                const margin = 10;
                return !(bounds1.right + margin <= bounds2.left || 
                        bounds2.right + margin <= bounds1.left || 
                        bounds1.bottom + margin <= bounds2.top || 
                        bounds2.bottom + margin <= bounds1.top);
            }

            function checkCollision(targetBlock, newLeft, newTop) {
                const targetBounds = {
                    left: newLeft,
                    top: newTop,
                    right: newLeft + (targetBlock.offsetWidth || 280),
                    bottom: newTop + (targetBlock.offsetHeight || 180),
                    width: targetBlock.offsetWidth || 280,
                    height: targetBlock.offsetHeight || 180
                };

                // Check against all other blocks
                for (let block of blocks) {
                    if (block === targetBlock) continue;
                    
                    const blockBounds = getBlockBounds(block);
                    if (blocksOverlap(targetBounds, blockBounds)) {
                        return true; // Collision detected
                    }
                }
                return false; // No collision
            }

            function checkCollisionWithSize(targetBlock, left, top, width, height) {
                const targetBounds = {
                    left: left,
                    top: top,
                    right: left + width,
                    bottom: top + height,
                    width: width,
                    height: height
                };

                // Check against all other blocks
                for (let block of blocks) {
                    if (block === targetBlock) continue;
                    
                    const blockBounds = getBlockBounds(block);
                    if (blocksOverlap(targetBounds, blockBounds)) {
                        return true; // Collision detected
                    }
                }
                return false; // No collision
            }

            function adjustBlockAfterResize(block) {
                const currentLeft = parseFloat(block.style.left) || block.offsetLeft || 0;
                const currentTop = parseFloat(block.style.top) || block.offsetTop || 0;
                const currentWidth = block.offsetWidth;
                const currentHeight = block.offsetHeight;
                
                // Try to find a position where the new size doesn't cause overlap
                const containerWidth = customBlocks.offsetWidth;
                const containerHeight = parseInt(getComputedStyle(customBlocks).minHeight, 10) || 600;
                
                // First try moving the block slightly in different directions
                const adjustments = [
                    { dx: 0, dy: 0 }, // Current position
                    { dx: gridSize, dy: 0 }, // Right
                    { dx: -gridSize, dy: 0 }, // Left
                    { dx: 0, dy: gridSize }, // Down
                    { dx: 0, dy: -gridSize }, // Up
                    { dx: gridSize, dy: gridSize }, // Down-right
                    { dx: -gridSize, dy: -gridSize }, // Up-left
                    { dx: gridSize, dy: -gridSize }, // Up-right
                    { dx: -gridSize, dy: gridSize }, // Down-left
                ];
                
                for (let adj of adjustments) {
                    const newLeft = currentLeft + adj.dx;
                    const newTop = currentTop + adj.dy;
                    
                    // Check bounds
                    if (newLeft >= 0 && newTop >= 0 && 
                        newLeft + currentWidth <= containerWidth &&
                        newTop + currentHeight <= containerHeight + 200) {
                        
                        if (!checkCollisionWithSize(block, newLeft, newTop, currentWidth, currentHeight)) {
                            // Found a good position
                            block.style.transition = 'all 0.3s cubic-bezier(0.2, 0.9, 0.3, 1)';
                            block.style.left = snapToGrid(newLeft) + 'px';
                            block.style.top = snapToGrid(newTop) + 'px';
                            
                            setTimeout(() => {
                                block.style.transition = '';
                                block.classList.remove('collision');
                                saveBlockPosition(block);
                            }, 300);
                            return;
                        }
                    }
                }
                
                // If no nearby position works, try to reduce the size slightly
                const maxAttempts = 5;
                for (let i = 1; i <= maxAttempts; i++) {
                    const reducedWidth = currentWidth - (i * 20);
                    const reducedHeight = currentHeight - (i * 15);
                    
                    // Don't make it too small
                    const minWidth = Math.max(250, Math.min(280, window.innerWidth * 0.35));
                    const minHeight = Math.max(160, Math.min(180, window.innerHeight * 0.2));
                    
                    if (reducedWidth >= minWidth && reducedHeight >= minHeight) {
                        if (!checkCollisionWithSize(block, currentLeft, currentTop, reducedWidth, reducedHeight)) {
                            // Reduce size to prevent overlap
                            block.style.transition = 'all 0.3s cubic-bezier(0.2, 0.9, 0.3, 1)';
                            block.style.width = reducedWidth + 'px';
                            block.style.height = reducedHeight + 'px';
                            
                            setTimeout(() => {
                                block.style.transition = '';
                                block.classList.remove('collision');
                                saveBlockDimensions(block);
                            }, 300);
                            return;
                        }
                    }
                }
                
                // If nothing works, just remove the collision visual feedback
                setTimeout(() => {
                    block.classList.remove('collision');
                }, 1000);
            }

            function calculateResizeConstraints(targetBlock, blockLeft, blockTop) {
                const containerWidth = customBlocks.offsetWidth;
                const containerHeight = parseFloat(getComputedStyle(customBlocks).minHeight) || 600;
                
                // Calculate maximum possible dimensions based on container bounds
                let maxWidth = containerWidth - blockLeft;
                let maxHeight = containerHeight - blockTop + 200; // Allow some extension
                
                // Check collision constraints with other blocks
                for (let block of blocks) {
                    if (block === targetBlock) continue;
                    
                    const otherBounds = getBlockBounds(block);
                    
                    // If other block is to the right, limit width
                    if (otherBounds.left > blockLeft && otherBounds.top < blockTop + 200 && otherBounds.bottom > blockTop) {
                        const availableWidth = Math.max(0, otherBounds.left - blockLeft - 10); // 10px margin
                        maxWidth = Math.min(maxWidth, availableWidth);
                    }
                    
                    // If other block is below, limit height
                    if (otherBounds.top > blockTop && otherBounds.left < blockLeft + 200 && otherBounds.right > blockLeft) {
                        const availableHeight = Math.max(0, otherBounds.top - blockTop - 10); // 10px margin
                        maxHeight = Math.min(maxHeight, availableHeight);
                    }
                }
                
                // Ensure minimum dimensions
                const minWidth = Math.max(250, Math.min(280, window.innerWidth * 0.35));
                const minHeight = Math.max(160, Math.min(180, window.innerHeight * 0.2));
                
                return {
                    maxWidth: Math.max(minWidth, maxWidth),
                    maxHeight: Math.max(minHeight, maxHeight),
                    minWidth: minWidth,
                    minHeight: minHeight
                };
            }

            function findMaxValidSize(targetBlock, blockLeft, blockTop, constraints) {
                const currentWidth = targetBlock.offsetWidth;
                const currentHeight = targetBlock.offsetHeight;
                
                // Start from current size and work backwards to find valid size
                let testWidth = currentWidth;
                let testHeight = currentHeight;
                
                // First, ensure we're within container bounds
                testWidth = Math.min(testWidth, constraints.maxWidth);
                testHeight = Math.min(testHeight, constraints.maxHeight);
                
                // Binary search approach for width
                let validWidth = constraints.minWidth;
                let minW = constraints.minWidth;
                let maxW = testWidth;
                
                while (maxW - minW > 5) {
                    const midW = Math.floor((minW + maxW) / 2);
                    if (!checkCollisionWithSize(targetBlock, blockLeft, blockTop, midW, testHeight)) {
                        validWidth = midW;
                        minW = midW;
                    } else {
                        maxW = midW - 1;
                    }
                }
                
                // Binary search approach for height
                let validHeight = constraints.minHeight;
                let minH = constraints.minHeight;
                let maxH = testHeight;
                
                while (maxH - minH > 5) {
                    const midH = Math.floor((minH + maxH) / 2);
                    if (!checkCollisionWithSize(targetBlock, blockLeft, blockTop, validWidth, midH)) {
                        validHeight = midH;
                        minH = midH;
                    } else {
                        maxH = midH - 1;
                    }
                }
                
                return {
                    width: Math.max(validWidth, constraints.minWidth),
                    height: Math.max(validHeight, constraints.minHeight)
                };
            }

            function adjustBlockSizeAfterResize(block) {
                const currentLeft = parseFloat(block.style.left) || block.offsetLeft || 0;
                const currentTop = parseFloat(block.style.top) || block.offsetTop || 0;
                const currentWidth = block.offsetWidth;
                const currentHeight = block.offsetHeight;
                
                // Calculate constraints based on current position
                const constraints = calculateResizeConstraints(block, currentLeft, currentTop);
                
                // Find the maximum valid size that doesn't cause overlap
                const validSize = findMaxValidSize(block, currentLeft, currentTop, constraints);
                
                // Only adjust if the current size exceeds valid limits
                let needsAdjustment = false;
                let targetWidth = currentWidth;
                let targetHeight = currentHeight;
                
                if (currentWidth > validSize.width) {
                    targetWidth = validSize.width;
                    needsAdjustment = true;
                }
                
                if (currentHeight > validSize.height) {
                    targetHeight = validSize.height;
                    needsAdjustment = true;
                }
                
                if (needsAdjustment) {
                    // Ultra-smooth animation with enhanced easing
                    block.style.transition = 'all 0.6s cubic-bezier(0.15, 0.85, 0.3, 1)';
                    block.style.width = targetWidth + 'px';
                    block.style.height = targetHeight + 'px';
                    
                    // Enhanced cleanup with smooth collision removal
                    setTimeout(() => {
                        if (block) {
                            block.style.transition = '';
                            // Gentle collision indicator fade-out
                            if (block.classList.contains('collision')) {
                                block.style.opacity = '0.95';
                                setTimeout(() => {
                                    block.classList.remove('collision');
                                    block.style.opacity = '';
                                }, 100);
                            }
                            saveBlockDimensions(block);
                        }
                    }, 600);
                } else {
                    // Smooth collision indicator removal without size change
                    if (block.classList.contains('collision')) {
                        block.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                        block.style.opacity = '0.98';
                        setTimeout(() => {
                            block.classList.remove('collision');
                            block.style.transition = '';
                            block.style.opacity = '';
                        }, 300);
                    }
                }
            }

            function findFreePosition(targetBlock, preferredLeft, preferredTop) {
                const containerWidth = customBlocks.offsetWidth;
                const containerHeight = parseInt(getComputedStyle(customBlocks).minHeight) || 600;
                const blockWidth = targetBlock.offsetWidth || 280;
                const blockHeight = targetBlock.offsetHeight || 180;
                
                // Start from preferred position and spiral outward to find free space
                const maxSteps = 50; // Limit search to prevent infinite loops
                let stepSize = gridSize;
                
                // Try the preferred position first
                if (!checkCollision(targetBlock, preferredLeft, preferredTop)) {
                    return { left: preferredLeft, top: preferredTop };
                }
                
                // Spiral search pattern
                for (let step = 1; step <= maxSteps; step++) {
                    const positions = [
                        // Try positions around the preferred location
                        { left: preferredLeft + step * stepSize, top: preferredTop },
                        { left: preferredLeft - step * stepSize, top: preferredTop },
                        { left: preferredLeft, top: preferredTop + step * stepSize },
                        { left: preferredLeft, top: preferredTop - step * stepSize },
                        { left: preferredLeft + step * stepSize, top: preferredTop + step * stepSize },
                        { left: preferredLeft - step * stepSize, top: preferredTop - step * stepSize },
                        { left: preferredLeft + step * stepSize, top: preferredTop - step * stepSize },
                        { left: preferredLeft - step * stepSize, top: preferredTop + step * stepSize }
                    ];
                    
                    for (let pos of positions) {
                        // Check if position is within bounds
                        if (pos.left >= 0 && pos.top >= 0 && 
                            pos.left + blockWidth <= containerWidth &&
                            pos.top + blockHeight <= containerHeight + 200) { // Allow some extension
                            
                            if (!checkCollision(targetBlock, pos.left, pos.top)) {
                                return { left: snapToGrid(pos.left), top: snapToGrid(pos.top) };
                            }
                        }
                    }
                }
                
                // If no free position found, try to place at the bottom
                let bottomY = 0;
                blocks.forEach(block => {
                    if (block !== targetBlock) {
                        const bounds = getBlockBounds(block);
                        bottomY = Math.max(bottomY, bounds.bottom + 20);
                    }
                });
                
                return { 
                    left: snapToGrid(Math.min(preferredLeft, containerWidth - blockWidth)), 
                    top: snapToGrid(bottomY) 
                };
            }

            // Update grid size on window resize
            function updateGridSize() {
                const newGridSize = getGridSize();
                if (newGridSize !== gridSize) {
                    gridSize = newGridSize;
                    
                    // Update CSS custom property for grid size if in edit mode
                    if (editMode) {
                        document.documentElement.style.setProperty('--dynamic-grid-size', gridSize + 'px');
                    }
                }
            }

            // Adaptive block resizing function
            function adaptBlockSizes() {
                blocks.forEach(block => {
                    const blockId = block.getAttribute('data-block-id');
                    const savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}');
                    
                    // Only adapt if no custom dimensions are saved
                    if (!savedDimensions[blockId]) {
                        const containerWidth = customBlocks.offsetWidth;
                        const adaptiveWidth = Math.max(250, Math.min(320, containerWidth * 0.4));
                        const adaptiveHeight = Math.max(160, Math.min(220, window.innerHeight * 0.25));
                        
                        block.style.width = adaptiveWidth + 'px';
                        block.style.height = adaptiveHeight + 'px';
                    }
                });
                
                updateContainerHeight();
            }

            // Enhanced window resize handler
            function handleWindowResize() {
                updateGridSize();
                adaptBlockSizes();
                
                // Reposition blocks if they're out of bounds
                blocks.forEach(block => {
                    const left = parseFloat(block.style.left) || block.offsetLeft || 0;
                    const top = parseFloat(block.style.top) || block.offsetTop || 0;
                    const limited = enforceScreenLimits(block, left, top);
                    
                    if (limited.left !== left || limited.top !== top) {
                        block.style.left = limited.left + 'px';
                        block.style.top = limited.top + 'px';
                        saveBlockPosition(block);
                    }
                });
            }

            // Listen for window resize with debouncing
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(handleWindowResize, 150);
            });

            function enforceScreenLimits(block, left, top) {
                const containerRect = customBlocks.getBoundingClientRect();
                const blockWidth = block.offsetWidth;
                
                // Only enforce horizontal limits - allow controlled vertical movement
                const maxLeft = containerRect.width - blockWidth;
                
                left = Math.max(0, Math.min(left, maxLeft));
                top = Math.max(0, Math.min(top, MAX_CONTAINER_HEIGHT - block.offsetHeight - 100));
                
                // Dynamically expand container height if needed, but never
                // beyond the safety cap.
                const blockBottom = top + block.offsetHeight;
                const currentMinHeight = parseInt(getComputedStyle(customBlocks).minHeight) || 600;
                const targetHeight = Math.min(blockBottom + 100, MAX_CONTAINER_HEIGHT);
                if (targetHeight > currentMinHeight) {
                    customBlocks.style.minHeight = targetHeight + 'px';
                }
                
                return { left, top };
            }

            function loadBlockDimensions() {
                const savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}');
                
                blocks.forEach(block => {
                    const blockId = block.getAttribute('data-block-id');
                    if (savedDimensions[blockId]) {
                        const dims = savedDimensions[blockId];
                        if (dims.width) block.style.width = dims.width;
                        if (dims.height) block.style.height = dims.height;
                    }
                });
            }

            function loadBlockPositions() {
                const savedPositions = JSON.parse(localStorage.getItem('blockPositions') || '{}');
                
                blocks.forEach((block, index) => {
                    const blockId = block.getAttribute('data-block-id');
                    if (savedPositions[blockId]) {
                        // Use saved positions
                        const pos = savedPositions[blockId];
                        const savedLeft = parseFloat(pos.left);
                        const savedTop = parseFloat(pos.top);
                        block.style.left = (Number.isNaN(savedLeft) ? 0 : savedLeft) + 'px';
                        block.style.top = (Number.isNaN(savedTop) ? 0 : savedTop) + 'px';
                    } else {
                        // Initialize with adaptive grid-like positions
                        const containerWidth = customBlocks.offsetWidth;
                        const blockWidth = Math.max(280, Math.min(320, containerWidth * 0.4)); // Adaptive block width
                        const blockHeight = Math.max(180, Math.min(220, window.innerHeight * 0.25)); // Adaptive block height
                        
                        const cols = Math.floor(containerWidth / (blockWidth + gridSize));
                        const row = Math.floor(index / Math.max(1, cols));
                        const col = index % Math.max(1, cols);
                        
                        block.style.left = snapToGrid(col * (blockWidth + gridSize)) + 'px';
                        block.style.top = snapToGrid(row * (blockHeight + gridSize)) + 'px';
                        
                        // Save the initial position
                        saveBlockPosition(block);
                    }
                });
                
                // Update container height to fit all blocks
                updateContainerHeight();
            }

            function updateContainerHeight() {
                let maxBottom = 600; // minimum height
                blocks.forEach(block => {
                    let top = parseFloat(block.style.top);
                    if (!Number.isFinite(top) || top < 0) top = 0;
                    let height = block.offsetHeight || 180;
                    if (!Number.isFinite(height) || height <= 0) height = 180;
                    let bottom = top + height;
                    if (!Number.isFinite(bottom)) bottom = 600;
                    if (bottom > maxBottom) {
                        maxBottom = bottom;
                    }
                });
                // Hard cap container height for stability
                maxBottom = Math.min(maxBottom, MAX_CONTAINER_HEIGHT - 50);
                customBlocks.style.minHeight = (maxBottom + 50) + 'px';
            }

            // Toggle edit mode
            editBtn.addEventListener('click', () => {
                editMode = !editMode;
                toggleEditMode();
            });

            if (removeAllBtn) {
                removeAllBtn.disabled = true;
                removeAllBtn.addEventListener('click', () => {
                    if (!editMode) return;
                    removeAllPlacedBlocks();
                });
            }

            function toggleEditMode() {
                if (editMode) {
                    // Store original dimensions and positions before entering edit mode
                    storeOriginalDimensions();
                    
                    // Update grid size for current viewport
                    updateGridSize();
                    
                    editBtn.classList.add('active');
                    editBtn.innerHTML = '<span>Готово</span>';
                    if (removeAllBtn) {
                        removeAllBtn.disabled = false;
                    }
                    customBlocks.classList.add('edit-mode');
                    if (addBlockBtn) {
                        addBlockBtn.classList.add('visible');
                    }
                    
                    // Convert to absolute positioning
                    blocks.forEach((block, index) => {
                        const blockId = block.getAttribute('data-block-id');
                        block.classList.add('edit-mode');
                        enableDragAndDrop(block);
                        enableResizeMonitoring(block);
                        
                        // Positions are already loaded, just ensure they have explicit values
                        if (!block.style.left || !block.style.top) {
                            // Only set if not already positioned
                            const savedPositions = JSON.parse(localStorage.getItem('blockPositions') || '{}');
                            if (savedPositions[blockId]) {
                                block.style.left = savedPositions[blockId].left + 'px';
                                block.style.top = savedPositions[blockId].top + 'px';
                            }
                        }
                        
                        // Apply saved dimensions if not already set
                        const savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}');
                        if (savedDimensions[blockId] && (!block.style.width || !block.style.height)) {
                            block.style.width = savedDimensions[blockId].width;
                            block.style.height = savedDimensions[blockId].height;
                        }
                    });

                    // Open the widget library automatically when entering edit mode
                    openBlockLibrary();
                } else {
                    editBtn.classList.remove('active');
                    editBtn.innerHTML = '<span>Редактиране</span>';
                    if (removeAllBtn) {
                        removeAllBtn.disabled = true;
                    }
                    
                    // Add exit animation class
                    customBlocks.classList.add('edit-mode-exit');
                    if (addBlockBtn) {
                        addBlockBtn.classList.remove('visible');
                    }
                    closeBlockBuilder();
                    closeBlockLibrary();
                    
                    // Wait for animation and then clean up
                    setTimeout(() => {
                        customBlocks.classList.remove('edit-mode', 'edit-mode-exit', 'resizing-active');
                        
                        // Don't reset container height - keep it based on block positions
                        updateContainerHeight();
                        
                        blocks.forEach(block => {
                            block.classList.remove('edit-mode', 'resizing', 'snapping');
                            disableDragAndDrop(block);
                            disableResizeMonitoring(block);
                        });
                        
                        // Restore layout but keep positions
                        restoreOriginalLayout();
                        
                        // Clean up any resize timeouts
                        blocks.forEach(block => {
                            if (block.resizeTimeout) {
                                clearTimeout(block.resizeTimeout);
                                delete block.resizeTimeout;
                            }
                        });
                    }, 300);
                }
            }

            async function removeAllPlacedBlocks() {
                if (!customBlocks) return;

                const blockEls = Array.from(customBlocks.querySelectorAll('.custom-block'));
                if (!blockEls.length) return;

                const removedDefault = new Set(getRemovedDefaultBlocks());
                const customData = getCustomBlocksData();

                let savedPositions = {};
                let savedDimensions = {};
                try {
                    savedPositions = JSON.parse(localStorage.getItem('blockPositions') || '{}') || {};
                } catch (err) {
                    savedPositions = {};
                }
                try {
                    savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}') || {};
                } catch (err) {
                    savedDimensions = {};
                }

                blockEls.forEach(block => {
                    const blockId = block.getAttribute('data-block-id');
                    if (!blockId) return;

                    if (isDefaultBlock(block)) {
                        removedDefault.add(blockId);
                    } else if (customData[blockId]) {
                        delete customData[blockId];
                    }

                    if (savedPositions[blockId]) delete savedPositions[blockId];
                    if (savedDimensions[blockId]) delete savedDimensions[blockId];
                });

                // Persist local state once.
                localStorage.setItem(REMOVED_DEFAULT_BLOCKS_KEY, JSON.stringify(Array.from(removedDefault)));
                localStorage.setItem(CUSTOM_BLOCKS_STORAGE_KEY, JSON.stringify(customData));
                localStorage.setItem('blockPositions', JSON.stringify(savedPositions));
                localStorage.setItem('blockDimensions', JSON.stringify(savedDimensions));

                // Remove from DOM.
                blockEls.forEach(block => block.remove());
                blocks = document.querySelectorAll('.custom-block');
                updateContainerHeight();

                // Best-effort: remove from Supabase so blocks don't come back on refresh.
                try {
                    const sb = window.supabaseClient;
                    if (sb) {
                        const { data: { user } } = await sb.auth.getUser();
                        if (user) {
                            await sb.from('user_blocks').delete().eq('user_id', user.id);
                        }
                    }
                } catch (err) {
                    console.warn('Remove-all cloud cleanup failed:', err);
                }
            }

            function enableResizeMonitoring(block) {
                if (resizeObserver) {
                    resizeObserver.observe(block);
                }
                
                // Add mouse events for resize detection
                block.addEventListener('mousedown', handleResizeStart);
            }

            function disableResizeMonitoring(block) {
                if (resizeObserver) {
                    resizeObserver.unobserve(block);
                }
                
                block.removeEventListener('mousedown', handleResizeStart);
            }

            function handleResizeStart(e) {
                const block = e.target.closest('.custom-block');
                if (!block || !block.classList.contains('edit-mode')) return;
                
                const rect = block.getBoundingClientRect();
                const isResizeArea = e.clientX > rect.right - 20 && e.clientY > rect.bottom - 20;
                
                if (isResizeArea) {
                    // Ultra smooth transition into resize mode
                    block.style.transition = 'border-color 0.3s ease, background 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease';
                    customBlocks.classList.add('resizing-active');
                    block.classList.add('resizing');
                    
                    // Store current collision state to prevent flickering
                    let currentCollisionState = block.classList.contains('collision');
                    
                    // Stable collision checking - only update when state actually changes
                    const resizeMonitor = setInterval(() => {
                        const blockLeft = parseFloat(block.style.left) || block.offsetLeft || 0;
                        const blockTop = parseFloat(block.style.top) || block.offsetTop || 0;
                        const hasCollision = checkCollisionWithSize(block, blockLeft, blockTop, block.offsetWidth, block.offsetHeight);
                        
                        // Only update if collision state actually changed
                        if (hasCollision !== currentCollisionState) {
                            currentCollisionState = hasCollision;
                            if (hasCollision) {
                                block.classList.add('collision');
                            } else {
                                block.classList.remove('collision');
                            }
                        }
                    }, 100); // Stable, less frequent checking
                    
                    // Add mouse up listener to clean up resize state
                    const cleanup = () => {
                        clearInterval(resizeMonitor);
                        block.style.transition = '';
                        block.classList.remove('collision'); // Always clear on resize end
                        document.removeEventListener('mouseup', cleanup);
                    };
                    document.addEventListener('mouseup', cleanup);
                }
            }

            function enableDragAndDrop(block) {
                // Use mouse events for better control in absolute positioning
                block.addEventListener('mousedown', handleMouseDown);
            }

            function disableDragAndDrop(block) {
                block.removeEventListener('mousedown', handleMouseDown);
            }

            function handleMouseDown(e) {
                const block = e.target.closest('.custom-block');
                if (!block || !block.classList.contains('edit-mode')) return;
                
                const rect = block.getBoundingClientRect();
                const containerRect = customBlocks.getBoundingClientRect();
                
                // Check if clicking on resize handle
                const isResizeArea = e.clientX > rect.right - 20 && e.clientY > rect.bottom - 20;
                if (isResizeArea) return;
                
                e.preventDefault();

                if (customBlocks) {
                    customBlocks.classList.add('show-grid');
                }
                
                draggedElement = block;
                block.classList.add('dragging');
                
                // Calculate offset from mouse to block position
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            }

            function handleMouseMove(e) {
                if (!draggedElement) return;
                
                e.preventDefault();
                
                const containerRect = customBlocks.getBoundingClientRect();
                
                // Calculate new position relative to container
                let newLeft = e.clientX - containerRect.left - dragOffset.x;
                let newTop = e.clientY - containerRect.top - dragOffset.y;
                
                // Snap to grid
                newLeft = snapToGrid(newLeft);
                newTop = snapToGrid(newTop);
                
                // Enforce screen limits
                const limited = enforceScreenLimits(draggedElement, newLeft, newTop);
                newLeft = limited.left;
                newTop = limited.top;
                
                // Always apply position during drag (allow passing over other blocks)
                draggedElement.style.left = newLeft + 'px';
                draggedElement.style.top = newTop + 'px';

                // Auto-scroll the page while dragging near viewport edges
                const edge = 80;
                if (e.clientY > window.innerHeight - edge) {
                    window.scrollBy({ top: 24, behavior: 'smooth' });
                } else if (e.clientY < edge) {
                    window.scrollBy({ top: -24, behavior: 'smooth' });
                }
                
                // Ultra-smooth collision checking - only check once and maintain state
                if (!draggedElement.lastCollisionCheck || Date.now() - draggedElement.lastCollisionCheck > 50) {
                    const hasCollision = checkCollision(draggedElement, newLeft, newTop);
                    
                    // Only update class if state actually changed
                    if (hasCollision && !draggedElement.classList.contains('collision')) {
                        draggedElement.classList.add('collision');
                    } else if (!hasCollision && draggedElement.classList.contains('collision')) {
                        draggedElement.classList.remove('collision');
                    }
                    
                    draggedElement.lastCollisionCheck = Date.now();
                }
                
                // Add snapping visual feedback
                if (!draggedElement.classList.contains('snapping')) {
                    draggedElement.classList.add('snapping');
                }
            }

            function handleMouseUp(e) {
                if (!draggedElement) return;
                
                // Clear any pending collision checks and states
                if (draggedElement.collisionCheckTimeout) {
                    clearTimeout(draggedElement.collisionCheckTimeout);
                    draggedElement.collisionCheckTimeout = null;
                }
                draggedElement.lastCollisionCheck = null;
                
                const currentLeft = parseInt(draggedElement.style.left) || 0;
                const currentTop = parseInt(draggedElement.style.top) || 0;
                
                // Check if the current position would cause a collision
                if (checkCollision(draggedElement, currentLeft, currentTop)) {
                    // Find the nearest free position
                    const freePosition = findFreePosition(draggedElement, currentLeft, currentTop);
                    
                    // Animate to the free position
                    draggedElement.style.transition = 'all 0.5s cubic-bezier(0.15, 0.85, 0.3, 1)';
                    draggedElement.style.left = freePosition.left + 'px';
                    draggedElement.style.top = freePosition.top + 'px';
                    
                    // Remove transition after animation
                    setTimeout(() => {
                        if (draggedElement) {
                            draggedElement.style.transition = '';
                        }
                    }, 500);
                }
                
                // Remove all drag-related classes smoothly
                draggedElement.classList.remove('dragging', 'snapping', 'collision');
                
                // Save the final position
                setTimeout(() => {
                    if (draggedElement) {
                        saveBlockPosition(draggedElement);
                    }
                }, 500); // Wait for potential animation to complete

                if (customBlocks) {
                    customBlocks.classList.remove('show-grid');
                }
                
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                
                draggedElement = null;
            }

            function saveBlockPosition(block) {
                const blockId = block.getAttribute('data-block-id');
                const left = Number.isFinite(block.offsetLeft) ? block.offsetLeft : parseFloat(block.style.left) || 0;
                const top = Number.isFinite(block.offsetTop) ? block.offsetTop : parseFloat(block.style.top) || 0;
                const position = {
                    left: Math.round(left * 100) / 100,
                    top: Math.round(top * 100) / 100
                };
                
                let savedPositions = {};
                try {
                    savedPositions = JSON.parse(localStorage.getItem('blockPositions') || '{}') || {};
                } catch (err) {
                    savedPositions = {};
                }
                savedPositions[blockId] = position;
                localStorage.setItem('blockPositions', JSON.stringify(savedPositions));
            }

            function saveBlockOrder() {
                // In free positioning mode, we don't need traditional order
                // Instead, we save positions which is handled by saveBlockPosition
            }

            function loadBlockOrder() {
                // Legacy function - positions are now handled differently
                // Keep for backward compatibility but functionality moved to loadBlockPositions
            }

            function createNewBlock(type, config = {}, options = {}) {
                const blockConfig = config && typeof config === 'object' ? config : {};
                const blockId = options.blockId || ('block_' + Date.now());
                const newBlock = document.createElement('div');
                newBlock.className = 'custom-block';
                newBlock.setAttribute('data-block-id', blockId);
                const containerWidth = customBlocks.offsetWidth;
                const adaptiveWidth = Math.max(250, Math.min(320, containerWidth * 0.4));
                const adaptiveHeight = Math.max(160, Math.min(220, window.innerHeight * 0.25));
                const storedWidth = options.dimensions && options.dimensions.width;
                const storedHeight = options.dimensions && options.dimensions.height;
                const resolvedWidth = typeof storedWidth === 'number' ? storedWidth + 'px' : (storedWidth || (adaptiveWidth + 'px'));
                const resolvedHeight = typeof storedHeight === 'number' ? storedHeight + 'px' : (storedHeight || (adaptiveHeight + 'px'));

                // Set dimensions first so collision detection works properly
                newBlock.style.width = resolvedWidth;
                newBlock.style.height = resolvedHeight;

                // Add to container temporarily for collision detection
                newBlock.style.position = 'absolute';
                newBlock.style.left = '-9999px'; // Hide while calculating position
                newBlock.style.top = '-9999px';
                customBlocks.appendChild(newBlock);
                
                // Update blocks collection to include the new block
                blocks = document.querySelectorAll('.custom-block');

                let targetLeft;
                let targetTop;
                let restoredPosition = false;

                if (options.position) {
                    const savedLeft = typeof options.position.left === 'number' ? options.position.left : parseFloat(options.position.left);
                    const savedTop = typeof options.position.top === 'number' ? options.position.top : parseFloat(options.position.top);
                    if (!isNaN(savedLeft) && !isNaN(savedTop)) {
                        targetLeft = savedLeft;
                        targetTop = savedTop;
                        restoredPosition = true;
                    }
                }

                if (!restoredPosition) {
                    const blockWidth = newBlock.offsetWidth || parseInt(resolvedWidth, 10) || adaptiveWidth;
                    const blockHeight = newBlock.offsetHeight || parseInt(resolvedHeight, 10) || adaptiveHeight;
                    const preferredX = Math.max(0, (containerWidth - blockWidth) / 2);
                    const preferredY = Math.max(0, (customBlocks.offsetHeight - blockHeight) / 2);
                    const freePosition = findFreePosition(newBlock, preferredX, preferredY);
                    targetLeft = freePosition.left;
                    targetTop = freePosition.top;
                }

                newBlock.style.left = targetLeft + 'px';
                newBlock.style.top = targetTop + 'px';

                // Add delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '×';
                deleteBtn.title = 'Изтрий блок';
                newBlock.appendChild(deleteBtn);

                // Create content based on type
                const content = createBlockContent(type, blockConfig);
                newBlock.appendChild(content);

                newBlock.dataset.blockType = type;
                if (blockConfig && Object.keys(blockConfig).length) {
                    try {
                        newBlock.dataset.blockConfig = JSON.stringify(blockConfig);
                    } catch (err) {
                        delete newBlock.dataset.blockConfig;
                    }
                }

                const normalizedColor = normalizeColorValue(blockConfig.color || DEFAULT_BLOCK_COLOR);
                blockConfig.color = normalizedColor;
                applyBlockColor(newBlock, normalizedColor);

                // Apply edit mode if active
                if (editMode) {
                    newBlock.classList.add('edit-mode');
                    enableDragAndDrop(newBlock);
                    enableResizeMonitoring(newBlock);
                }

                // Save position and dimensions
                saveBlockPosition(newBlock);
                saveBlockDimensions(newBlock);
                updateContainerHeight();

                // Set up block-specific functionality
                setupBlockFunctionality(newBlock, type, blockConfig);

                if (!options.restoring) {
                    persistCustomBlockData(blockId, type, blockConfig);
                }
            }

            function createBlockContent(type, config = {}) {
                const content = document.createElement('div');

                switch(type) {
                    case 'reminder':
                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">📝</div>
                                <h4>Напомняния</h4>
                            </div>
                            <div class="block-content">
                                <div class="reminder-list">
                                    <div class="reminder-item">
                                        <input type="checkbox" id="remind1_${Date.now()}">
                                        <input type="text" placeholder="Добави напомняне..." value="Примерно напомняне">
                                    </div>
                                </div>
                                <button class="link-btn" onclick="addReminderItem(this)">+ Добави</button>
                            </div>
                        `;
                        break;

                    case 'music': {
                        const title = config.title || 'Музика';
                        const platform = config.platform || 'spotify';
                        const url = (config.url || '').trim();
                        const note = config.note || '';
                        const platformLabels = {
                            spotify: 'Spotify',
                            apple: 'Apple Music',
                            youtube: 'YouTube Music',
                            soundcloud: 'SoundCloud',
                            custom: 'Друго'
                        };
                        const badgeLabel = platformLabels[platform] || 'Music';
                        const hasLink = Boolean(url);
                        const safeUrl = hasLink ? url : '#';
                        const openLabel = hasLink
                            ? (platform === 'spotify'
                                ? 'Отвори в Spotify'
                                : platform === 'apple'
                                    ? 'Отвори в Apple Music'
                                    : 'Отвори плейлист')
                            : 'Добави линк от редактора';

                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">🎵</div>
                                <h4>${title}</h4>
                            </div>
                            <div class="block-content">
                                <div class="music-platform-tag ${platform}">${badgeLabel}</div>
                                <div class="song-info">
                                    <div class="song-title">${note ? note : 'Вашият музикален ъгъл'}</div>
                                    <div class="song-meta">${hasLink ? 'Връзка активна' : 'Добавете връзка от редактора'}</div>
                                </div>
                                <div class="music-controls">
                                    <button class="music-btn" data-action="previous">⏮️</button>
                                    <button class="music-btn play" data-action="toggle">▶️</button>
                                    <button class="music-btn" data-action="next">⏭️</button>
                                </div>
                                <a class="link-btn music-link${hasLink ? '' : ' disabled'}" href="${safeUrl}" ${hasLink ? 'target="_blank" rel="noopener"' : 'data-disabled="true" aria-disabled="true" tabindex="-1"'}>
                                    ${openLabel}
                                </a>
                            </div>
                        `;
                        break;
                    }

                    case 'storage':
                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">☁️</div>
                                <h4>Cloud Storage</h4>
                            </div>
                            <div class="block-content">
                                <div class="storage-options">
                                    <div class="storage-option active" data-service="dropbox">Dropbox</div>
                                    <div class="storage-option" data-service="gdrive">Google Drive</div>
                                </div>
                                <a href="https://www.dropbox.com" target="_blank" class="storage-link">
                                    Отвори Dropbox
                                </a>
                            </div>
                        `;
                        break;

                    case 'weather': {
                        const title = config.title || 'Време';
                        const location = config.location || 'София, България';
                        const normalizedUnits = (config.units === 'imperial' || config.units === 'f') ? 'imperial' : 'metric';
                        const unitSymbol = normalizedUnits === 'imperial' ? '°F' : '°C';
                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">🌤️</div>
                                <h4>${title}</h4>
                            </div>
                            <div class="block-content">
                                <div class="weather-info">
                                    <div class="weather-icon">☀️</div>
                                    <div class="weather-details">
                                        <div class="weather-temp">22${unitSymbol}</div>
                                        <div class="weather-desc">Персонализирано време</div>
                                        <div class="weather-desc">${location}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                        break;
                    }

                    case 'quote':
                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">💭</div>
                                <h4>Мотивация</h4>
                            </div>
                            <div class="block-content">
                                <div class="quote-text">
                                    "Успехът е сумата от малките усилия, повтаряни ден след ден."
                                </div>
                                <div class="quote-author">- Робърт Колиър</div>
                            </div>
                        `;
                        break;

                    case 'link':
                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">🔗</div>
                                <h4>Бърз линк</h4>
                            </div>
                            <div class="block-content">
                                <input type="url" class="link-input" placeholder="Въведете URL..." value="https://example.com">
                                <button class="link-btn" onclick="openCustomLink(this)">Отвори линк</button>
                            </div>
                        `;
                        break;

                    case 'checklist': {
                        const title = config.title || 'Чеклист';
                        const items = (config.items && config.items.length) ? config.items : ['Нова задача'];
                        const itemsHtml = items.map((item, index) => `
                            <label class="checklist-item">
                                <input type="checkbox" data-index="${index}">
                                <span>${item}</span>
                            </label>
                        `).join('');
                        const completedText = `0 от ${items.length} завършени`;

                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">✅</div>
                                <h4>${title}</h4>
                            </div>
                            <div class="block-content">
                                ${itemsHtml}
                                <div class="checklist-progress" data-total="${items.length}">
                                    <span>${completedText}</span>
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width:0%"></div>
                                    </div>
                                </div>
                            </div>
                        `;
                        break;
                    }
                    case 'calendar': {
                        const title = config.title || 'Календар';
                        const mode = config.mode || 'link';
                        const url = (config.url || '').trim();
                        const hasEmbed = mode === 'embed' && url && url.includes('calendar.google.com');
                        content.innerHTML = `
                            <div class="block-header">
                                <div class="block-icon">📅</div>
                                <h4>${title}</h4>
                            </div>
                            <div class="block-content">
                                ${hasEmbed ? `
                                    <div class="calendar-embed">
                                        <iframe src="${url}" style="border:0" loading="lazy" referrerpolicy="no-referrer-when-downgrade"></iframe>
                                    </div>
                                ` : `
                                    <div class="calendar-preview">
                                        <div class="calendar-date">
                                            <span class="day" id="calendar-day">${String(new Date().getDate()).padStart(2,'0')}</span>
                                            <span class="month">${new Date().toLocaleString('bg-BG',{ month:'short' })}</span>
                                        </div>
                                        <div class="calendar-events">
                                            <div class="event">Свържи Google Calendar от блока</div>
                                        </div>
                                    </div>
                                `}
                            </div>
                        `;
                        break;
                    }
                }

                return content;
            }

            function setupBlockFunctionality(block, type, config = {}) {
                // Base handlers should be attached only once per block.
                if (!block._baseHandlersWired) {
                    function openBlockCustomizer() {
                        const existingType = block.dataset.blockType || type;
                        let existingConfig = {};
                        if (block.dataset.blockConfig) {
                            try { existingConfig = JSON.parse(block.dataset.blockConfig); } catch (err) { existingConfig = {}; }
                        }
                        openBlockBuilder(existingType, existingConfig, block);
                    }

                    // Open the full customisation popup when the placed block is
                    // clicked (outside of edit mode) or long‑pressed.
                    block.addEventListener('click', (e) => {
                        if (editMode || isResizing) return;
                        if (e.target.closest('.delete-btn')) return;
                        if (e.target.matches('input, textarea, select, button, a')) return;
                        e.preventDefault();
                        e.stopPropagation();
                        openBlockCustomizer();
                    });

                    // --- Long‑press to edit (works even when not in edit mode) ---
                    function clearLongPressState() {
                        if (longPressTarget !== block) return;
                        if (longPressTimer) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                        }
                        longPressTarget = null;
                    }

                    function scheduleLongPress(e) {
                        if (editMode || isResizing) return; // only in normal mode
                        if (e.button !== 0 && e.type === 'mousedown') return;
                        if (e.target.closest('.delete-btn')) return;
                        const clientX = e.clientX || (e.touches && e.touches[0].clientX) || 0;
                        const clientY = e.clientY || (e.touches && e.touches[0].clientY) || 0;
                        longPressTarget = block;
                        longPressStartPos = { x: clientX, y: clientY };
                        longPressTimer = setTimeout(() => {
                            if (longPressTarget !== block) return;
                            block.classList.add('long-press-morph');
                            openBlockCustomizer();
                            setTimeout(() => {
                                block.classList.remove('long-press-morph');
                            }, 400);
                            clearLongPressState();
                        }, LONG_PRESS_DELAY);
                    }

                    function maybeCancelLongPressOnMove(e) {
                        if (longPressTarget !== block) return;
                        const cx = e.clientX || (e.touches && e.touches[0].clientX) || 0;
                        const cy = e.clientY || (e.touches && e.touches[0].clientY) || 0;
                        if (Math.abs(cx - longPressStartPos.x) > LONG_PRESS_MOVE_TOLERANCE ||
                            Math.abs(cy - longPressStartPos.y) > LONG_PRESS_MOVE_TOLERANCE) {
                            clearLongPressState();
                        }
                    }

                    block.addEventListener('mousedown', scheduleLongPress);
                    block.addEventListener('touchstart', scheduleLongPress, { passive: true });
                    ['mouseup','mouseleave','touchend','touchcancel'].forEach(ev => {
                        block.addEventListener(ev, clearLongPressState);
                    });
                    block.addEventListener('mousemove', maybeCancelLongPressOnMove);
                    block.addEventListener('touchmove', maybeCancelLongPressOnMove, { passive: true });

                    // Add delete functionality (wire once per delete button)
                    const deleteBtn = block.querySelector('.delete-btn');
                    if (deleteBtn && !deleteBtn._wiredDelete) {
                        deleteBtn._wiredDelete = true;
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (editMode) {
                                deleteBlock(block);
                            }
                        });
                    }

                    // Add hover effects
                    block.addEventListener('mouseenter', () => {
                        if (!editMode && !isResizing) {
                            block.style.transform = 'translateY(-4px)';
                            block.style.boxShadow = '0 20px 48px rgba(2,18,40,0.15)';
                        }
                    });

                    block.addEventListener('mouseleave', () => {
                        if (!editMode && !isResizing) {
                            block.style.transform = 'translateY(0)';
                            block.style.boxShadow = '0 12px 32px rgba(2,18,40,0.08)';
                        }
                    });

                    block._baseHandlersWired = true;
                }

                if (type === 'checklist') {
                    const progressWrap = block.querySelector('.checklist-progress');
                    const progressLabel = progressWrap ? progressWrap.querySelector('span') : null;
                    const progressBar = progressWrap ? progressWrap.querySelector('.progress-fill') : null;
                    const checkboxes = block.querySelectorAll('.checklist-item input[type="checkbox"]');
                    const total = progressWrap ? parseInt(progressWrap.getAttribute('data-total'), 10) || checkboxes.length : checkboxes.length;

                    const updateProgress = () => {
                        const completed = Array.from(checkboxes).filter(cb => cb.checked).length;
                        const percentage = total ? Math.round((completed / total) * 100) : 0;
                        if (progressLabel) {
                            progressLabel.textContent = `${completed} от ${total} завършени`;
                        }
                        if (progressBar) {
                            progressBar.style.width = `${percentage}%`;
                        }
                    };

                    checkboxes.forEach(cb => cb.addEventListener('change', updateProgress));
                }

                if (type === 'music') {
                    const musicLink = block.querySelector('.music-link');
                    const controls = block.querySelectorAll('.music-btn');
                    if (config.url) {
                        block.dataset.musicUrl = config.url;
                    }
                    if (config.platform) {
                        block.dataset.musicPlatform = config.platform;
                    }
                    controls.forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            const action = btn.dataset.action;
                            if (action === 'previous') {
                                previousTrack();
                            } else if (action === 'next') {
                                nextTrack();
                            } else if (action === 'toggle') {
                                togglePlay(btn);
                            }
                        });
                    });
                    if (musicLink && musicLink.dataset.disabled === 'true') {
                        musicLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            if (!editMode) {
                                return;
                            }
                            let existingConfig = {};
                            if (block.dataset.blockConfig) {
                                try { existingConfig = JSON.parse(block.dataset.blockConfig); } catch (err) { existingConfig = {}; }
                            }
                            openBlockBuilder('music', existingConfig, block);
                        });
                    }
                }

                if (type === 'weather') {
                    const normalizedUnits = (config.units === 'imperial' || config.units === 'f') ? 'imperial' : 'metric';
                    if (config.location) {
                        block.dataset.weatherLocation = config.location;
                    }
                    block.dataset.weatherUnits = normalizedUnits;
                    if (typeof initWeatherBlock === 'function') {
                        initWeatherBlock(block, config);
                    }
                }

                if (type === 'calendar') {
                    const url = (config.url || '').trim();
                    const mode = config.mode || 'link';
                    block.dataset.calendarUrl = url;
                    block.dataset.calendarMode = mode;

                    if (!block._calendarOpenHandler) {
                        block._calendarOpenHandler = (e) => {
                            if (editMode || isResizing) return;
                            if (e.target.closest('.delete-btn')) return;
                            // If the customizer opened, it will stop propagation.
                            const currentUrl = (block.dataset.calendarUrl || '').trim();
                            const currentMode = block.dataset.calendarMode || 'link';
                            e.preventDefault();
                            e.stopPropagation();
                            if (currentUrl && currentMode === 'embed') {
                                window.open(currentUrl, '_blank');
                            } else {
                                window.open('https://calendar.google.com', '_blank');
                            }
                        };
                        block.addEventListener('click', block._calendarOpenHandler);
                    }
                }
            }

            // Weather helpers (auto локация и Open-Meteo без ключ)
            const WEATHER_GEOCODE_API = 'https://geocoding-api.open-meteo.com/v1/search';
            const WEATHER_FORECAST_API = 'https://api.open-meteo.com/v1/forecast';

            async function initWeatherBlock(block, config = {}) {
                const units = block.dataset.weatherUnits || 'metric';
                const unitSymbol = units === 'imperial' ? '°F' : '°C';
                const details = block.querySelector('.weather-details');
                const tempEl = block.querySelector('.weather-temp');
                const descEls = details ? details.querySelectorAll('.weather-desc') : null;
                const summaryEl = descEls && descEls[0] ? descEls[0] : null;
                const locationEl = descEls && descEls[1] ? descEls[1] : null;

                const apply = (temp, description, label) => {
                    if (tempEl) tempEl.textContent = `${Math.round(temp)}${unitSymbol}`;
                    if (summaryEl) summaryEl.textContent = description;
                    if (locationEl && label) locationEl.textContent = label;
                };

                const fallbackLabel = config.location || (locationEl ? locationEl.textContent : '');
                if (!navigator.geolocation) {
                    if (config.location) {
                        await fetchWeatherByName(config.location, units, apply, fallbackLabel);
                    }
                    return;
                }

                navigator.geolocation.getCurrentPosition(async (pos) => {
                    const { latitude, longitude } = pos.coords;
                    await fetchWeatherByCoords(latitude, longitude, units, apply, 'Текуща локация');
                }, async () => {
                    if (config.location) {
                        await fetchWeatherByName(config.location, units, apply, fallbackLabel);
                    }
                }, { enableHighAccuracy: false, timeout: 7000, maximumAge: 600000 });
            }

            async function fetchWeatherByCoords(lat, lon, units, apply, label) {
                try {
                    const url = new URL(WEATHER_FORECAST_API);
                    url.searchParams.set('latitude', lat);
                    url.searchParams.set('longitude', lon);
                    url.searchParams.set('current_weather', 'true');
                    url.searchParams.set('timezone', 'auto');
                    if (units === 'imperial') {
                        url.searchParams.set('temperature_unit', 'fahrenheit');
                    }
                    const res = await fetch(url.toString());
                    const data = await res.json();
                    if (!data || !data.current_weather) return;
                    const temp = data.current_weather.temperature;
                    apply(temp, 'Текущо време', label);
                } catch (err) {
                    console.warn('Weather fetch error (coords)', err);
                }
            }

            async function fetchWeatherByName(name, units, apply, fallbackLabel) {
                try {
                    const url = new URL(WEATHER_GEOCODE_API);
                    url.searchParams.set('name', name);
                    url.searchParams.set('count', '1');
                    url.searchParams.set('language', 'bg');
                    url.searchParams.set('format', 'json');
                    const res = await fetch(url.toString());
                    const data = await res.json();
                    if (!data || !data.results || !data.results.length) return;
                    const place = data.results[0];
                    const label = place.name + (place.country ? `, ${place.country}` : '');
                    await fetchWeatherByCoords(place.latitude, place.longitude, units, apply, label);
                } catch (err) {
                    console.warn('Weather geocode error', err);
                    if (fallbackLabel) {
                        apply(22, 'Персонализирано време', fallbackLabel);
                    }
                }
            }

            function deleteBlock(block) {
                const blockId = block.getAttribute('data-block-id');
                const defaultBlock = isDefaultBlock(block);
                if (defaultBlock) {
                    markDefaultBlockRemoved(blockId);
                } else {
                    removeCustomBlockData(blockId);
                }
                
                // Remove from localStorage
                let savedPositions = {};
                let savedDimensions = {};
                try {
                    savedPositions = JSON.parse(localStorage.getItem('blockPositions') || '{}') || {};
                } catch (err) {
                    savedPositions = {};
                }
                try {
                    savedDimensions = JSON.parse(localStorage.getItem('blockDimensions') || '{}') || {};
                } catch (err) {
                    savedDimensions = {};
                }
                delete savedPositions[blockId];
                delete savedDimensions[blockId];
                localStorage.setItem('blockPositions', JSON.stringify(savedPositions));
                localStorage.setItem('blockDimensions', JSON.stringify(savedDimensions));

                // Remove from DOM
                block.remove();

                // Update blocks collection
                blocks = document.querySelectorAll('.custom-block');
                updateContainerHeight();
            }

            // Add delete functionality to existing blocks
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (editMode) {
                        deleteBlock(btn.closest('.custom-block'));
                    }
                });
            });

            // Original functionality (only when not in edit mode)
            const calendarBlock = document.querySelector('.calendar-block');
            const homeworkBlock = document.querySelector('.homework-block');
            const curriculumBlock = document.querySelector('.curriculum-block');

            function addBlockClickHandler(block, handler) {
                block.addEventListener('click', (e) => {
                    if (!editMode && !isResizing) {
                        handler(e);
                    }
                });
            }

            // Calendar block click handler
            addBlockClickHandler(calendarBlock, () => {
                window.open('https://calendar.google.com', '_blank');
            });

            // Homework block functionality
            const homeworkCheckboxes = document.querySelectorAll('.homework-item input[type="checkbox"]');
            const progressElement = document.querySelector('.homework-progress span');
            
            function updateHomeworkProgress() {
                const total = homeworkCheckboxes.length;
                const completed = Array.from(homeworkCheckboxes).filter(cb => cb.checked).length;
                progressElement.textContent = `${completed} от ${total} завършени`;
            }

            homeworkCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', updateHomeworkProgress);
            });

            // Homework block click handler
            addBlockClickHandler(homeworkBlock, (e) => {
                if (e.target.type === 'checkbox' || e.target.tagName === 'LABEL') return;
                alert('Домашни задания - функцията ще бъде добавена скоро!');
            });

            // Curriculum block click handler
            addBlockClickHandler(curriculumBlock, () => {
                alert('Учебна програма - настройките ще бъдат достъпни в менюто Settings!');
            });

            // Add hover effects to custom blocks (only when not in edit mode or resizing)
            blocks.forEach(block => {
                block.addEventListener('mouseenter', () => {
                    if (!editMode && !isResizing) {
                        block.style.transform = 'translateY(-4px)';
                        block.style.boxShadow = '0 20px 48px rgba(2,18,40,0.15)';
                    }
                });
                
                block.addEventListener('mouseleave', () => {
                    if (!editMode && !isResizing) {
                        block.style.transform = 'translateY(0)';
                        block.style.boxShadow = '0 12px 32px rgba(2,18,40,0.08)';
                    }
                });
            });
        })();
    </script>

    <script>
        // Add 'lift' on mouseenter and 'land' on mouseleave for cards and icon buttons
        (function(){
            if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
            const els = document.querySelectorAll('.card, .icon-btn');
            els.forEach(el=>{
                el.addEventListener('mouseenter', ()=>{
                    el.classList.remove('land');
                    el.classList.add('lift');
                });
                el.addEventListener('mouseleave', ()=>{
                    // on leave, remove lift and run land animation once
                    el.classList.remove('lift');
                    // force reflow so animation can replay reliably
                    void el.offsetWidth;
                    el.classList.add('land');
                });
                // Clean up class when animation ends
                el.addEventListener('animationend', (ev)=>{
                    // only remove when our land animation finishes
                    if(ev.animationName && ev.animationName.indexOf('land')!==-1){
                        el.classList.remove('land');
                    }
                });
            });
        })();
    </script>

    <script>
        // single-run sheen control for icon buttons, cards, and custom blocks
        (function(){
            if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
            const targets = document.querySelectorAll('.icon-btn, .card, .custom-block');
            function finishOutgoing(){
                document.querySelectorAll('.sheen-back').forEach(el=>{
                    // force it to its end state, then remove classes shortly after
                    el.classList.add('sheen-end');
                    // force reflow so styles apply
                    void el.offsetWidth;
                    setTimeout(()=> el.classList.remove('sheen-back','sheen-end'), 50);
                });
            }
            function addOnce(el, cls){
                // Don't add sheen if resizing, in edit mode, or actively being resized
                if (el.classList.contains('resizing') || 
                    el.classList.contains('dragging') ||
                    (el.classList.contains('custom-block') && 
                     (el.closest('.custom-blocks').classList.contains('resizing-active') ||
                      el.classList.contains('edit-mode')))) {
                    return;
                }
                
                // finish any outgoing sheen animations first so they don't linger
                finishOutgoing();
                el.classList.remove('sheen-run','sheen-back');
                // force reflow
                void el.offsetWidth;
                el.classList.add(cls);
            }
            targets.forEach(el=>{
                el.addEventListener('mouseenter', ()=> addOnce(el,'sheen-run'));
                el.addEventListener('mouseleave', ()=> addOnce(el,'sheen-back'));
                el.addEventListener('animationend', (ev)=>{
                    // only remove when our sheen animation finishes
                    if(ev.animationName && ev.animationName.indexOf('button-sheen')!==-1){
                        el.classList.remove('sheen-run','sheen-back');
                    }
                });
            });
        })();
    </script>

    <script>
        // reflection: update --mx/--my and fade the reflection according to pointer
        (function(){
            if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
            const btns = document.querySelectorAll('.icon-btn');
            btns.forEach(btn=>{
                btn.addEventListener('mousemove', (e)=>{
                    const r = btn.getBoundingClientRect();
                    const x = ((e.clientX - r.left)/r.width)*100;
                    const y = ((e.clientY - r.top)/r.height)*100;
                    btn.style.setProperty('--mx', x + '%');
                    btn.style.setProperty('--my', y + '%');
                    btn.style.setProperty('--ref-opacity', '0.9');
                });
                btn.addEventListener('mouseenter', ()=> btn.style.setProperty('--ref-opacity','0.9'));
                btn.addEventListener('mouseleave', ()=> btn.style.setProperty('--ref-opacity','0'));
            });

            // pill reflection
            const pills = document.querySelectorAll('.pill');
            pills.forEach(pill=>{
                pill.addEventListener('mousemove', (e)=>{
                    const r = pill.getBoundingClientRect();
                    const x = ((e.clientX - r.left)/r.width)*100;
                    const y = ((e.clientY - r.top)/r.height)*100;
                    pill.style.setProperty('--mx', x + '%');
                    pill.style.setProperty('--my', y + '%');
                    pill.style.setProperty('--pill-ref-opacity', '0.85');
                });
                pill.addEventListener('mouseenter', ()=> pill.style.setProperty('--pill-ref-opacity','0.85'));
                pill.addEventListener('mouseleave', ()=> pill.style.setProperty('--pill-ref-opacity','0'));
            });
        })();
    </script>

    <script>
        // Helper functions for specific block types
        function addReminderItem(button) {
            const reminderList = button.parentElement.querySelector('.reminder-list');
            const newItem = document.createElement('div');
            newItem.className = 'reminder-item';
            const itemId = 'remind' + Date.now();
            newItem.innerHTML = `
                <input type="checkbox" id="${itemId}">
                <input type="text" placeholder="Добави напомняне..." value="">
            `;
            reminderList.appendChild(newItem);
        }

        function togglePlay(button) {
            const playBtn = button || (typeof event !== 'undefined' ? event.target : null);
            if (!playBtn) return;
            if (playBtn.textContent === '▶️') {
                playBtn.textContent = '⏸️';
                // Тук можеш да вържеш реален плейбек (Spotify SDK / Apple Music и т.н.)
            } else {
                playBtn.textContent = '▶️';
                // Пауза на плейбек
            }
        }

        // --- AI помощ за чеклист блоковете (реално време, ако има AI endpoint) ---
        async function callChecklistAI(prompt) {
            const endpoint = window.WORKER || window.STUDYSPACE_AI_ENDPOINT || window.STUDYSPACE_AI_WORKER;
            if (!endpoint) return null;
            try {
                const res = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt })
                });
                const data = await res.json().catch(() => null);
                if (data && typeof data.answer === 'string') return data.answer.trim();
                if (data && typeof data === 'string') return data.trim();
            } catch (err) {
                console.warn('Checklist AI error', err);
            }
            return null;
        }

        function maybeScheduleChecklistAI(inputEl) {
            const aiEnabled = !!window.checklistAIEnabled;
            const endpoint = window.WORKER || window.STUDYSPACE_AI_ENDPOINT || window.STUDYSPACE_AI_WORKER;
            if (!inputEl || !aiEnabled || !endpoint) return;

            const base = (inputEl.value || '').trim();
            if (base.length < 6) return;

            if (inputEl._aiTimer) {
                clearTimeout(inputEl._aiTimer);
            }

            inputEl._aiTimer = setTimeout(async () => {
                const latest = (inputEl.value || '').trim();
                if (latest !== base) return; // потребителят е продължил да пише

                const prompt = `Ти си интелигентен асистент за учебни чеклисти. Довърши това заглавие или задача на български по естествен начин. Върни само завършеното изречение, без обяснения. Текст: "${base}"`;
                const suggestion = await callChecklistAI(prompt);
                if (!suggestion) return;

                let finalText = suggestion.trim();
                if (finalText.toLowerCase().startsWith(base.toLowerCase())) {
                    inputEl.value = finalText;
                } else if (finalText.length > base.length && finalText.toLowerCase().includes(base.toLowerCase())) {
                    inputEl.value = finalText;
                }
            }, 700);
        }

        function previousTrack() {
            // Add previous track logic
            console.log('Previous track');
        }

        function nextTrack() {
            // Add next track logic
            console.log('Next track');
        }

        function openCustomLink(button) {
            const linkInput = button.parentElement.querySelector('.link-input');
            const url = linkInput.value;
            if (url && url.trim() !== '') {
                window.open(url, '_blank');
            }
        }

        // Storage service switching
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('storage-option')) {
                const storageOptions = e.target.parentElement;
                const storageLink = storageOptions.parentElement.querySelector('.storage-link');
                
                // Remove active class from all options
                storageOptions.querySelectorAll('.storage-option').forEach(opt => {
                    opt.classList.remove('active');
                });
                
                // Add active class to clicked option
                e.target.classList.add('active');
                
                // Update link
                const service = e.target.getAttribute('data-service');
                if (service === 'dropbox') {
                    storageLink.href = 'https://www.dropbox.com';
                    storageLink.textContent = 'Отвори Dropbox';
                } else if (service === 'gdrive') {
                    storageLink.href = 'https://drive.google.com';
                    storageLink.textContent = 'Отвори Google Drive';
                }
            }
        });

        // Prevent edit mode activation when interacting with form elements
        document.addEventListener('click', function(e) {
            if (e.target.matches('input, button, .storage-option, .music-btn') && 
                e.target.closest('.custom-block')) {
                e.stopPropagation();
            }
        });

        // Add click / drag handler for "Нова +" button to redirect to Flashcardcreate.html
        document.addEventListener('DOMContentLoaded', function() {
            const IMPORT_KEY = 'studyspace_import_payload';
            const newCardButton = document.querySelector('.card.add');

            function isFileDrag(event){
                const dt = event.dataTransfer;
                if(!dt) return false;
                if(dt.types && Array.from(dt.types).includes('Files')) return true;
                return dt.files && dt.files.length > 0;
            }

            async function handleImportDrop(fileList){
                const files = Array.from(fileList || []);
                if(!files.length) return;
                const payload = [];
                const readers = [];

                files.forEach(file => {
                    const item = { name:file.name, type:file.type, size:file.size, text:'' };
                    payload.push(item);
                    const lower = (file.type || '').toLowerCase();
                    const isTextLike = lower.startsWith('text/') ||
                        lower.includes('json') ||
                        lower.includes('xml') ||
                        lower.includes('markdown');
                    if(isTextLike){
                        readers.push(new Promise(resolve => {
                            const r = new FileReader();
                            r.onload = (e) => {
                                try{
                                    item.text = String(e.target.result || '').slice(0, 8000);
                                } catch(_){}
                                resolve();
                            };
                            r.onerror = () => resolve();
                            r.readAsText(file);
                        }));
                    }
                });

                try { await Promise.all(readers); } catch(_){ }

                try {
                    sessionStorage.setItem(IMPORT_KEY, JSON.stringify(payload));
                } catch(_){ }

                window.location.href = 'Flashcardcreate.html?import=1';
            }

            if (newCardButton) {
                newCardButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    window.location.href = 'Flashcardcreate.html';
                });

                let dragDepth = 0;

                newCardButton.addEventListener('dragenter', (e) => {
                    if(!isFileDrag(e)) return;
                    e.preventDefault();
                    dragDepth += 1;
                    newCardButton.classList.add('drag-ready');
                });

                newCardButton.addEventListener('dragover', (e) => {
                    if(!isFileDrag(e)) return;
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                });

                newCardButton.addEventListener('dragleave', (e) => {
                    if(!isFileDrag(e)) return;
                    e.preventDefault();
                    dragDepth = Math.max(dragDepth - 1, 0);
                    if(dragDepth === 0){
                        newCardButton.classList.remove('drag-ready');
                    }
                });

                newCardButton.addEventListener('drop', (e) => {
                    if(!isFileDrag(e)) return;
                    e.preventDefault();
                    dragDepth = 0;
                    newCardButton.classList.remove('drag-ready');
                    const files = e.dataTransfer ? e.dataTransfer.files : null;
                    handleImportDrop(files);
                });
            }

            // Fetch and render recent flashcards for authenticated users
            const recentContainer = document.getElementById('recentCards');
            function stripAndSnippet(html, limit = 110){
                const text = (html || '').replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
                if(!text) return '';
                return text.length <= limit ? text : text.slice(0, limit) + '…';
            }
          // 1. ЗАРЕЖДАНЕ НА КАРТИ ОТ SUPABASE
async function renderRecentCards() {
    const container = document.getElementById('recentCards');
    const sb = window.supabaseClient;
    if (!container || !sb) return;

    try {
        // Get current user
        const { data: { user } } = await sb.auth.getUser();
        if (!user) return;

        // Fetch up to 2 last-used libraries from recent_libraries
        const { data: recent, error: recentErr } = await sb
            .from('recent_libraries')
            .select('*')
            .eq('user_id', user.id)
            .order('last_used', { ascending: false })
            .limit(2);

        if (recentErr) throw recentErr;

        const addBtn = container.querySelector('.card.add');
        container.innerHTML = '';
        if (addBtn) container.appendChild(addBtn);

        if (recent && recent.length > 0) {
            recent.forEach((item) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                cardDiv.onclick = () => window.location.href = item.url;
                cardDiv.innerHTML = `
                    <div class="card-content" style="text-align:center">
                        <div style="font-size:10px;opacity:0.6;margin-bottom:5px;">ПОСЛЕДНО ОТВАРЯНА</div>
                        <div class="label" style="font-size:14px;font-weight:800;">${escapeHtml(item.name)}</div>
                    </div>
                `;
                container.appendChild(cardDiv);
            });
        } else {
            // no recent rows found: keep a couple of placeholders
            for (let i = 0; i < 2; i++) {
                const placeholder = document.createElement('div');
                placeholder.className = 'card';
                placeholder.innerHTML = `<div class="card-content" style="text-align:center"><div style="font-size:14px;font-weight:800">Последно използвани</div><div class="label">карта</div></div>`;
                container.appendChild(placeholder);
            }
        }
    } catch (err) { console.warn('Cards load error:', err); }
}

// small helper to avoid unsafe HTML in deck names
function escapeHtml(unsafe) {
    return (unsafe || '').replace(/[&<>"']/g, function(m) { return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'})[m]; });
}

async function syncBlockToCloud(el) {
    const sb = window.supabaseClient;
    if (!sb || !el) return;
    try {
        const { data: { user } } = await sb.auth.getUser();
        if (!user) return;

        const blockId = el.getAttribute('data-id') || el.id;
        const blockData = {
            user_id: user.id,
            block_key: blockId,
            type: el.getAttribute('data-type') || 'custom',
            position: { 
                x: parseFloat(el.getAttribute('data-x')) || 0, 
                y: parseFloat(el.getAttribute('data-y')) || 0 
            },
            style: {
                width: el.style.width,
                height: el.style.height,
                backgroundColor: el.style.backgroundColor || ''
            }
        };

        // Записваме в базата данни
        await sb.from('user_blocks').upsert(blockData, { onConflict: 'user_id, block_key' });
    } catch (err) { console.warn('Sync failed:', err); }
}

// Функциите за запис при местене/оразмеряване
function saveBlockPositions() { document.querySelectorAll('.block-item, .custom-block').forEach(syncBlockToCloud); }
function saveBlockDimensions() { document.querySelectorAll('.block-item, .custom-block').forEach(syncBlockToCloud); }
            
// Заместваме старите локални функции
function saveBlockPositions() { document.querySelectorAll('.block-item, .custom-block').forEach(syncBlockToCloud); }
function saveBlockDimensions() { document.querySelectorAll('.block-item, .custom-block').forEach(syncBlockToCloud); }

// 3. ЗАРЕЖДАНЕ НА ПЕРСОНАЛИЗАЦИЯТА ПРИ СТАРТ
async function loadUserCustomization() {
    const sb = window.supabaseClient;
    if (!sb) return;
    try {
        const { data: { user } } = await sb.auth.getUser();
        if (!user) return;

        const { data: blocks, error } = await sb
            .from('user_blocks')
            .select('*')
            .eq('user_id', user.id);

        if (error) throw error;

        if (blocks && blocks.length > 0) {
            const container = document.querySelector('.custom-blocks');
            if (container) container.innerHTML = ''; 

            blocks.forEach(b => {
                if (typeof createNewBlock === 'function') {
                    createNewBlock(b.type || 'custom', b.style, {
                        blockId: b.block_key,
                        position: b.position,
                        restoring: true
                    });
                }
            });
        }
    } catch (err) { console.warn('Restore failed:', err); }
}

// Инициализация
setTimeout(renderRecentCards, 800);
setInterval(renderRecentCards, 60000);
setTimeout(loadUserCustomization, 1200);

}); // end DOMContentLoaded handler
    
    </script>
                                  

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

<style>
    /* Поправка на иконите и менюто */
    .profile-dropdown ul li a {
        display: flex !important;
        align-items: center !important;
        gap: 12px !important;
        padding: 10px 20px !important;
        color: #333 !important;
        text-decoration: none !important;
    }
    .profile-dropdown ul li a i {
        width: 20px;
        text-align: center;
        color: #4a90e2;
        font-size: 16px;
    }
</style>

<script>
/**
 * STUDYSPACE - SUPABASE INTEGRATION REPAIR
 */
(function() {
    let checkInterval;
    let attempts = 0;

    async function startDynamicLoading() {
        // Използваме споделения Supabase клиент от window.supabaseClient
        const sb = window.supabaseClient;

        if (!sb || typeof sb.from !== 'function') {
            if (attempts < 20) {
                attempts++;
                return; // Продължаваме да чакаме
            }
            console.error("Инжекция: Supabase не бе намерен след 10 секунди.");
            clearInterval(checkInterval);
            return;
        }

        // Ако го намерим, спираме интервала и действаме
        clearInterval(checkInterval);
        console.log("Инжекция: Supabase е зареден успешно!");

        try {
            const { data: { user } } = await sb.auth.getUser();
            if (!user) return;

            // Зареждане на библиотеките
            const { data: recent, error: recentErr } = await sb
                .from('recent_libraries')
                .select('*')
                .eq('user_id', user.id)
                .order('last_used', { ascending: false })
                .limit(2);

            if (recentErr) throw recentErr;

            const addBtn = container.querySelector('.card.add');
            container.innerHTML = '';
            if (addBtn) container.appendChild(addBtn);

            if (recent && recent.length > 0) {
                recent.forEach((item) => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card';
                    cardDiv.onclick = () => window.location.href = item.url;
                    cardDiv.innerHTML = `
                        <div class="card-content" style="text-align:center">
                            <div style="font-size:10px;opacity:0.6;margin-bottom:5px;">ПОСЛЕДНО ОТВАРЯНА</div>
                            <div class="label" style="font-size:14px;font-weight:800;">${escapeHtml(item.name)}</div>
                        </div>
                    `;
                    container.appendChild(cardDiv);
                });
            } else {
                // no recent rows found: keep a couple of placeholders
                for (let i = 0; i < 2; i++) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'card';
                    placeholder.innerHTML = `<div class="card-content" style="text-align:center"><div style="font-size:14px;font-weight:800">Последно използвани</div><div class="label">карта</div></div>`;
                    container.appendChild(placeholder);
                }
            }
        } catch (err) {
            console.error("Грешка при комуникация със Supabase:", err.message);
        }
    }

    // Проверяваме на всеки 500ms дали Supabase е зареден
    checkInterval = setInterval(startDynamicLoading, 500);

    // Глобална функция за запис (за твоите бутони долу)
    window.logLib = async function(name, url) {
        const sb = window.supabaseClient;
        if (!sb) return;
        const { data: { user } } = await sb.auth.getUser();
        if (!user) return;

        await sb.from('recent_libraries').upsert({
            user_id: user.id,
            name: name,
            url: url,
            last_used: new Date().toISOString()
        }, { onConflict: 'user_id, name' });
    };
})();
</script>
